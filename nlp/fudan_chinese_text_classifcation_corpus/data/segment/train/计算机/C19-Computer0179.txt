软件 学报 
 JOURNAL   OF   SOFTWARE 
 2000 　 Vol.11 　 No.2 　 P.187 - 194 
 
 
 
 用 计算 函数 模型 增强 数据流 分析 
 胡世亮 　 臧斌宇 　 朱传琪 
 摘 　 要 ： 精确 的 数据流 分析 , 需要 充分利用 条件 分支 语句 的 逻辑 语义 . 为了 简洁 而 有效 地 处理 条件 分支 语句 , 该文 提出 了 对应 于 程序段 的 计算 函数 模型 , 在 该 模型 里 表示 条件 分支 语句 的 逻辑 语义 , 并 利用 文中 提出 的 不确定性 消解 方法 , 可以 把 通常 需要 逻辑推理 来 处理 的 数据流 分析 问题 转化 为 空间 区域 之间 覆盖 关系 的 判定 问题 . 而 这个 问题 在 并行 化 编译 的 理论 和 实践 中 已有 比较 成熟 的 解决办法 . 
 关键词 ： 计算 函数 模型 , 数据流 分析 , 条件 分支 语句 , Omega 区域 . 
 分类号 ： TP314 
 Enhancing   Dataflow   Analysis   with   Computation   Function   Model 
 HU   Shi - liang 　 ZANG   Bin - yu 　 ZHU   Chuan - qi 
 ( Institute   of   Parallel   Processing   Fudan   University   Shanghai   200433 ) 
 Abstract ： A   precise   dataflow   analysis   should   effectively   exploit   the   semantic   information   presented   by   conditional   branch   statements . Most   traditional   systems , however , either   ignore   the   logical   conditions , or   try   hard   to   handle   logical   conditions   with   logical   reasoning   which   is   rather   difficult   and   infeasible   for   paralleling   systems . With   the   aim   to   solve   this   problem   efficiently   and   effectively , the   authors   introduce   the   computation   function   model   and   then   successfully   convert   the   logical   reasoning   problems   into   problems   of   deciding   the   coverage   relationship   of   Omega   regions   which   are   substantially   more   feasible   to   be   solved   by   contemporary   paralleling   compilers . 
 Key   words ： Computation   function   model , dataflow   analysis , conditional   branch   statement , omega   region . ▲ 
 　 　 数据流 分析 和 相关性 测试 是 并行 化 编译器 分析程序 潜在 并行性 的 主要 方法 . 实践证明 , 在 并行 化 科学计算 程序 方面 , 它们 已经 取得 了 令人鼓舞 的 成果 ［ 1 ］ . 而 依然 存在 的 问题 之一 是 , 现有 的 分析方法 还 不 善于 利用 条件 分支 语句 的 逻辑 语义 , 因而 难以 充分 开发 程序 的 潜在 并行性 . 
 　 　 并行 化 编译器 主要 开发 粗粒度 并行性 . 需要 并行 化 的 代码段 是 程序 中 计算 量 大 、 执行 时间 占 总 执行 时间 相当 比例 的 关键 代码段 . 理论 推测 和 实际 统计 都 表明 , 在 应用程序 中 广泛 出现 的 条件 分支 语句 , 在所难免 地会 影响 对于 程序 关键 代码段 的 并行性 分析 . 如果 不能 有效 地 利用 条件 分支 语句 提供 的 语义 信息 , 那么 对 程序 关键 代码段 的 并行性 分析 就会 流于 保守 , 错失 并行计算 带来 的 巨大 收益 . 
 　 　 传统 的 数据流 分析 ［ 2 , 3 ］ 侧重 分析 过程 的 简捷 , 对 条件 分支 语句 的 逻辑 语义 基本上 予以 忽略 . 文献 ［ 4 ］ 等 在 分析 了 程序 自动 并行 化 方面 依然 存在 的 主要 问题 后 认为 , 充分利用 条件 分支 语句 的 逻辑 语义 势在必行 . 在 文献 ［ 5 ］ 中用 带 条件 谓词 的 符号 表示法 处理 该类 问题 , 其实质 是 Wolfe 提出 的 φ - function 表示法 的 扩充 . 此外 , 还有 在 文献 ［ 6 ］ 中 提出 的 Guarded   Array   Region 等 . 它们 都 试图 在 条件 谓词 上 实施 逻辑推理 来 导出 精确 的 数据流 信息 . 但 遗憾 的 是 , 完备 的 自动化 逻辑推理 系统 , 实现 起来 代价 太高 , 集成 到 实用化 的 并行 化 编译器 里 并 不 现实 . 本文 提出 的 与 程序段 相对 应 的 计算 函数 模型 , 试图 为此 找到 一种 简单 而 有效 的 解决方案 . 
 　 　 本质 上 , 逻辑推理 和 计算 函数 模型 是 同一个 问题 的 求解 在 不同 数学模型 下 的 表示 与 运算 . 而 计算 函数 模型 相对 于 逻辑推理 的 好处 在于 : 概念 上 的 简洁 、 统一 , 该 模型 拓广 了 数据流 分析 中 的 数组 区域 及其 覆盖 的 概念 以 统一 处理 条件 的 或非 条件 的 定义 - 引用 数据流 关系 , 问题 的 表述 和 求解 简洁 、 统一 ; 宜于 在 现有 系统 中 实现 . 概念 上 的 简洁 、 统一 使得 实现 是 在 既有 系统 上 的 拓广 扩充 , 又 无需 在 数据流 分析 的 框架 下 再 引入 逻辑推理 系统 . 
 　 　 本文 第 1 部分 介绍 引入 的 计算 函数 模型 . 第 2 部分 阐述 该 模型 下 条件 分支 语句 的 语义 . 第 3 和 第 4 部分 讨论 如何 利用 该 模型 解决 条件 分支 语句 所 带来 的 两类 重要 问题 . 最后 得出结论 . 
 　 　 条件 分支 语句 形式多样 , 如 C / C++ , Java , FORTRAN , Pascal 等 程序设计 语言 中 出现 的 各种 IF 语句 、 Switch 语句 、 case 语句 等 , 其中 IF 语句 出现 得 尤为 广泛 , 本文 约定 : 所 提到 的 IF 语句 和 条件 分支 语句 含义 等价 , 另外 , 约定 下列 标记符号 和 相关 的 算符 , 见表 1 . 
 Table   1   Conventions   for   some   symbols 
 表 1   有关 的 符号 约定 
 
 Symbol ① Name ② Explanation ③ 
 PProgram   segment ④ A   segment   of   program   ( in   Fortran , C   etc . ) ⑤ 
 r \ wRead / write   reference ⑥ Read   / write   reference   to   a   variable   ( including   array ) ⑦ 
 x , XReference , reference   set ⑧ Reference   to   a   variable   ( x   can   be   r , ri , w , wi ) 
 RP \ WPRead / write   set ⑨ All   read / write   reference   to   the   inspected 
 variable   in   the   program   segment   P 
 NaWrPNon   anti - dependence   write   setThe   non   anti - dependence   write 
 set   of   r   in   the   program   segment   P * 
 SetP ( x ) Reference   element   setThe   set   of   all   array   elements   or   variables   referred   by   x   in   program   segment   P   ( the   set   is   null   when   x   isn ' t   in   the   program   P ) 
 
 
 ① 符号 , ② 名称 , ③ 解释 , ④ 程序段 , ⑤ 一段 被 编译 的 程序 , ⑥ 读 / 写 引用 , ⑦ 对 变量 ( 包括 数组 , 下同 ) 的 读 / 写 引用 , ⑧ 引用 , 引用 集 , ⑨ 对 变量 的 引用 ( x 可以 取值 为 r , ri , w , wi )   读 / 写集 , 程序段 P 中 对 被 考察 变量 所有 读 / 写 引用 , 无反 相关 写集 , 程序段 P 中 关于 r 的 无反 相关 写集 , 引用 元素 集 , x 在 P 中 引用 的 所有 变量 , 数组 元素 的 集合 ( x ) 不 在 P 中时 为 空集 . 
 1   程序 的 计算 函数 模型 及其 相关 的 基本概念 
 　 　 在 可 计算 理论 里 , 任何 程序 都 可以 视为 一个 从 输入 数据 空间 到 输出 数据 空间 的 函数 映射 . 设 m , n 分别 为 输入 、 输出 空间 的 维数 , 那么 程序 对应 于 映射 : Ψ ( m ) P : Zm → Zn . 同理 , 在 数据流 分析 过程 中 , 对于 当前 被 分析 的 程序段 P , 也 可以 采用 这种 函数 映射 式 的 程序 模型 . 
 1.1   程序 的 计算 函数 模型 
 　 　 定义 1.1 . 程序段 P 的 定义 变量 集 In ( P ) = { x1 , x2 , ... , xm } 表示 P 执行 时 , 读 引用 之前 P 未定义 的 所有 变量 的 集合 , 程序段 P 的 定义域 为 : Dom ( P ) = Dx1 × Dx2 × ... × Dxm . 
 　 　 定义 1.2 . 程序段 P 的 映象 变量 集 Out ( P ) = { y1 , y2 , ... , yn } 表示 P 执行 时 定义 , 并且 被 程序 其他 部分 读 引用 的 变量 集合 , 程序段 P 的 值域 为 : Range ( P ) = Dy1 × Dy2 × ... × Dym . 
 　 　 这里 , Dxi 是 xi 的 定义域 , Dyi 是 yi 的 定义域 . 
 　 　 定义 1.3 . 程序段 P 的 计算 函数 模型 定义 为 向 量值 函数 映射 : fP : Dom ( P ) → Range ( P ) . 
 　 　 在 上述 定义 中 , 把 数组 和 数组 的 子 区域 ( subarray ) 视为 一组 分立 的 变量 , 带 下 标的 数组 元素 引用 视为 一个 普通 变量 . 有些 程序段 有 对 其 输入 变量 集 进行 约束 的 条件 谓词 φ ( x1 , x2 , ... , xm ) , 此时 , 程序段 P 的 定义域 应该 是 : 
 Dom ( P ) = { ( x1 , x2 , ... , xm ) | φ ( x1 , x2 , ... , xm ) = True } . 
 　 　 为了 在 上述 计算 函数 程序 模型 的 基础 上 进行 推理 , 我们 还 假设 了 下面 的 程序执行 方式 . 
 　 　 确定性 执行 假设   对于 程序段 P 定义域 中 的 任何 确定 的 一点 ( 对应 着 程序段 P 的 一次 实例 执行 ) : ( x1 , x2 , ... , xm ) ∈ Dom ( P ) , 程序段 P 的 执行 是 完全 确定 的 , 这种 确定性 包括 : 
 　 　 P 的 In ( P ) = { x1 , x2 , ... , xm } 和 Out ( P ) = { y1 , y2 , ... , yn } 确定 ; 
 　 　 P 计算 结束 后 Out ( P ) = { y1 , y2 , ... , yn } 中 的 值 也 是 确定 的 . 即 P 是 确定性 的 程序 , fP 是 严格 数学 意义 下 的 函数 映射 ; 
 　 　 条件 分支 语句 的 转向 确定 . 
 　 　 确定性 执行 假设 对于 我们 后面 的 推理 有着 基本 的 重要性 , 并且 常见 的 程序设计 语言 一般 都 满足 上述 假设 . 
 1.2   不确定性 概念 的 引入 
 　 　 定义 1.4 . 如果 AIn ( P ) , A ≠ , 当 A 中 的 变量 由于 不同 的 执行 实例 而 有 不同 取值 时 , In ( P ) 或 Out ( P ) 也 在 该 实例 的 后续 执行 中 取值 为 不同 的 变量 集 , 则 称 程序段 P 是 数据流 不 确定 的 . 而 A 中 的 变量 是 造成 这种 不确定性 的 变量 , 在 编译器 中 需要 进行 符号分析 , 我们 称之为 关键 值 变量 或 符号 变量 . 
 　 　 我们 称 程序段 P 的 数据流 不 确定 现象 为流 不确定性 , 流 不确定性 主要 由 条件 分支 语句 、 指针 别名 等 产生 ; 也 会 由于 某些 关键 值 的 不 确定 、 数据 引用 以及 DO 语句 的 迭代 范围 等 导致 . 其 直观 意义 是 , 程序段 P 对于 某些 变量 是否 进行 了 读写 由于 是 在 一定 逻辑 条件 下 进行 的 , 或 读写 的 范围 由于 某些 变量值 的 不 明确 而 产生 数据流 不 确定 现象 . 
 　 　 当 数据流 确定 时 , 如果 对于 编译器 来说 , 变量 定义 的 具体 数值 不 明确 , 我们 则 称之为 值 不确定性 . 值 不确定性 可以 由 表达式 、 条件 分支 语句 、 程序 变量 的 输入 值 等 导致 . 其 直观 含义 是 : 程序段 P 的 读写 引用 区域 是 确定 的 , 但 程序段 P 中 具体 数值 计算 的 映射 关系 不 明确 . 
 　 　 在 确定性 执行 假设 下 , 程序 数据流 信息 的 不确定性 源自 程序 输入 数据 的 不 确定 ( 可以 是 Dom ( P ) 中 的 任何 一点 ) , 或 计算 结构 的 复杂度 超出 编译器 的 分析 能力 . 
 　 　 任何 程序段 P 都 可以 视为 是 某个 可 计算 函数 f 的 实现 , 编译器 的 任务 是 产生 一个 同 f 等价 的 映射 foptimized : 它 和 f 具有 在 Dom ( P ) 内 完全相同 的 值 对应 关系 , 只是 foptimized 必须 具有 更加 适合 于 底层 计算 模型 的 计算 结构 以 获取 高性能 . 编译器 不是 映射 f 的 具体实施 , 不 关心 具体 的 数值 计算 过程 , 所以 值 不确定性 对 编译器 无足轻重 ; 但流 不确定性 意味着 变量值 在 程序 中 的 传递 关系 不 明确 ( 计算 函数 的 复合 关系 不 明确 ) , 是 编译器 对于 程序 计算 结构 的 识别 和 理解 不 明确 . 因此 , 流 不确定性 对于 编译器 是 关键 的 . 编译器 在 对 程序 的 一个 局部 进行 并行性 的 分析 与 变换 时 , 需要 识别 , 以 消解 编译 时刻 可以 确定 的 流 不确定性 , 以 保持 在 本质 的 计算 约束 下 并行 化 和 优化 程序 . 否则 , 就 只能 在 不确定性 的 可能 范围 里 作出 保守 的 假设 . 
 1.3   条件 谓词 在 计算 函数 模型 下 的 语义 
 　 　 在 计算 函数 模型 下 , 程序段 P 中 任何 条件 分支 语句 的 条件 谓词 , 在 经过 一定 的 变量 替换 后 都 对应 着 Dom ( P ) 中 一个 特定 的 子 区域 ( 在 无 任何 条件 约束 的 情况 下为 Dom ( P ) ) . 
 　 　 设 Predicate ( t1 , t2 , ... , tk ) 是 条件 分支 语句 中 的 逻辑 条件 , t1 , t2 , ... , tk 是 条件 中 直接 出现 的 变量 , 那么 Predicate ( t1 , t2 , ... , tk ) = True 确定 了 DT = Dt1 × Dt2 × ... × Dtk 空间 中 的 一个 区域 Ω T , 由 程序 中 从 P 的 定义 变量 到 参数 变量 t1 , t2 , ... , tk 的 一系列 赋值 语句 、 表达式 等 确定 的 映射 关系 : φ : ( x1 , x2 , ... , xm ) → ( t1 , t2 , ... , tk ) 可知 , DT 是 Dom ( P ) 的 一个 导出 参数 空间 . Ω P = φ - 1 ( Ω T ) 表示 在 P 的 定义域 中 , 该 条件 分支 执行 的 程序 状态 空间 区域 . 而 Ω T 表示 是 在 参数 空间 DT 中 . 这里 的 Ω P = φ - 1 ( Ω T ) 有 如下 表示 : 
 Ω P = { ( x1 , x2 , ... , xm ) | ( x1 , x2 , ... , xm ) ∈ Dom ( P ) ; φ ( x1 , x2 , ... , xm ) = ( t1 , t2 , ... , tk ) ∈ Ω T } . 
 　 　 事实上 , 谓词 p ( x1 , x2 , ... , xn ) 是 程序 状态 空间 中 的 特定 空间 区域 或点集 Ω P 的 特征函数 . 
 p ( x1 , x2 , ... , xn ) ( x1 , x2 , ... , xn ) ∈ Ω P , ( x1 , x2 , ... , xn ) ∈ Dom ( P ) . 
 　 　 定义 1.5 . 以 程序段 P 中 的 条件 谓词 Predicate ( t1 , t2 , ... , tk ) 作为 特征函数 , 在 P 的 定义域 Dom ( P ) = Dx1 × Dx2 × ... × Dxm 中 确定 的 空间 区域 Ω P 以及 所有 表示 在 Dom ( P ) 的 导出 空间 DT = Dt1 × Dt2 × ... × Dtk 中 的 区域 Ω T 称为 该 谓词 的 Omega 区域 , 记 为 Ω PredicateP , 在 不 导致 歧义 时 , 简化 为 Ω Predicate . 
 　 　 引理 1.1 . 设 程序段 P 中 的 逻辑 谓词 p ( x1 , x2 , ... , xn ) 确定 的 Omega 区域 为 Ω p , 则 : 
 　 　 
 　 　 证明 是 平凡 的 , 略 . 
 　 　 引理 1.2 . 设是 关于 程序 变量 的 逻辑 谓词 集 , 是 以 中 的 谓词 为 特征函数 生成 的 Ω 区域 的 集合 , 则 点集 运算 系统 ［ ; - , ∩ , ∪ ］ 同态 于 逻辑运算 系统 . 
 　 　 由 引理 1.1 易知 , 的 生成 映射 φ : → 是 其 上 的 同态 映射 , 证明 略 . 
 　 　 引理 1.1 和 引理 1.2 表明 , 在 条件 分支 语句 中 , 逻辑 谓词 对应 的 Omega 区域 , 其 相互间 的 覆盖 关系 对应 着 逻辑 谓词 之间 的 逻辑关系 , 因此 , 计算 函数 模型 的 引入 , 可以 把 逻辑推理 的 问题 变换 为 空间 区域 之间 覆盖 关系 的 判定 问题 . 
 　 　 逻辑 谓词 及其 对应 的 Omega 区域 在 表示 形式 上 是 一致 的 , 都 是 关于 程序 变量 的 等式 或 不等式 组等 . 区别 在于 作用 于 其 上 的 运算 系统 是 不同 的 , 区域 覆盖 的 方法 更 容易 与 现有 技术 融和 , 更 易于 实现 . 判定 Omega 区域 之间 的 覆盖 关系 时 , 没有 必要 把 变量 全部 替换 为 P 的 定义 变量 , 而 只 需 把 两个 Omega 区域 划 到 同一个 参数 变量 空间 即可 . 在 文献 ［ 5 ］ 中 提出 了 一个 逐步 反向 替代 的 变量 替换 方法 . 对 实用程序 , 特别 是 科学计算 类 的 程序 的 分析 统计 表明 , 多数 条件 分支 语句 的 逻辑 条件 谓词 确定 了 其 参数 空间 里 的 线性 凸 区域 , 或 线性 凸 区域 中 按照 一定 规律 排布 的 整数 点集 . 而 针对 这种 区域 、 点集 的 集合 运算 处理 方法 ( 如 线性 不等式 组等 ) 在 并行 化 编译器 的 实践 中 已经 比较 成熟 . 
 　 　 在 FORTRAN 程序 及 C语言 程序 中 , 这里 的 程序段 P 可以 是 程序 中 的 各种 实体 : 整个 程序 、 某个 子程序 、 某块 代码 、 DO 的 循环体 , 甚至 是 一个 语句 或 表达式 . 这种 统一 的 看法 有助于 推出 一个 统一 的 处理 方法 , 它 既 可以 具有 局部 有效性 , 又 可以 进行 全局 的 通盘筹划 处理 . 
 2   计算 函数 模型 下 条件 分支 语句 的 语义 
 　 　 条件 分支 语句 的 一般 形式 : 
 　 if 　 　 　 　 　 　 　 　 if 
 　 [ ] P1 → B1 ; 　 　 　 　 　 [ ] Ω P1 → B1 ; 
 　 [ ] P2 → B2 ; 　 　 　 　 　 [ ] Ω P2 → B2 ; 
 　 　 　 ... 　 　 　 or 　 　 　 　 ... 
 　 [ ] Pn → Bn ; 　 　 　 　 　 [ ] Ω Pn → Bn ; 
 　 fi 　 　 　 　 　 　 　 　 fi 
 　 　 由于 B1 , B2 , ... , Bn 执行 的 不确定性 导致 了 程序 对 数据 读写 的 不确定性 , 这种 不确定性 由 各个 可 执行 语句 体 Bi 的 前置 谓词 Pi 决定 . Pi 的 引用 区域 是 完全 确定 的 , 不会 导致 不确定性 . 
 2.1   条件 分支 语句 对 变量 定义 的 语义 作用 
 　 　 设 当前 分析 的 程序段 P , 条件 分支 语句 对 其中 变量 定义 产生 的 语义 作用 可以 有 如下 几种 . 
 　 　 . 值 不确定性 定义 ( 写 )   参见 下面 图 1 和 图 2 中 的 示例 , 作为 一个 整体 , 程序段 的 所有 读写 区域 是 确定 的 , 但 变量 定义 的 数值 不 确定 . 此时 , IF 语句 对于 变量 定义 的 语义 作用 是 计算 表达式 的 一部分 , 主要 意图 是 在 不同 条件 下 赋予 变量 不同 的 数值 . 如果 条件 分支 语句 的 此类 语义 作用 不 影响 程序 的 计算 结构 ( 比如 其 产生 的 变量值 出现 在 其他 IF 语句 的 条件 表达式 、 DO 语句 的 上 下界 表达式 或 数组 下标 表达式 中 ) 时 , 可以 把 它 作为 一种 表达式 来 处理 . 而 当 条件 分支 语句 下 的 定义 结果 影响 程序 的 计算 结构 时 , 则 该值 不确定性 定义 是 符号 变量 定义 , 需要 进行 符号分析 . 我们 采用 下面 的 标记 表示 其 语义 : , 其中 Ω P 是 条件 谓词 p 的 Omega 区域 , w 表示 是 写 / 定义 , ExpVal 表示 相应 的 计算 表达式 . 
 　 　 　 　 　 　 　 　 　 　 
 　 　 　 　 　 　 　 　 　 　 Fig.1 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 Fig.2 
 　 　 　 　 　 　 　 　 　 　 图 1 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 图 2 
 　 　 . 流 不确定性 定义 ( 条件 写 )   参见 下面 的 示例 . IF 语句 决定 的 是 变量 , 特别 是 数组 区域 ( array   region ) 在 一定 条件 下 的 写 区域 . 逻辑 条件 成立 的 不 确定 导致 数据 定义 和 引用 关系 的 不 确定 , 其中 的 逻辑 语义 暗示 了 程序 计算 结构 的 约束 关系 . 相应 的 语义 可以 标记 为 : . 
 条件 分支 语句 产生 的 流 不确定性 示例 如下 : 
 　 　 ［ 1 ］ DO   K = 2 , 5 , 1 
 　 　 ［ 2 ］ 　 IF   ( RS ( 4 + K ) . LE . CUT2 )   THEN 
 　 　 ［ 3 ］ 　 　 　 RL ( 4 + K ) = SQRT ( RS ( 4 + K ) ) 
 　 　 ［ 4 ］ 　 ENDIF 
 　 　 ［ 5 ］ ENDDO 
 　 　 ［ 6 ］ IF   ( KC . EQ.0 )   THEN 
 　 　 ［ 7 ］ 　 DO   K = 11 , 14 , 1 
 　 　 ［ 8 ］ 　 　 FF ( ( - 5 ) + K ) = FF ( ( - 5 ) + K ) + AB2 * EXP ( - B2 * RL ( K - 5 ) ) / RL ( ( - 5 ) + K ) 
 　 　 ［ 9 ］ 　 ENDDO 
 　 　 ［ 10 ］ ENDIF 
 　 　 整个 程序段 是否 定义 、 引用 了 RL ( 6 : 9 ) 是 不 确定 的 . 
 　 　 流 不确定性 一定 是 由值 不确定性 引发 , 并且 值 不确定性 定义 和 流 不确定性 定义 是 相对 于 当前 程序段 P 的 , 对于 程序段 P 是 流 不确定性 的 定义 在 一个 更大 的 程序 范围 内 可能 会 成为 值 不确定性 定义 , 反之亦然 . 区分 条件 分支 语句 的 上述 两种 语义 是 出于 数据流 分析 过程 的 需要 , 并且 区别 这 两种 条件 分支 语句 对于 变量 定义 的 语义 作用 不能 简单 地 通过 对 条件 分支 语句 的 词法 分析 和 语法分析 得到 , 而 需要 有 在 一定 范围 内 的 数据流 分析 , 以 确定 其 计算 语义 . 
 2.2   条件 分支 语句 对 变量 读 引用 的 语义 作用 
 　 　 条件 分支 语句 对于 变量 读 引用 的 语义 作用 是 , 该读 引用 是 在 一定 逻辑 条件 下 进行 的 , 这里 我们 称之为 条件 引用 ( 读 ) . 相应 的 逻辑 条件 确定 的 Omega 区域 内 是 该 读 引用 发生 的 程序 状态 集 , 并且 也 是 我们 用来 化解 定义 - 引用 之间 数据流 不确定性 的 关键 条件 . 条件 读 的 语义 在 计算 函数 模型 下 表示 为 
 
 2.3   条件 分支 语句 的 处理 
 　 　 对于 由 条件 分支 语句 导致 的 单纯 的 值 不确定性 定义 予以 忽略 . 由于 在 科学计算 程序 中有 相当 一部分 条件 分支 语句 是 值 不确定性 定义 , 这种 忽略 可以 大大 减轻 编译器 的 计算 量 . 而 对于 条件 分支 语句 下 的 符号 变量 定义 , 则 应 设法 推测 其值 的 情况 . 此时 , 值 的 信息 会 导出 流 的 信息 . 本文 第 4 部分 介绍 如何 利用 计算 函数 模型 辅助 符号分析 来 处理 其中 的 逻辑 条件 . 
 　 　 流 不确定性 定义 的 处理 . 利用 条件 读中 的 逻辑 条件 进行 定义 - 引用 数据流 分析 , 消解 编译 时刻 可以 明确 的 数据流 的 不确定性 . 下面 所 证明 的 覆盖 定理 将 利用 前面 介绍 的 Omega 区域 之间 的 覆盖 关系 来 解决 这个 问题 . 需要 指出 的 是 , 许多 场合 下 的 数据流 不确定性 是 不能 在 静态 得以 明确 的 , 本质 上 , 它们 是 动态 确定 的 数据流 关系 . 
 3   用 计算 函数 模型 消解 流 的 不确定性 
 3.1   流 不确定性 消解 需要 解决 的 问题 
 　 　 在 数据流 分析 中 确定 读 引用 的 数据源 以 得出 程序段 的 数据流 信息 是 许多 并行 化 、 优化 变换 的 前提 . 但是 , 由于 条件 分支 语句 限定 下 的 条件 定义 没有 kill 掉 其他 定义 点 的 写 , 甚至 是 该 定义 点 以前 实例 的 定义 , 由此 导致 了 读 引用 对于 同一 存储 变量 的 读取 可能 读 到 程序段 P 当前 实例 之外 的 定义 点 , 产生 流 不确定性 . 忽略 这种 不确定性 意味着 无条件 地 接受 其他 数据源 的 可能 , 分析 结果 趋于 保守 . 
 　 　 在 计算 函数 模型 的 框架 下 可以 把 问题 表述 为 : 对于 一个 读 引用 r : ( 表示 在 计算 函数 模型 下 , 下同 ) 以及 可能 为 r 提供 数据源 的 定点 集 , 如何 确定 W 和 r 之间 的 数据流 关系 . 
 　 　 下面 的 讨论 针对 特定 的 数组 A , 标量 的 情形 可以 简单 地 推出 . 程序段 P 可以 是 任何 复杂 嵌套 情形 下 的 结构化程序 段 . 
 3.2   流 不确定性 消解 原理 
 　 　 定义 3.1 . 写 覆盖 读 . 对于 程序段 P 中 的 一对 读写 r , w ( 或 写集 W ) , 如果 在 P 的 任何 执行 实例 中 : 写 的 执行 在读 r 之前 执行 并且 r 读到 的 数据 集都 被 写 w ( 或 写集 W ) 的 定义数据 集所 包含 , 换句话说 , 写 w ( 或 写集 W ) 完全 可以 满足 读 r 的 数据 引用 需求 , 我们 则 称 写 w 覆盖 了 读 r ( 或 写集 W 覆盖 了 读 r ) , 记 为 : 
 或 . 
 　 　 定理 3.1 . 如果 程序段 P 中 的 一对 读写 r , w : w ∈ NaWrP , 满足 下列 条件 : 
 Ω r Ω w   and   SetP ( r ) SetP ( w ) , 
 那么 , 写 w 覆盖 了 读 r , . 
 　 　 证明 : 由于 Ω r Ω w , 当 程序段 P 执行 读 r 时 , 写 w 也 一定 被 执行 到 , 由 SetP ( r ) SetP ( w ) 可知 , w 和 r 之间 一定 存在 相关性 , 可能 是 流 相关 , 也 可能 是 反 相关 , 但 由题 设 : w ∈ NaWrP , w 和 r 之间 存在 的 一定 是 流 相关性 , 即 写 完全 有 能力 向读 r 提供数据 , 因此 : . 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 □ 
 　 　 如果 , 并且 w 输出 相关 于 任何 同 r 有流 相关 的 写 , w 是 r 的 确切 数据源 . 
 　 　 数据 集 空间 DataSpace   定义 为 程序 中 由 数据 变量 的 存储单元 组成 的 存储空间 . 标量 S 的 DataSpace 是 标量 S 所 代表 的 一个 存储单元 空间 ; 数组 A 的 DataSpace 是 数组 A 所 代表 的 dim ( A ) 维 存储空间 , 其上 下界 由 数组 说明 提供 ; 程序段 P 的 DataSpace 由 程序段 P 的 所有 变量 , 包括 标量 和 数组 的 全体 , 组成 的 存储空间 . 下面 的 讨论 中 主要 涉及 数组 的 DataSpace . 
 　 　 为了 导出 写集 覆盖 读 的 充要条件 , 我们 需要 考虑 Omega 区域 和 数组 引用 区域 的 笛 卡积 . 它 代表 程序 状态 空间 和 程序 数据 集 空间 的 笛 卡积 : Dom ( P ) × DataSpace 中 的 一个 特定 区域 : Ω x × SetP ( x ) . 其 直观 意义 是 : 程序段 P 在 满足 Ω x 的 程序 状态 下 引用 数据 区域 SetP ( x ) . 
 　 　 定义 3.2 . 程序段 P 中 引用 x 的 状态 - 数据 引用 区域 , 简称 Φ 区域 , 定义 为 : 
 Φ xP = Ω xP × SetP ( x ) . 
 　 　 Ω xP 表示 在 程序段 P 范围 内 约束 引用 x 的 Omega 区域 , 在 不 产生 歧义 时 简记 为 Ω x , Φ xP 也 记为 Φ P ( x ) . 定义 : . 
 　 　 定理 3.2 ( 覆盖 定理 ) . 对于 程序段 P 中 的 读 r 和 写集 W : WNaWrP , 的 充要条件 是 : 读 的 状态 - 数据 引用 区域 被 写集 的 状态 - 数据 引用 区域 之 并 所 覆盖 : , 即 . 
 　 　 证明 : 充分性 : 推出 . 
 　 　 当 程序段 P 任何 一次 执行 到 读 r 时 , 其所 对应 的 程序 状态 为 : s ∈ Ω r . 它 对 存储 区域 任何 一点 X ∈ SetP ( r ) 的 引用 必定 满足 下列 条件 : 
 　 　 w ∈ W , 使得 s ∈ Ω w 且 X ∈ SetP ( w ) ( 否则 与题 设 : 矛盾 ) . 由于 X ∈ SetP ( r ) ∧ X ∈ SetP ( w ) , w 和 r 之间 一定 存在 着 相关性 , 可能 是 流 相关 , 也 可能 是 反 相关 , 但 由题 设 : w ∈ WNaWrP , 则 w 和 r 之间 存在 的 一定 是 流 相关 . 由 写 覆盖 读 的 定义 , 充分性 得证 . 
 　 　 必要性 : 推出 . 
 　 　 反证法 : 设 ( s , X ∈ Φ rP ) 但 , 则 由 覆盖 的 定义 , 当 程序段 P 以 s 进入 且 引用 点 X 时 , W 无法 覆盖 r , 与题 设 不符 . 可见 必要性 成立 . 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 □ 
 　 　 推论 1 . 如果 程序段 P 中 的 一对 读写 r , w : w ∈ NaWrP , 且 满足 下列 条件 : 
 ( Ω r × SetP ( r ) ) ( Ω w × SetP ( w ) ) , 
 那么 , 写 w 覆盖 了 读 r , . 
 　 　 推论 2 . 设 r 为 程序段 P 中 的 读 , 如果 , 那么 , r 为 P 中 的 非 暴露 读 . 
 　 　 推论 3 . 对于 程序段 P 中 的 读集 R 和 写集 W : 的 条件 是 : 
 　 　 , 其中 的 充要条件 由 覆盖 定理 确定 : . 
 　 　 推论 1 是 定理 3.1 的 另外 一种 表示 形式 , 推论 2 应用 在 数组 私有化 判定 过程 中 , 推论 3 是 覆盖 定理 的 一种 广义 形式 . 
 　 　 由 覆盖 定理 , 我们 可以 确定 程序段 P 中 特定 的 定义 点集 能否 满足 P 中读 引用 r : 的 数据 引用 需求 . 
 4   用 计算 函数 模型 辅助 符号分析 
 4.1   条件 分支 语句 对于 符号分析 的 影响 
 　 　 符号分析 对于 精确 的 数据流 分析 和 相关性 测试 十分 重要 . 符号 变量 一般 是 标量 , 确定 这些 变量 的 数值 可以 使 编译器 分析 出 更加 精确 的 数据流 信息 . 
 　 　 在 计算 函数 模型 下 , 条件 分支 语句 里 定义 的 符号 变量 , 其值 不确定性 可以 表示 为 : 
 
 　 　 由 确定性 执行 假设 可知 , Ω p1 , ... , Ω pn , Ω other 是 Dom ( P ) 的 一个 划分 . 
 　 　 相应 的 要 解决 的 问题 是 : 对于 一个 关键 值 Symbol 的 读 引用 R : 以及 Symbol 可能 的 取值 : 
 
 如何 确定 R 实际 读取 的 Symbol 变量 的 值 . 
 4.2   用 计算 函数 模型 消解 数值 的 不确定性 
 　 　 事实上 , 化解 值 不确定性 和 消解 流 不确定性 在 原理 上 是 一致 的 , 我们 可以 得出 下面 的 结论 . 对于 程序段 P 中 一个 对 关键 值 Symbol 的 读 引用 R : , R 如果 能够 读到 ExpVali , 则 一定 满足 Ω pr ∩ Ω pi ≠ . 特别 地 , 如果 Ω pr Ω pi , 则 R 读到 的 一定 是 ExpVali , 如果 , 则 R 读到 的 一定 是 { ExpVali | i ∈ D } 中 的 某个 数值 . 
 　 　 证明 类似 于流 不确定性 的 消解 , 略 . 
 5   结   论 
 　 　 任何 试图 利用 条件 分支 语句 的 逻辑 语义 来 得到 精确 数据流 信息 的 方法 , 本质 上 都 是 在 不同 的 模型 下 , 对 逻辑 条件 进行 表示 和 运算 . 在 计算 函数 模型 的 框架 下 , 条件 分支 语句 的 语义 可以 自然 而 简洁 地 表示 , 其 形式 为 : 或 Φ 区域 , 是 数组 引用 区域 在 概念 上 的 一个 拓广 ; 而 条件 分支 语句 语义 作用 下 的 相应 数据流 信息 也 可以 通过 读写 引用 的 Ω 区域 或 Φ 区域 的 运算 得以 明确 . 这里 的 表示 和 计算 方式 与 目前 数组 数据流 分析 采用 的 方式 基本一致 , 因此 实现 起来 只 需 对 已有 系统 进行 扩充 , 无需 引入 一套 推理 系统 . 
 　 　 运用 本文 提出 的 不确定性 消解 原理 , 通过 手工 形式化 变换 PERFECT   Club   Benchmarks , SPEC95fp 等 测试 程序包 里 的 实用程序 表明 , 这里 提出 的 方法 简洁 有效 . 下 一步 的 工作 是 进行 算法 化 , 以便 在 并行 化 编译器 中 实现 . ■ 
 基金项目 ： 本文 研究 得到 国家自然科学基金 ( No.69633030 ) 、 国家 863 高科持 项目 基金 ( No.863 - 
 　 　 　 　 　 306 - ZT01 - 02 - 01 ) 、 教育部 科学技术 项目 基金 和 国防科技 重点 实验室 基金 
 　 　 　 　 　 ( No.97 JS76.5 . 2JW0701 ) 资助 . 
 作者简介 ： 胡世亮 ， 1972 年生 , 硕士生 , 主要 研究 领域 为 并行 与 分布 计算 . 
 　 　 　 　 　 臧斌宇 , 1965 年生 , 副教授 , 主要 研究 领域 为 并行处理 , 高性能 计算 . 
 　 　 　 　 　 朱传琪 , 1943 年生 , 教授 , 博士生 导师 , 主要 研究 领域 为 并行处理 , 高性能 计算 . 
 作者 单位 ： 胡世亮 ( 复旦大学 并行处理 研究所   上海   200433 ) 
 　 　 　 　 　 臧斌宇 ( 复旦大学 并行处理 研究所   上海   200433 ) 
 　 　 　 　 　 朱传琪 ( 复旦大学 并行处理 研究所   上海   200433 ) 
 参考文献 ： 
 ［ 1 ］ Zhu   Chuan - qi , Zang   Bin - yu , Chen   Tong . An   automatic   parallelizer . Journal   of   Software , 1996 , 7 ( 3 ) : 180 ～ 186 
 ( 朱传琪 , 臧斌宇 , 陈彤 . 程序 自动 并行 化 系统 AFT . 软件 学报 , 1996 , 7 ( 3 ) : 180 ～ 186 ) 
 ［ 2 ］ Mary   W   Hall , Murphy   B   R , Amarasinghe   S   P   et   al . Interprocedural   analysis   for   parallelization . In : Huang   C - H   et   al   eds . Proceedings   of   the   8th   International   Workshop   on   Languages   and   Compilers   for   Parallel   Computing . Columbus , Ohio : Springer - Verlag , 1995.61 ～ 74 
 ［ 3 ］ Beatrice   Creusillet , Francois   Irigoin . Interprocedural   array   region   analysis . In : Huang   C - H   et   al   eds . Proceedings   of   the   8th   International   Workshop   on   Languages   and   Compilers   for   Parallel   Computing . Columbus , Ohio : Springer - Verlag , 1995.46 ～ 60 
 ［ 4 ］ Peng   Tu , David   Padua . Automatic   array   privatization . In : Proceedings   of   the   6th   International   Workshop   on   Languages   and   Compilers   for   Parallel   Computing . Springer - Verlag , 1993.500 ～ 521 
 ［ 5 ］ Peng   Tu , David   Padua . Gated   SSA - based   demand - driven   symbolic   analysis   for   paralleling   compilers . In : Michael   Wolfe , Denis   Nicole   et   al   eds . Proceedings   of   the   1995   International   Conference   on   Supercomputing . Bacelona : ACM   Press , July   1995.414 ～ 423 
 ［ 6 ］ Trung   Nguyen , Gu   Jun - jie , Li   Zhi - yuan . An   interprocedural   paralleling   compiler   and   its   support   for   memory   hierarchy   research . In : Huang   C - H   et   al   eds . Proceedings   of   the   8th   International   Workshop   on   Languages   and   Compilers   for   Parallel   Computing . Columbus , Ohio : Springer - Verlag , 1995.90 ～ 104 
 收稿 日期 ： 1998 - 09 - 21 
 修稿 日期 ： 1999 - 03 - 09 
