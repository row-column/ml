计算机 应用 研究 
 APPLICATION   RESEARCH   OF   COMPUTERS 
 2000 　 Vol.17 　 No.2 　 P.16 - 19 
 
 
 
 存储 一致性 模型 研究 
 胡曙 　 廖湘科 　 罗军 　 唐晓东 　 张屹 
 摘   要   讨论 了 分布式 共享 存储系统 ( Ｄ Ｓ Ｍ ) 的 通用 结构 及 页面 管理机制 ， 给出 了 各种 存储 一致性 模型 的 正确性 条件 ， 并 以 互斥 问题 为例 ， 说明 了 在 分布式 环境 下 编程 的 一些 特点 。 最后 ， 基于 作者 本人 的 工作 ， 还 讨论 了 如何 提高 Ｄ Ｓ Ｍ 系统 性能 的 问题 。 
 关键词   分布式 共享 存储   一致性 模型   延迟 
 1   研究 背景 
 　 　 目前 ， 随着 网络 技术 的 急剧 发展 及 日益 普及 ， 计算机系统 正 朝着 分布 化 、 并行 化 的 方向 发展 。 如何 让 多台计算机 协同工作 来 完成 一个 大型 任务 ， 提高 计算机系统 ( 非 单机 ) 的 整体 处理 能力 ， 一直 是 国内外 研究 的 重点 。 为 达到 这个 目标 ， 存储 一致性 的 研究 是 基础 ， 它 是 保证 分布式系统 正确 运行 及 提高效率 的 关键 。 
 2   系统结构 
 　 　 DSM 系统 具备 一个 客户 / 服务器 的 结构 ， 而且 包含 了 内核 及 用户 级 的 模块 ， 如图 1 所示 。 其中 ， 客户 进程 是 指 使用 DSM 系统 的 用户 级 应用程序 ， 当然 ， 在 单个 节点 上 可 运行 多个 客户 进程 ， 为了 支持 客户 进程 访问 DSM 系统 的 操作 ， 提供 一个 单一 的 用户 态下 的 DSM 服务器 。 
 
 图 1 　 DSM 系统 的 通用 结构 示意图 
 　 　 DSM 系统 的 页面 管理 结构 如图 2 所示 ， 它 描述 了 一个 页面 从 网络 上 取回 并 映射 到 用户 或 内核 的 地址 空间 及 可 交换 到 本地 Swap 区 的 全过程 。 
 
 图 2 　 DSM 系统 的 页面 管理 结构 
 3   一致性 模型 
 　 　 所谓 存储 一致性 模型 ( Memory   Consistency   Model ) ， 实际上 是 系统 设计者 与 应用 程序员 之间 的 一种 约定 。 如果 应用软件 遵从 一定 的 规则 访问 虚 内存 系统 ， 则 应用软件 可 获得 正确 的 存储 访问 结果 ； 反之 ， 若 破坏 约定 的 规则 ， 则 存储 访问 的 正确性 不 受 保证 。 
 　 　 从 某种意义 上 来讲 ， 存储 一致性 模型 对 共享 存储系统 中 多处理机 的 访存 次序 作 了 限制 ， 从而 对 性能 有 影响 。 分布式 共享 存储系统 ( DSM ) 的 一个 根本 目标 就是 让 一个 通过 局域网 连接起来 的 工作站 集群 ， 共享 单一 的 分页 虚 地址 空间 ， 使 在 工作站 集群 之上 运行 程序 的 效果 类似 于 程序 在 单机 之上 的 运行 。 在 最 简单 的 变体 中 ， 每页 存在 于 一个 确定 的 机器 中 ， 对 本地 页面 的 查询 速度 等同于 对 内存 的 访问速度 ， 而 访问 远程 机器 的 页面 查询 请求 将 引发 段 违例 信号 ( SIGSEGV ) ， 这 将 导致 程序 陷入 到 操作系统 之中 ， 由 操作系统 来 处理 缺页 中断 ， 操作系统 随之 发送 一个 消息 至 远程 机以 找到 所 需 的 页面 并 等待 远程 机将 该 页面 回送 过来 。 本地 机器 获得 远程 页面 之后 ， 引发 段 违例 信号 的 指令 将 被 重启 并 能 继续 往 下 执行 。 
 　 　 为 达到 上述 目标 ， 需要 构造 一个 虚 内存 子系统 ， 由 它 来 捕获 在 DSM 系统 中 的 页面 访问 错及 负责 从 网络 上 的 其它 结点 处 取回 数据 并 完成 必要 的 同步操作 。 
 　 　 在 前述 的 DSM 系统 中 ， 某 只读 页面 可能 在 多个 结点 上 均 有 副本 ， 而 对 可 写 页面 ， 一般 都 由 一个 宿主 ( Owner ) 来 维护 其 一致性 ， 远程 访问 时 ， 由 远程 结点 向 宿主 结点 发出 访问 请求 并 从 宿主 结点 处 取回 该 可 写 页面 。 通常 情况 下 ， 对 一个 可 写 页面 ， DSM 系统 中 最 多 只能 有 一个 副本 ， 当 应用程序 的 数据 相关性 比较 大时 ， 这种 对 每 一 可 写 页面 只 维护 一个 副本 的 策略 将 引发 严重 的 性能 瓶颈 。 维护 多个 副本 的 策略 能 减缓 性能 的 瓶颈 效应 ， 但 又 带来 一个 新 的 问题 ， 即 如何 在 多个 副本 之间 维护 数据 的 一致性 ？ 为 解决 这个 问题 ， 提出 了 一致性 存储 模型 。 大致 来说 ， 按照 对 一致性 的 要求 由强 到 弱 的 顺序 ， 可 区分 为 以下 几类 。 
 3.1   严格 一致性 模型 ( Strict   Consistency ) 
 　 　 这 是 对 一致性 要求 最 严格 的 一种 模型 ， 它 由 以下 条件 来 描述 ： 任何 对 内存 位置 X 的 读 操作 将 返回 最近 对 位置 X 进行 写 操作 而 存入 的 值 。 
 　 　 在 DSM 系统 中 ， 这是 一种 理想 模型 ， 但 受 网络 延迟 的 影响 ， 不 可能 实现 。 在 DSM 系统 中 实现 的 多种 一致性 模型 ， 都 是 对 严格 一致性 模型 在 不同 程度 上 的 放松 ； 而 在 单机 环境 下 ， 任何 存储 访问 序列 都 满足 严格 一致性 的 要求 。 严格 一致性 模型 与非 严格 一致性 模型 的 存储 访问 序列 的 比较 见图 3 。 其中 W ( x ) a 表示 对应 左边 的 进程 将 x 的 值置 为 a ， R ( x ) b 则 表示 对应 左边 的 进程 读取 x 的 值 ， 读到 的 x 的 值 为 b 。 
 
 图 3 　 严格 一致性 模型 ( 水平 轴 时间 ) 
 3.2   顺序 一致性 模型 ( Sequential   Consistency ) 
 　 　 顺序 一致性 对 存储器 的 限制 较 严格 一致性 稍弱 ， 顺序 一致性 的 存储器 要 满足 以下 的 条件 ： 
 　 　 ( 1 ) 每个 进程 内部 各个 操作 的 顺序 是 确定 不变 的 ； 
 　 　 ( 2 ) 假如 所有 CPU 上 的 进程 都 对 某个 存储单元 执行 操作 ， 那么 ， 它们 的 操作 顺序 是 确定 的 ， 即 任一 进程 都 能 感知 到 这些 进程 同样 的 操作 顺序 。 
 　 　 上述 条件 的 含义 是 指 ， 当 多个 进程 分别 在 不同 的 机器 上 并行执行 时 ， 只要 所有 的 进程 都 保持 同样 的 顺序 访问 存储器 ， 那么 ， 任何 有效 的 交叉 访问 执行 都 是 可 接受 的 。 在 顺序 一致性 模型 中 ， 时间 不再 是 影响 一致性 的 因素 ， 它 关心 的 是 ： 所有 进程 必须 能 感受 到 一致 的 内存 访问 序列 。 
 　 　 顺序 一致性 模型 不 确保 进程 的 一次 读 操作 能够 返回 由 另 一 进程 所 写入 的 最新 值 。 产生 图 4 中 ( a ) 结果 的 程序 在 下 一次 执行 时 可能 会 产生 图 4 中 ( b ) 的 结果 。 在 没有 显式 的 同步操作 的 情况 之下 ， 再 一次 运行 同样 的 程序 不能 确保 能 获得 同样 的 结果 。 
 
 图 4 　 运行 同一 程序 的 两种 可能 的 结果 ( 水平 轴 表示 时间 ) 
 3.3   因果 一致性 模型 ( Causal   Consistency ) 
 　 　 它 是 对 顺序 一致性 模型 的 弱化 ， 它 要求 在 具有 潜在 因果关系 的 操作 之间 保持 其 一致 的 顺序 。 一般性 的 描述 如下 ： 有 潜在性 因果 相关 的 写 操作 必须 以 同样 的 顺序 被 各 进程 所 感知 ， 而 并发 的 写 操作 在 不同 的 机器 上 可以 有 不同 的 顺序 。 
 　 　 在 因果 一致性 的 存储管理 系统 中 ， 上述 操作 序列 是 合法 的 ， 而 在 顺序 一致性 或 严格 一致性 模型 中 ， 它们 是 非法操作 。 
 
 图 5 　 一个 全法 的 因果 一致性 存储 访问 事件 序列 
 3.4   管道 一致性 模型 ( Pipelined   RAM ) 
 　 　 管道 一致性 模型 是 对 因果 一致性 模型 的 进一步 弱化 ， 它 满足 以下 条件 ： 由 某 一个 进程 完成 的 写 操作 能够 被 所有 别的 进程 按序 地 感知 到 ， 而 从 不同 进程 中来 的 写 操作 对 不同 的 进程 可 有 不同 的 顺序 。 如图 6 示例 。 
 
 图 6 　 在 PRSM 模型 中 的 一个 合法 的 事件 序列 
 　 　 PRAM 模型 由于 其 易于 实现 ， 故有 一定 的 吸引力 。 实际上 ， 它 对 不同 进程 所 感知 的 写 操作 顺序 并 没有 保证 ， 除非 是从 同一个 进程 ( 源 ) 来 的 写 操作 ， 则 必须 按序 到达 别的 所有 的 进程 ， 类似 于 它们 处在 一条 管道 中 一样 。 除此之外 ， 在 PRAM 模型 中 ， 由 不同 进程 产生 的 写 操作 完全 是 并行 的 。 
 3.5   弱 一致性 模型 ( Weak   Consistency ) 
 　 　 尽管 PRAM 模型 与 较之 严格 的 一致性 模型 相比 ， 能够 获得 更好 的 性能 ， 但 因为 它 对 同一个 进程 ( 源 ) 所 产生 的 结果 仍然 作 了 必须 按序 地 送达 所有 别的 进程 的 要求 ， 故对 很多 应用程序 而言 ， 仍然 受到 了 模型 的 限制 。 并非 所有 的 进程 都 要求 看到 所有 的 写 操作 的 结果 ， 让 它们 按序 地 看到 写 操作 的 结果 则 更是 没有 必要 。 在 此 ， 模型 的 开销 能够 严重 地 影响 应用程序 的 性能 。 考虑 到 运算 的 中间 结果 在 大多数 情况 下 并 没有 必要 传播 出去 的 情况 ， 我们 必须 对 一致性 要求 作 进一步 的 放松 ， 我们 只有 在 需要 传播 写 操作 结果 的 时候 才 将 结果 传播 出去 ， 除此之外 ， 一切都是 完全 并行 的 。 为了 同步操作 的 目的 ， 在 弱 一致性 模型 中 引入 同步 变量 。 
 　 　 弱 一致性 模型 必须 满足 的 条件 ： 
 　 　 ( 1 ) 对 同步 变量 的 访问 满足 顺序 一致性 的 要求 。 
 　 　 ( 2 ) 对 同步 变量 的 访问 ， 只有 在 以前 的 写 操作 在 各处 都 完成 之后 才能 完成 。 
 　 　 ( 3 ) 对 数据 的 操作 ( 读 或 写 ) ， 只有 在 以前 的 对 同步 变量 的 访问 完成 之后 才能 完成 。 
 　 　 第一点 说明 所有 的 进程 都 能 以 同样 的 顺序 感知 到 所有 对 同步 变量 的 访问 。 当 一个 进程 访问 某 同步 变量 时 ， 它会 把 对 该 同步 变量 的 访问 广播 出去 ， 在 该 进程 对 该 同步 变量 的 操作 成功 之前 ， 任何 别的 进程 对 同步 变量 的 访问 都 将 被 阻塞 。 
 　 　 第二点 说明 对 同步 变量 的 访问 会 导致 对 内存 进行 刷新 的 结果 。 当 一个 同步 访问 完成 之后 ， 那么 ， 所有 先前 的 写 操作 可以 同时 确保 已 完成 。 当某 进程 对 一个 共享 数据 作 了 更新 之后 ， 它 可以 通过 同步操作 将 新值 传播 出去 。 
 　 　 第三点 说明 当 一个 进程 在读 一个 共享 数据 ( 非 同步 变量 ) 时 ， 通过 同步操作 ， 它 能 获得 该 共享 数据 的 最新 值 。 
 
 图 7 　 一个 合法 的 弱 一致性 访问 序列 
 
 图 8 　 一个 非法 的 弱 一致性 访问 序列 
 3.6   释放 一致性 模型 ( Release   Consistency ) 
 　 　 对于 同步 变量 的 访问 ， 弱 一致性 模型 有 一个 问题 ： 就是 无法 区分 进程 是 准备 进入 临界 区 还是 已经 完成 对 共享 变量 的 操作 而 准备 退出 临界 区 ， 其 后果 就是 进程 在 以下 两种 情况 下 都 必须 采取 同步操作 ： 
 　 　 ( 1 ) 将 局部 写 操作 的 结果 传播 出去 。 
 　 　 ( 2 ) 从 别的 机器 上 收集 共享 数据 的 最新 值 。 
 　 　 如果 能 将 进入 和 退出 临界 区 这 两个 动作 区分 开来 ， 则 能 实现 一种 更为 高效 的 存储 一致性 模型 ─ 释放 一致性 模型 。 释放 一致性 模型 提供 了 两类 同步操作 ： Acquire 和 Release 。 某 进程 将要 进入 临界 区时 执行 Acquire 操作 ， 退出 临界 区时 执行 Release 操作 。 也 可以 不用 临界 区而用 栅栏 ( Barrier ) 同步 来 实现 释放 一致性 协议 。 栅栏 是 一种 同步 机制 ， 它 要求 所有 的 进程 全都 到达 程序 的 某 一 同步 点 之后 ， 各个 进程 才能 继续 往 下 执行 。 
 　 　 借助于 Acquire 和 Release 操作 ， 我们 可以 把 某些 特殊 的 共享 变量 保护 起来 ， 并 维护 它们 的 一致性 。 当然 ， 应用程序 必须 确知 它 需要 维护 其 一致性 的 数据 ， 这 也 给 应用程序 的 编制 增加 了 一些 协议 开销 ， 但 整体 性能 提高 了 ， 如图 9 所示 。 
 
 图 9 　 一个 合法 的 释放 一致性 访问 序列 
 　 　 通常 ， 如果 一个 分布式 共享 存储系统 满足 释放 一致性 ， 则 它 必须 遵从 以下 的 规则 ： ( 1 ) 某 进程 只有 在 成功 地 完成 Acquire 操作 之后 ， 才能 确保 对 一般 共享 变量 ( 非 共享 同步 变量 ) 访问 的 正确性 。 ( 2 ) 某 进程 只有 在 完成 对 共享 数据 的 读写操作 之后 ， Release 操作 才能 完成 。 ( 3 ) Acquire 和 Release 操作 必须 满足 管道 一致性 要求 。 
 　 　 为了 更进一步 提高 性能 ， 另外 一种 实现 释放 一致性 模型 的 协议 被 称之为 懒 释放 一致性 ( Lazy   Release   Consistency ) ， 与 之 对应 ， 一般 的 实现 被 称之为 勤 释放 一致性 ( Eager   Release   Consistency ) 。 它们 之间 的 区别 在于 ， 勤 释放 一致性 协议 在 Release 操作 结束 之后 ， 将 所有 已 修改 的 数据 传送 给 所有 别的 进程 ， 这样 ， 别的 进程 都 拥有 此 最新 数据 的 一个 副本 并 可 在 本地 访问 它们 。 但 实际 情况 是 有 可能 别的 进程 并不需要 该 共享 数据 ， 这样 就 浪费 了 带宽 并 给 程序 带来 不必要 的 延迟 。 懒 释放 一致性 协议 在 Release 操作 结束 之后 ， 并 不 急于 传送 新 的 数据 ， 而是 在 别的 进程 执行 Acquire 操作 之后 ， 由 别的 进程 向 它 提出 获取 新 数据 的 请求 时 ， 它响 应该 请求 并 把 共享 数据 的 最新 值 传送 给 特定 的 进程 ， 这样 ， 系统 的 性能 又 获得 了 提高 。 
 3.7   单项 一致性 模型 ( Entry   Consistency ) 
 　 　 另外 一种 用于 提高 临界 区 操作 并行性 的 一致性 模型 是 由 Bershad 等 人于 1993 年 提出 的 单项 一致性 模型 。 它 要求 编程人员 在 临界 区 的 开始 和 结束 时 使用 Acquire 和 Release 操作 ， 但 与 释放 一致性 不同 的 是 ： 它 要求 每个 共享 变量 都 与 某 同步 变量 相关联 ， 同步 变量 可以 是 锁 或者 栅栏 。 以 并行 访问 一个 数组 的 不同 元素 为例 ， 它 要求 给 不同 的 数组 元素 加 不同 的 锁 ， 只有 当对 同步 变量 的 Acquire 操作 完成 之后 ， 相关 的 共享 数据 才 得到 一致性 保证 。 单项 一致性 模型 也 不同于 懒 释放 一致性 模型 ， 后者 并 不 将 共享 数据 与 锁 或 栅栏 相关联 ， 而是 在 对 同步 变量 作 Acquire 操作 之后 ， 才能 确定 它 需要 哪些 共享 数据 。 
 　 　 因为 只有 少量 的 共享 变量 需要 同步 ， 所以 如果 将 每 一个 同步 变量 与 多个 共享 数据 相关联 ， 则 会 减少 对 同步 变量 的 Acquire 和 Release 操作 的 开销 。 同时 ， 它 还 允许 多个 包含 不同 变量 的 临界 区 并行操作 ， 从而 提高 了 并行性 。 它 的 代价 主要 是 每个 共享 变量 均 要 与 一个 同步 变量 相关联 ， 从而 带来 一些 开销 及 复杂性 。 
 　 　 同步 变量 的 使用 规则 如下 ： 
 　 　 每个 同步 变量 有 一个 当前 拥有者 ( 即 最近 获取 到 该 同步 变量 的 进程 ) ， 拥有者 可以 对 临界 区 进行 重复 的 操作 而 无需 在 网络 上 发送 任何 消息 。 这时 ， 一个 想 获得 此 同步 变量 的 进程 需要 给 当前 拥有者 发送 一个 消息 ， 以 获得 对 同步 变量 操作 的 所有权 及 与 此 同步 变量 相关联 的 共享 变量 的 值 。 在 非 互斥 的 情况 之下 ， 允许 多个 进程 同时 拥有 某 同步 变量 ， 但 只能 对 共享 数据 进行 读 操作 ， 而 不能 写 。 满足 单项 一致性 的 条件 是 ： 
 　 　 ( 1 ) 在 当前 拥有者 对 数据 的 更新 操作 未 完成 之前 ， 不能 执行 另 一 进程 对 同步 变量 的 Acquire 操作 。 
 　 　 ( 2 ) 如果 某 进程 以 互斥 模式 访问 某 同步 变量 ， 则 在 该 进程 释放 此 同步 变量 之前 ， 任何 别的 进程 即使 是 在 非 互斥 模式 下 都 将 无法 获得 该 同步 变量 。 
 　 　 ( 3 ) 如果 某 进程 以 互斥 模式 访问 一个 同步 变量 ， 则 在 该 进程 完成 操作 之后 ， 任何 进程 对此 同步 变量 的 后继 非 互斥 访问 ， 都 只有 在 成为 该 同步 变量 的 拥有者 之后 才能 完成 。 
 4   编程 模式 
 　 　 由 一系列 共享 页面 所 组成 的 虚 地址 空间 是 DSM 系统 的 核心 ， 不妨 称之为 DSM 对象 ， 试图 访问 虚 地址 空间 的 进程 在 访问 前 必须 满足 两个 先决条件 ： 
 　 　 首先 ， 它 必须 获得 一个 唯一 的 DSM 对象 标识符 ， 借此 以 区别 于 系统 中 的 其它 DSM 对象 。 其次 ， 它 还 必须 知道 控制 该 DSM 对象 的 DSM 服务器 的 网络地址 。 
 　 　 一个 DSM 对象 标识符 可 通过 请求 创建 一个 新 的 DSM 对象 或者 在 已 存在 的 DSM 对象 集中 查询 而 获得 ， 上述 过程 被 称之为 Attach 操作 。 一旦 某个 进程 满足 上述 两个 条件 ， 它 将 向 DSM 服务器 发出请求 ， 将 相应 的 DSM 对象 通过 Map 系统 调用 映射 到 本 进程 的 地址 虚 空间 中 ， 从而 完成 内存空间 的 分配任务 。 进程 在 完成 对 DSM 对象 的 访问 之后 ， 将 向 DSM 服务器 发出 Detach 请求 。 
 　 　 以 互斥 问题 为例 ， 传统 的 互斥 算法 ， 如 Peterson 的 入口 协议 ( Entry   Protocol ) 算法 ， 在 分布式 境下 都 将 失效 。 其中 ， ┐ 表示 取非 操作 ， ∨ 表示 或 操作 。 
 　 　 Peterson 的 两 进程 互斥 算法 在 图 10 中 ( a ) 给出 。 当 Xi 为 真时 ， 进程 i 将 试图 获得 访问 临界 区 的 入口 ， 当 两个 进程 都 在 试图 获取 临界 区 的 入口 时 ， 变量 Y 起到 仲裁 作用 ， 由 它 来 指示 哪个 进程 可以 真正 进入 临界 区 。 此 代码段 在 单机 环境 下 可以 很 好 地 工作 ， 但 在 DSM 环境 之下 ， 由于 没有 考虑 到 通信 延迟 的 影响 ， 上述 代码 将 导致 错误 的 结果 ， 出错 情况 如图 10 中 ( b ) 所示 ， 造成 两个 进程 均 进入 了 临界 区 的 后果 。 
 
 图 10 　 传统 互斥 算法 在 DSM 环境 下 失效 的 示意图 
 　 　 在 DSM 环境 下 ， 互斥 算法 是 可能 的 ， 如图 11 所示 ， 客户 通过 向 互斥 服务器 发 Require 请求 及 等待 服务器 来 的 Ack 等 操作 , 可以 保证 能够 互斥 地 进入 临界 区 ， 通过 Realease 操作 ， 可以 向 服务器 通告 本 进程 已 退出 临界 区 。 服务器 在 接受 各 客户 的 互斥 请求 时 ， 进行 排队 处理 ， 它 只会 给 处在 队列 首位 的 客户 发 Ack 消息 ， 别的 客户 由于 等待 接受 服务器 的 Ack 消息 而 处于 阻塞状态 。 其实 ， 以上 算法 也 是 对 某些 存储 一致性 模型 中 同步操作 ( 如 加锁 Lock 及 栅栏 Barrier ) 的 形式化 描述 。 
 
 图 11 　 在 DSM 环境 下 集中式 的 N - 进程 互斥 算法 
 5   结论 
 　 　 考虑 一个 包含 两个 变量 x 、 y 的 程序 ， x 、 y 的 值 均 初始化 为 0 。 现在 由 两个 进程 P1 、 P2 来 执行 该 程序 ， 其中 P1 把 x 的 值 先赋 为 1 ， 然后 读取 变量 y 的 值 ， P2 则 把 y 的 值 先赋 为 1 ， 然后 读取 变量 x 的 值 ， 方框 代表 操作 的 时间 间隔 。 在 一致性 存储器 中 ， P1 或 P2 读到 0 值 的 情况 是 不 允许 的 。 
 　 　 假如 写 操作 的 最 短时间 为 w ， 读 操作 的 最 短时间 为 r ， 消息 延迟 的 最 短时间 为 τ ( 如图 12 所示 ) ， 如果 w + r < τ ， 则 P1 和 P2 读到 的 变量 的 值 都 只能 是 0 ， 即 未 更新 的 值 。 因为 消息 延迟时间 实际上 就是 信息 传输 的 时间 ， 在 某 一 进程 没有 收到 消息 之前 ， 它 不 可能 知道 发生 在 别的 进程 中 的 事件 ， 所以 ， 在 一致性 共享 存储系统 中 ， 必然 满足 w + r ≥ τ 。 从而 ， 可以 得出 以下 结论 ： 不管 一个 协议 多么 复杂 及 多么 智能化 ， 只要 它 实现 的 是 一个 一致性 共享存储器 ， 那么 它 必然 是 慢 的 ( Slow ) ， 即 系统 的 性能 必然 受到 通信 延迟 的 影响 。 同样 的 原因 ， 对 一致性 要求 严格 的 模型 ， 如 严格 一致性 模型 或 顺序 一致性 模型 ， 其 可扩充性 能 也 是 不好 。 
 
 图 12 　 消息 延迟 的 影响 
 6   相关 工作 
 　 　 针对 中国科学院 计算所 开发 的 JIAJIA 系统 ， 我们 做 了 大量 的 测试 及 改善 性能 方面 的 工作 。 JIAJIA 实现 的 是 一种 被 称之为 域 一致性 的 协议 ， 通过 显式 的 加锁 ( Lock ) 及 栅栏 ( Barrier ) 操作 来 实现 同步 。 主要 的 改进 之 处 在于 ： 
 　 　 ( 1 )   采用 块 传输方式 
 　 　 由于 JIAJIA 采用 的 是 UDP 协议 ， 实现 的 是 一种 不 可靠 的 数据包 通信 ， 而且 ， 对 具有 大 通信量 的 应用程序 而言 ， 采用 UDP 协议 通过 以太网 ( EtherNet ) 将 数据 逐个 地 发送 出去 显得 太慢 。 为此 ， 我们 采用 了 硬件 提供 的 特殊 BLT 功能 ， 通过 PUT / GET 操作 实现 块 传输 ， 通信 不再 通过 以太网 。 因为 块 传输 提高 了 通信 的 带宽 ， 所以 系统 的 性能 获得 了 改善 。 在 块 传输方式 下 运行 的 应用程序 随着 结点 的 增加 有 良好 的 加速 比 ， 并且 ， 与 之 在 以太网 通信 下 的 时间 耗费 相比 ， 性能 也 有 提高 。 
 　 　 ( 2 )   将 部分 功能 下移 至 系统 内核 实现 
 　 　 DSM 系统 中带 普遍性 的 一个 问题 是 ： 应用程序 在 运行 过程 中 由于 需要 访问 远程 数据 而 不得不 陷入 到 操作系统 之中 。 这种 进管 / 出管 的 时间 耗费 是 相当 大 的 ， 在 采用 块 传输方式 提高 了 通信 带宽 之后 ， 这种 进 / 出管 的 开销 就 成为 限制 系统 性能 的 瓶颈 。 现在 ， 这部分 工作 正在 进行 之中 。 
 　 　 ( 3 ) 进一步 在 寻求 硬件 方面 的 支撑 
 本 项目 获 国家自然科学基金 ( 基于 单 映象 并行 分布式 操作系统 研究 ) 资助 
 胡曙 （ 国防科学技术大学 计算机系 ） 
 廖湘科 （ 计算机 学院   长沙   410073 ） 
 罗军 （ 计算机 学院   长沙   410073 ） 
 唐晓东 （ 计算机 学院   长沙   410073 ） 
 张屹 （ 中国 电子设备 系统工程 公司 研究所 软件 中心   北京   100039 ） 
 参考文献 
 1 ， Andrew   S .   Tanenbaum .   Distributed   Operating   Systems 
 2 ， Phillip   W . Hutto   and   Mustaque   Ahamad .   Slow   Memory :   Weakening   Consistency   to   Enhance   Concurrency   in   Distributed   Shared   Memories .   IEEE   1990 
 3 ， Pedro   Souto   and   Eugene   W . Stark .   A   Distributed   Shared   Memory   Facility   for   FreeBSD .   USENIX   Association .   1997   Annual   Technical   Conference 
 4 ， Hu   Weiwu ,   Shi   Weisong ,   Tang   Zhimin   and   Li   Ming .   A   Lock - Based   Cache   Coherence   Protocol   for   Scope   Consistency .   Vol.13   No.2   J . of   Comput .   Sci .& Technol .   Mar.1998 
 5 ， L . lftode ,   J . P . Singh   and   K . Li .   Scope   Consistency :   A   Bridge   between   Release   Consistency   and   Entry   Consistency .   Theory   Comput . Systems   31 .   451 ～ 473 ( 1998 ) 
 6 ， Steven   K .   Reinhardt ,   Member ,   IEEE ,   Robert   W . Pfile ,   and   David   A . Wood ,   Member ,   IEEE .   Hardware   Support   for   Flexible   Distributed   Shared   Memory   IEEE   1998 
 收稿 日期 ： 1999 年 9 月 21 日 
