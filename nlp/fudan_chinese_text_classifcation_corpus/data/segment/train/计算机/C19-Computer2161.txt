计算机 应用 研究 
 APPLICATION   RESERCH   OF   COMPUTERS 
 2000     Vol.17 　 No.1 　 P.78 - 80 ， 90 
 
 
 
 
 PostgreSQL 数据库 XA 协议 的 设计 和 实现 
 郭歌 　 贾焰 
 摘   要   XA 协议 是 分布 事务处理 中子 事务 与 全局 事务 间 通讯 的 接口 规范 。 PostgreSQL 是 一种 集中式 的 数据库 管理系统 ， 尚未 实现 对 XA 协议 的 支持 。 在 对 数据库 事务管理 和 存储管理 分析 的 基础 上 ， 提出 了 PostgreSQL 上 XA 协议 的 实现 方法 ， 并 对 事务 预交 后 的 恢复 提出 一种 独特 的 解决方案 。 
 关键词   事务   两 阶段 提交   预交   存储管理   恢复   日志 
 1   前言 
 　 　 在 数据库 中 ， 分布 事务 的 完成 有赖于 各个 分布 节点 上 的 子 事务 。 与 集中式 事务 一样 ， 分布 事务 也 具有 原子 性 、 一致性 、 隔离 性 、 持久性 四种 特性 。 
 　 　 为了 保证 分布 事务 的 原子 性 和 一致性 ， 分布 事务 的 提交 通常 是 两 阶段 提交 ( 2PC ) 。 在 第一阶段 ， 全局 事务 管理器 要求 所有 的 子 事务 进入 预交 阶段 ， 进行 投票 查询 。 若子 事务 准备 好 了 并 愿意 提交 ， 则 如果 子 事务 是 一个 只读 事务 ， 就 返回 “ 只读 ” 票 并 先行 提交 ， 否则 投 “ 提交 ” 票 。 若子 事务 不能 提交 ， 就 投 “ 失败 ” 票 ， 然后 先行 失败 。 在 第二阶段 ， 全局 事务 管理器 分析 接收 到 的 消息 ， 若 超时 或 收到 一个 “ 失败 ” 票 ， 则 决定 失败 整个 分布 事务 ， 并 向 所有 投 “ 提交 ” 票 的 子 事务 发 失败 命令 ， 否则 向 它们 发 提交 命令 。 其中 第一阶段 就 叫子 事务 的 预交 阶段 。 
 　 　 XA 协议 是 X / Open 组织 提出 的 一种 资源管理 器 ( 通常 指 处理 子 事务 的 DBMS ) 在 2PC 过程 中 与 全局 分布 事务 管理器 间 通讯 的 接口协议 规范 。 在 863 项目 “ 分布式 事务管理 ” 中 ， 要求 全局 事务 下 的 各个 DBMS 能够 支持 XA 协议 以 实现 对 全局 事务 的 统一 管理 。 当前 的 商业 数据库 Oracle ， Sybase 都 支持 XA 协议 。 
 　 　 PostgreSQL 是 一种 面向对象 并 支持 大 对象 管理 的 数据库 ， 它 强大 的 功能 和 代码 开放 的 特点 使得 它 在 全球 有着 广泛 的 应用 范围 ， 但 原有 DBMS 未能 支持 XA 协议 。 本文 在 对 数据库 的 有关 管理机制 的 源码 进行 分析 后 ， 提出 XA 协议 实现 的 解决方案 。 实现 中 的 主要 问题 是 事务 预交 后 的 崩溃 恢复 。 在 这 之前 ， 我们 首先 看看 数据库 的 事务管理 和 存储管理 。 
 2   PostgreSQL 的 事务管理 和 存储管理 分析 
 　 　 数据库 服务器 处理 多个 事务 过程 中 发生 如 电源 掉电 的 故障 时 ， 正在 执行 的 事务 就 会 半途而废 ， 这种 故障 称为 “ 系统 崩溃 ” ， 从 系统 崩溃 故障 中 恢复 称为 “ 崩溃 恢复 ” 。 崩溃 恢复 为了 保证 事务 的 原子 性 与 一致性 ， 需要 进行 Redo 或 Undo 操作 使得 已 提交 的 事务 数据 修改 确实 写 入库 中 而 未 完成 事务 不能 对库 的 数据 有 任何 影响 。 如何 恢复 有赖于 系统 何时 将 数据 写回 数据库 中 的 策略 ， 也 与 数据库 的 事务管理 和 存储管理 的 具体 实现 相关 。 
 　 　 PostgreSQL 最初 的 一个 设计 目标 是 希望 能够 降低 数据库 崩溃 恢复 的 代码 数量 。 对于 DBMS 来讲 ， 大量 的 崩溃 恢复 代码 不仅 不 易于 书写 ， 而且 对于 不同 的 情况 会 出现 许多 分支 ， 这 也 不 易于 测试 和 调试 。 同时 PostgreSQL 本身 又 支持 允许 用户 自定义 访问 方法 ， 所以 PostgreSQL 要求 崩溃 恢复 的 模型 尽可能 地 简单 和 易于 扩展 。 基于 此 PostgreSQL 提出 了 一种 解决 方法 ： 使用 非 重写 的 存储管理 技术 ， 并 将 日志 作为 一个 系统 关系 文件 来 进行 管理 。 
 2.1   PostgreSQL 的 事务管理 
 　 　 PostgreSQL 中 每个 事务 都 有 唯一 的 事务 标识 ( transaction   identifier ) XID 。 数据库 日志 中 记录 的 是 表明 事务 状态 ( “ 提交 ” ， “ 失败 ” 或 “ 事务 处理过程 中 ” ) 的 信息 ( 事务 缺省 的 状态值 是 “ 事务 处理过程 中 ” ) ， 而 不是 事务 的 操作 序列 。 每个 事务 在 日志 中 的 位置 可 通过 事务 XID 计算 得到 。 当 事务 提交 时 ， 就 将 日志 中该 事务 状态 的 值 修改 为 “ 提交 ” ， 并 将 日志 所在 的 块 写 回 静态 磁盘 中 ， 同时 该 事务所 作 的 任何 数据 页面 修改 也 写 回 磁盘 。 而 当 事务 失败 时 ， 则 修改 事务 在 日志 中 的 状态 为 “ 失败 ” ， 将 日志 所在 的 块 写 回 静态 磁盘 中 ( 这个 时候 事务所 作 的 数据 页面 修改 不 需写 回 磁盘 ， 但 由于 这些 页面 可能 包含 别的 已 提交 事务 的 数据 ， 因此 有 可能 已 被 别的 事务 写回 磁盘 。 在 这种 情况 下 ， 系统 需要 能够 识别 某些 数据 的 不 合法性 ) 。 此外 ， 在 事务 的 处理过程 中 ， 事务 的 状态 是 由 一个 事务 结构 变量 说明 的 。 不同 的 事务 操作 ( 开始 ， 结束 ， 提交 ， 失败 ) 必须 根据 不同 的 事务 状态 作出 相应 的 处理 和 并 对 事务 状态 进行 转换 。 事务 运行 出现异常 时 ， 也 会 影响 事务 状态值 。 
 2.2   PostgreSQL 的 存储管理 
 　 　 数据库系统 的 存储管理 通常 采用 的 是 先 写 日志 ( WAL ) 的 方法 ， 即 在 真正 将 数据 写入 磁盘 之前 ， 先 将 该 事务 的 操作 或 被 修改 的 数据 的 前后 像 写入 日志 ， 系统 崩溃 后 依据 日志 中 的 内容 进行 Redo 或 Undo 操作 。 而 PostgreSQL 的 存储管理 采用 非 重写 ( no - overwrite ) 技术 。 采用 这种 技术 ， 当 数据 发生 修改 ( 如 update 语句 ) 时 ， 旧 的 数据 仍然 会 保留 在 数据库 中 。 体现 在 PostgreSQL 的 数据库 元组 组织 方式 上 表现 为 ： 
 　 　 PostgreSQL 中 的 关系 和 数据文件 是 一一对应 的 。 每 一个 数据文件 由 许多块 组成 ， 块 之间 由 前后 指针 连接成 一条 双向 链 ， 如图 1 ， PostgreSQL 的 数据 块 由 数据 头 ( line   table ) ， 数据 体 和 一个 指针 域 组成 。 数据 头 是 对 该 块 中 所有 元组 的 索引 。 当 插入 一个 元组 时 ( insert 语句 ) 时 ， 在 数据 块 中 插入 一个 锚点 ， 以后 在 修改 该 元组 时 ， 并 不 修改 原有 的 元组 ， 只是 将 修改 值 插入 到 数据 块 中 ， 并 建立 指向 该 修改 的 指针 。 
 
 图 1 
 　 　 使用 非 重写 技术 有 两个 好处 。 首先 ， 失败 事务 是 即时 的 ， 不必 根据 日志 取消 事务 对 数据 的 修改 ( Undo ) ， 因为 修改 前 的 记录 仍然 留在 数据库 中 。 其次 ， 使用 非 重写 技术 的 另 一个 优点 是 可 进行 时间 传播 ( time   travel ) 。 一个 用户 可以 对 历史数据 ( 即 已 被 新 数据 代替 的 或 被 删除 的 旧 数据 ) 进行 查询 。 
 　 　 同一 元组 的 新旧 数据 通过 链表 连接起来 ， 但 这 并 不 表示 链表 末端 的 数据 一定 是 最新 的 ， 因为 一个 最近 失败 的 事务 插入 值 也 会 在 这个 链表 内 ， 而且 可能 就 在 末端 。 那么 如何 判断 数据 是否 满足要求 呢 ？ 
 　 　 PostgreSQL 中 每个 元组 的 数据 不论 新旧 都 有 一个 表明 该 数据 相关 事务 信息 的 结构 ， 结构 中 包括 创建 该 数据 的 事务 标识 xmin ， 删除 该 数据 的 事务 标识 xmax 和 表明 这 两个 事务 状态 的 信息 info 以及 其它 的 信息 ( 我们 暂 不 考虑 历史数据 的 操作 ) 。 当 发生 如 update 的 数据 修改 操作 时 ， 系统 分成 两步 来 完成 ， 首先 “ 删除 ” 原有 数据 ( 相当于 delete 语句 ) ， 然后 插入 新 的 数据 ( 相当于 insert 语句 ) 。 即 修改 原 数据 的 xmax 为 当前 事务 XID ， 并 创建 新 数据 和 初始化 相应 结构 ( 置 xmin 为 当前 事务 XID 和 xmax 为空 ) 。 在 以后 发生 例如 select 语句 的 检索 数据 操作 时 ， 对待 合符 查询 条件 的 元组 的 所有 数据 ， 系统 首先 对 数据 的 info 进行 判断 ， 如果 能够 判断 数据 的 xmin 事务 已 提交 并且 xmax 事务 失败 或 不 存在 ， 就 能 表明 数据 是 合法 的 。 如果 能 判断 xmax 事务 已 提交 了 ， 说明 这个 数据 是 旧 数据 。 如果 不能 确定 数据 是否 合法 ， 系统 就 会 到 日志 中 查找 xmin 与 xmax 的 状态 来 进行 判断 ， 并 把 得到 的 相关 信息 记录 到 info 中 。 对待 历史数据 的 检索 ， 还 需 使用 到 结构 中 与 xmin 和 xmax 有关 的 时间 参数 来 判断 ， 这里 省略不提 。 当然 系统 也 提供 了 清除 一定 范围 历史数据 的 命令 。 
 2.3   PostgreSQL 的 恢复 问题 
 　 　 我们 只 考虑 数据库 的 崩溃 恢复 。 假设 网络 是 完全 可靠 的 ， 静态 存储器 也 是 完全 可靠 的 。 
 　 　 数据库 在 事务 提交 时会 把 记录 事务 状态 日志 的 内容 和 修改 的 数据 页面 写回 静态 磁盘 ， 我们 只 考虑 崩溃 时未 完成 的 事务 ， 崩溃 时 如果 它 的 数据 修改 未 写入 磁盘 ， 不 存在 什么 恢复 。 如果 部分 已 写入 了 磁盘 ， 也 并 不 需像 别的 数据库 作 undo 操作 ， 因为 例如 select 的 检索 语句 发现 这个 值 的 xmax 事务 在 日志 中 的 状态 是 “ 处理过程 中 ” ， 就 认为 它 不 合法 的 。 这 说明 PostgreSQL 基本上 不 存在 崩溃 恢复 问题 ， 这 也 达到 的 数据库 初始 的 设计 目的 。 
 3   PostgreSQL 中 分布 子 事务 的 设计 和 实现 
 　 　 在 XA 协议 中 ， DBMS 作为 资源管理 器 在 事务处理 的 过程 中向 全局 分布 事务 管理器 至少 提供 三种 函数 接口 ： Prepare ( ) ， Commit ( ) 和 Rollback ( ) 。 全局 分布 事务 管理器 调用 这 三个 函数 来 取得 子 事务 的 投票 查询 结果 ， 提交 和 失败 子 事务 。 
 　 　 我们 已经 知道 PostgreSQL 数据库 本身 基本上 没有 什么 崩溃 恢复 ， 未 完成 的 事务 在 对 数据库 的 影响 方面 系统 认为 等价 于 失败 的 事务 。 但是 在 两 阶段 提交 过程 中 ， 如果 子 事务 投了 “ 提交 ” 票后 ， 在 等待 事务 管理器 的 提交 或 失败 命令 时 ， 发生 了 系统 崩溃 。 系统 重启 后 必须 能够 恢复 这个 子 事务 并且 能 对 事务 管理器 给 这个 子 事务 发出 的 “ 提交 ” 或 “ 失败 ” 命令 作出 正确 反应 ， 而 不是 简单 地 认为 是 “ 失败 ” 了 。 这是 分布 事务 的 特点 决定 的 。 这种 情况 下 的 恢复 ， 我们 称之为 预交 后 的 崩溃 恢复 。 如何 保证 预交 后 的 崩溃 恢复 是 XA 协议 实现 中 的 主要 问题 。 
 　 　 预交 后 的 崩溃 恢复 有 两种 方法 ， 一种 是 像 WAL 一样 记录 事务 的 操作 序列 ， 系统 重启 时重 做 已 预交 事务 的 这些 操作 。 另外 一方面 由于 PostgreSQL 使用 了 非 重写 的 存储管理 技术 ， 保留 在 数据库 中 的 数据 是否 合法 依赖于 它 的 xmin 事务 和 xmax 事务 的 状态 。 一个 未 提交 的 事务 完全 可以 把 数据 修改 保留 在 数据库 中 而 不会 引起 冲突 。 所以 我们 提出 另外 一种 方法 即 在 子 事务 投 撎 峤 粩 票 前 把 数据 修改 写回 数据库 中 ， 而 真正 提交 时 就 不必 再 做 这个 操作 了 。 这时 如果 系统 崩溃 ， 系统 重启 后 这些 数据 仍然 会 在 数据库 中 ， 我们 只要 在 事务 管理器 的 命令 到达 之前 不让 别的 事务 修改 ( 以免 改变 数据 的 xmax ) 和 检索 ( 以免 改变 数据 的 info ) 这些 数据 即可 ( 给 这些 数据 上 写 锁 ) 。 然后 不论是 提交 还是 失败 命令 到达 时 ， 我们 只 需 修改 日志 中该 待 恢复 事务 状态 和 释放 这些 锁 就 可 真正 完成 这个 待 恢复 事务 。 这 就 需要 预交 事务 在 投 “ 提交 ” 票前 记录 该 事务 保持 的 一些 写锁 信息 。 
 　 　 比较 两种 方法 ， 在 投票 前 记录 事务 的 锁 比 记录 事务 的 数据 或 动作 序列 更 容易 。 这 是因为 一方面 ， 数据库 也 可以 处理 集中式 事务 ， 而 我们 要求 记录 的 只是 分布 子 事务 的 信息 。 如果 在 每个 事务 动作 后 做 记录 ， 此时 我们 并 不能 判断 这个 事务 是否是 分布 子 事务 ( 在 具体 实现 中 ， 我们 直到 prepare 语句 时 才能 判断 ) 。 而 事实上 每个 事务 却 始终 维持 着 一个 锁 队列 直到 事务 结束 前才 释放 这些 锁 ( 数据库 的 锁 机制 是 两 阶段 锁 ) ， 锁 信息 在 执行 prepare 语句 时 容易 得到 。 此外 由于 我们 只 记录 关系 级 写 锁 ( PostgreSQL 的 锁 粒度 是 关系 ) ， 因而 日志 内容 也 不大 。 另一方面 使用 记录 锁 的 方法 ， 系统 重启 后 我们 只 恢复 了 写 锁 ， 而 如果 重做 事务 操作 还会 对 某些 数据 上 一些 读锁 ， 因而 影响 数据库 的 并发 度 。 另外 ， 决定 投 “ 只读 ” 票 也 可 在 记录 写锁 的 基础 上 进行 判断 。 所以 我们 采纳 后 一种 方法 即 在 预 提交 时 就 将 事务 的 修改 写入 磁盘 中 并且 记录 事务 的 锁 ( 主要 是 写 锁 ) 。 而 在 当 事务 真正 提交 和 失败 时 ， 只 需 改变 事务 在 日志 中 的 状态 ， 并 删除 已 记录 的 该 事务 的 锁 。 这是 一种 以 空间 换取 机制 简单化 的 策略 。 
 　 　 具体 实现 如下 。 
 3.1   Prepare ( ) ， Commit ( ) ， Rollback ( ) 的 实现 
 　 　 。 Prepare ( ) ： 
 　 　 根据 事务 状态 结构 变量 ， 判断 事务 的 状态 ； 
 　 　 if   事务 不 可以 提交   then   先行 失败 事务 ， 返回 “ 失败 ” 票 ； 
 　 　 for   事务 保持 的 每个 锁   如果 是 写 锁 ， 则 记录 到 锁 日志 中 ； 
 　 　 if   没有 写锁   then   先行 提交 事务 ， 返回 “ 只读 ” 票 ； 
 　 　 修改 事务 状态 进入 预 提交 ； 
 　 　 将 数据 写回 数据库 中 并 返回 “ 提交 ” 票 。 
 　 　 。 Commit ( ) ： 
 　 　 If   事务 已 是 预 提交 状态   删除 锁 日志 中 相关 记录 ； 
 　 　 else   将 数据 写回 数据库 中 ； ( 这里 是 处理 无需 预交 的 集中式 事务 ) 
 　 　 修改 日志 中 事务 状态 为 “ 提交 ” ； 
 　 　 释放 资源 。 
 　 　 。 Rollback ( ) ： 
 　 　 If   事务 已 是 预 提交 状态   then   删除 锁 日志 中 相关 记录 ； 
 　 　 修改 日志 中 事务 状态 为 “ 失败 ” ； 
 　 　 释放 资源 。 
 3.2   2PC 过程 中 失败 恢复 的 实现 
 　 　 正如 前面 所 讲 ， 我们 在 原有 的 基础 上 的 改进 主要 是 记录 了 子 事务所 保持 的 写 锁 ， 目的 在于 崩溃 恢复 中 使用 。 
 　 　 PostgreSQL 是 一个 集中式 的 数据库 ， 它 是 由 一个 叫做 postmaster 的 后台 监控 程序 在 接收 到 前台 的 连接 请求 后 派 生出 一个 子 进程 postgres ， 并 由 postgres 与 前台 连接 并 处理 前台 请求 。 所有 的 postgres 子 进程 共享 postmaster 所 管理 的 锁 信息 。 
 　 　 由于 事务 的 数据 信息 已 写入 数据库 中 ， 系统 重启 后 ， 为 避免 在 提交 或 失败 命令 到达 之前 数据 信息结构 被 修改 ， 要求 这些 数据 要 被 锁住 直至 事务 管理器 发给 该 事务 的 命令 得到 执行 。 所以 postmaster 启动 后 ， 在 接收 任何 前台 连接 请求 之前 它 应该 恢复 那些 失败 前 已预 提交 的 事务 的 锁 。 这 可 由 postmaster 先派 生出 子 进程 用于 这些 锁 的 恢复 ， 然后 该 恢复 进程 等待 。 当 事务 管理器 的 命令 到达 后 ， 与 输入 该 命令 的 前台 对应 的 后台 postgres 就 传递信息 给 恢复 进程 ， 并 由 恢复 进程 对 恢复 事务 进行 真正 的 结束 即 修改 日志 中 事务 的 状态 ， 并 释放 和 清除 日志 中 记录 的 该 事务 相关 锁 。 
 　 　 Crash _ Recovery ( ) 和 Complete _ Transaction 的 实现 如下 。 Crash _ Recovery ( ) 是 崩溃 恢复 后 系统 重启 时 的 工作 ， Complete _ Transaction 是 恢复 进程 接收 到 命令 后 的 工作 。 
 　 　 。 Crash _ Recovery ( ) ： 
 　 　 如果 锁 日志 非空 
 　 　 派 生出 一个 进程 用于 恢复 记录 于锁 日志 中 各个 预 提交 事务 的 锁 ， 同时 该 进程 处于 等待 状态 随时 接收 结束 这些 事务 的 命令 。 处理 完 这些 命令 后 如果 进程 发现 已 释放 了 本 进程 所有 保持 的 锁 ， 就 结束 这个 进程 。 
 　 　 。 Complete _ Transaction ( TransactionId ， Tran _   Status ) ： 
 　 　 ( 两个 参数 代表 事务 标识 和 要求 事务 是 提交 还是 失败 。 ) 
 　 　 将 相关 事务 的 状态 记录 到 日志 中 。 
 　 　 释放 相关 事务 的 锁 。 
 　 　 删除 相关 事务 在 锁 日志 中 的 记录 。 
 3.3   锁 日志 的 组织 方式 
 　 　 锁 日志 作为 一种 频繁 读写 ， 进行 插入 删除 操作 的 文件 ， 其 组织 方式 上 有 两种 方法 。 其一 ， 将 其 设计 为 一种 系统 关系 文件 ( PostgreSQL 的 日志 文件 以及 其它 的 系统文件 都 是 按 关系 来 组织 的 ) ， 锁 日志 记录 的 写入 与 删除 对应 关系 元组 的 插入 与 删除 ， 这 可以 很 好 地 与 原 系统 结合 。 问题 是 关系 的 插入 删除 是 较高级 别的 读写操作 ， 频繁 插入 删除 速度 较慢 ， 不利于 性能 的 提高 ， 而且 也 不 容易 调试 。 另 一种 方法 是 将 其 作为 一种 普通 文件 。 文件 可 包含 固定 数目 的 记录 ， 每个 事务 记录 锁 的 位置 根据 事务 XID 的 hash 函数 计算 得到 ， 这样 使得 有效 记录 平均分配 到 文件 中 。 作为 一个 随机 文件 ， 数据 的 读写 比 关系 的 读写 快 ， 而且 也 易于 实现 。 
 　 　 由于 性能 以及 实现 上 的 原因 ， 我们 选择 了 后者 。 每个 锁 记录 的 结构 包括 以下 的 内容 ： 事务 标识 、 关系 标识 数组 、 数组 有效 数 和 一个 特征 标志 位 以及 记录 有效 标志 位 。 它们 的 作用 分别 是 ： 事务 标识 用于 区分 待 恢复 的 事务 ， 也 可 定位 记录 在 锁 日志 中 的 位置 。 关系 标识 数组 是 一个 用于 存储 该 事务 被 写 锁 的 关系 标识 的 定长 数组 ， 数组 前面 多少 个 元素 是 有效 的 可 由 数组 有效 数来 说明 。 如果 这个 事务 涉及 的 写 锁 关系 过多 ， 一个 关系 标识 数组 不够 ， 可能 需要 另外 的 一个 记录 ， 这 就 需要 一个 特征 标志 位来 判断 ( 一般来讲 ， 一个 事务 对 数据 的 读 可能 涉及 到 很多 关系 ， 而 对 写 就 稍 少 。 所以 ， 一个 事务 一个 记录 一般 就 足够 了 ) ， 表明 该 事务 在 日志 中 还有 其它 记录 存在 。 记录 有效 标志 位 表明 该 记录 在 日志 文件 中 是否 有效 ， 删除 该 记录 时 只 需 给 该 标志 位置 位 。 
 4   小结 
 　 　 PostgreSQL 的 非 重写 技术 抛弃 了 日志 的 前 像 和 后 像 的 传统模式 ， 在技术上 简化 了 事务管理 ， 但 给 XA 协议 的 实现 带来 了 难度 。 在 对 XA 协议 的 实现 中 ， 一方面 我们 必须 参考 普通 日志 的 设计 和 使用 ， 另一方面 ， 也 需 充分 使用 PostgreSQL 的 存储管理 达到 很 好 地 与 原 系统 的 合成 。 
 本 课题 获 863 摲 植际 绞挛 窆 芾 頂 项目 资助 
 郭歌 （ 国防科技大学 计算机 学院   长沙   410073 ） 　 
 贾焰 （ 国防科技大学 计算机 学院   长沙   410073 ） 
 参考文献 
 1 ， Stonebraker   M   and   Rowe   L .   A .   THE   DESIGN   OF   POSTGRES .   Proc   1986ACM - SIGMOD   Conference   on   Management   of   Data ,   Washington   D .   C ,   May   1986 :   ( 18 ～ 20 ) 
 收稿 日期 ： 1999 年 8 月 16 日 
