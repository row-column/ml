软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年 　 第 10 卷 　 第 11 期 　 Vol.10 　 No.11 　 1999 
 
 
 
 启发式 任务调度 中 的 处理器 选择 策略 
 陈华平 　 黄刘生 
 　 　 摘要 　 任务调度 是 并行 分布 计算 中 最为 基本 、 最为 关键 , 也 最 具有 挑战性 的 问题 之一 , 是 影响 并行 分布 计算 执行 效率 的 一个 关键因素 . 现有 的 基于 任务 静态 优先级 的 启发式 任务调度 方法 都 是 以 “ 当前任务 具有 最早 起始 执行 时刻 ” 为 目标 来 选择 执行 处理器 . 该文 在 详细分析 讨论 该种 调度 方法 的 基础 上 , 指出 了 以 该 目标 选择 处理器 存在 的 问题 及 缺点 , 并 提出 了 以 “ 当前任务 的 直接 后继 具有 最早 起始 执行 时刻 ” 为 目标 选择 处理器 的 方法 , 并 给出 了 相应 的 约束条件 . 
 　 　 关键词 　 并行 分布 计算 , 启发式 任务调度 , 处理器 选择 . 
 　 　 中图法 分类号 　 TP316 
 Processor   Selection   Policy   in   Heuristic   Task   Scheduling 
 CHEN   Hua - ping   HUANG   Liu - sheng 
 ( National   High   Performance   Computing   Center   Hefei   230027 ) 
 ( Department   of   Computer   Science   and   Technology   University   of   Science   and   Technology   of   China   Hefei   230027 ) 
 　 　 Abstract 　   As   one   of   the   most   fundmental ,   critical   and   challengable   problems   in   PDC   ( parallel   distributed   computing ) ,   task   scheduling   has   great   influence   on   the   execution   efficiency   of   PDC .   The   existing   heuristic   task   schedulings   based   on   static   task   priorities   always   use   it   as   processor   selection   policy   to   make   the   current   task   have   earliest   start   execution   time .   On   the   basis   of   analysis   of   the   mechanism   in   priority - based   heuristic   task   scheduling ,   the   authors   illustrate   the   drawbacks   of   the   processor   selection   policy   mentioned   above ,   and   propose   a   new   processor   selection   policy ,   i . e ,   to   make   the   successor   of   the   current   task   have   the   earliest   start   time ,   and   give   the   corresponding   restraint . 
 　 　 Key   words 　 Parallel   distributed   computing ,   heuristic   task   scheduling ,   processor   selection . 
 　 　 既然 并行 分布 计算 中 一般 的 任务调度 问题 均 具有 NP 难度 , 那么 , 利用 任务 图 本身 所 包含 的 一些 启发 信息 来 获得 最优 调度 的 近似 解是 经常 被 采用 的 一种 技术 方法 . 其中 基于 任务 静态 优先级 的 启发式 任务调度 方法 , 即表 调度 （ list   scheduling ） 是 并行 分布 计算 中 最为 常用 的 一种 任务调度 技术 ［ 1 ～ 3 ］ . 它 的 主要 思想 是 , 在 编译 时 给 任务 图中 的 每个 任务 按 一定 规则 赋一 优先级 , 并且 把 当前 的 所有 就绪 任务 按 优先级 的 大小 排列 , 建立 一个 就绪 任务 队列 RTQ . 然后 , 每次 从 队列 中 选择 优先级 最高 的 任务 （ 称该 任务 为 当前任务 ） , 按 一定 规则 把 该 任务分配 到 合适 的 处理器 上 , 并 计算 出此 任务 在 该 处理器 上 的 起始 执行 时刻 , 最后 获得 以 Gantt 图 ［ 1 , 4 ］ 形式 表示 的 整个 任务 图 的 调度 结果 . 
 　 　 目前 , 基于 表 调度 的 这类 启发式 任务调度 算法 很多 . 但 它们 的 思想 都 很 相似 , 主要 区别 在于 给 任务 赋 优先级 的 方式 有所不同 . 有些 是 在 基本 表 调度 算法 基础 上 通过 任务 插入 和 任务 复制 等 技术 来 提高 启发式 任务调度 算法 的 执行 性能 ［ 2 , 5 ］ , 这些 算法 均 以 “ 当前任务 具有 最早 起始 执行 时刻 ” 为 目标 来 选择 该 当前任务 的 执行 处理器 号 . 本文 的 主要 工作 就是 在 分析 基本 的 表 调度 算法 和 其 改进 算法 的 基础 上 , 指出 表 调度 算法 中单 以 “ 当前任务 具有 最早 起始 执行 时刻 ” 为 目标 选择 执行 处理器 存在 的 问题 及 缺点 , 并 提出 了 以 “ 当前任务 的 直接 后继 具有 最早 起始 执行 时刻 ” 为 目标 选择 处理器 的 方法 , 同时 给出 了 相应 的 约束条件 . 
 1   基本 模型 及 定义 
 　 　 通常 , 一个 并行程序 的 性质 可用 ( V , , ［ dij ］ , w ( ai ) ) 来 刻画 , 偏序 关系 “ ” 一般 用 任务 图 G = ( V , E ) 来 表示 , 其中 V = { ai ｜ i = 1 , 2 , ... , n } , 为 表示 n 个 任务 的 有权 结点 , 任务 ai 的 工作 负载 w ( ai ) 为 该 结点 的 权重 ; E = { ( ai , aj ) ｜ ai , aj ∈ V } 为 表示 任务 间通信 关系 的 带权 有 向 边 , dij 为 任务 ai 到 aj 的 通信量 ; IMP ( ai ) = { ak ｜ ( ak , ai ) ∈ E ) } , 表示 任务 图中 任务 ai 的 直接 前 趋集 , IMS ( aj ) = { ak ｜ ( aj , ak ) ∈ E ) } , 表示 任务 图中 任务 aj 的 直接 后继 集 . 
 　 　 任务 图 的 一个 调度 其实 就是 任务 图 G 到 目标 机器 的 一个 映射 f : V ｜ → { 1 , 2 , ... , m } × ［ 0 , ∞ ) , f ( ai ) = ( p , t ) , 表示 任务 ai 被 调度 到 编号 为 p 的 处理器 上 , 起始 执行 时间 为 t . 一般 地 , 我们 可用 Gantt 图 GC = { ( p ( ai ) , t ( ai ) ) ｜ ai ∈ V } 来 表示 调度 结果 , 其中 函数 p ( ai ) 表示 分配 给 任务 ai 的 处理器 号 , t ( ai ) 表示 任务 ai 的 起始 执行 时刻 . 
 　 　 定义 1 .   设 ai 为 任务 图 的 一个 结点 , 如果 IMP ( ai ) = , 则 称 结点 ai 为 入口 结点 ; 如果 IMS ( aj ) = , 则 称 结点 aj 为 出口 结点 . 
 　 　 定义 2 .   任务 图中 结点 ai 到 结点 aj 的 一条 路径 的 计算长度 为 该 路径 上 包括 起始 结点 ai 和 终止 结点 aj 在内 的 所有 结点 的 权重 之 和 . 
 　 　 定义 3 .   任务 图中 一个 结点 的 出口 长度 为 从 该 结点 到 出口 结点 的 最大 计算长度 . 结点 的 入口 长度 为 从 入口 结点 到 该 结点 的 最大 计算长度 . 
 　 　 很 明显 , 一般 情况 下 , 出口 长度 大 的 任务 或 入口 长度 小 的 任务 优先 执行 . 当 采用 任务 结点 的 入口 长度 作为 该 任务 优先级 的 主要 部分 时 , 那么 结点 的 出口 长度 就 成为 主要 调度 启发 信息 . 另外 , 入口 长度 、 关键 路径 等 也 是 常用 的 一种 调度 启发 信息 . 在 以下 的 算法 中 , 我们 就 用 结点 的 出口 长度 作为 主要 启发 信息 . 当 两个 结点 的 出口 长度 相同 时 , 可 进一步 通过 它们 的 直接 后继 结点 的 数目 来 决定 它们 的 优先级 的 大小 . 
 　 　 如果 已经 把 一个 任务调度 到 某 一 处理器 上 , 那么 我们 称该 任务 是 已 分配 的 . 如果 结点 任务 ai 的 直接 前趋 已 全部 分配 完毕 , 可 把 该 结点 作为 就绪 任务 插入 到 就绪 任务 队列 RTQ 中 , 插入 后 , RTQ 还是 保持 按照 上面 定义 的 优先级 大小 排列 . 很 明显 , 一 开始 只有 入口 结点 任务 为 就绪 任务 . 在 就绪 任务 队列 中 具有 最高 优先级 的 队首 任务 也 叫 当前 分配任务 , 用 ac 来 表示 , 被 选中 执行 ac 的 处理器 也 叫 当前 处理器 . 
 　 　 在 分布 存储 的 并行计算 模型 上 , 严格 地 讲 , 像 出口 长度 这样 的 启发 信息 应该 包括 通信 延迟 . 但是 , 任务 间 的 通信 延迟 与 这 两个 任务 所 分配 处理器 的 位置 有关 , 把 同一 结点 调度 到 不同 处理器 上 所 产生 的 通信 延迟 是 不同 的 . 例如 , 任务 ai 与 aj 之间 的 通信量 为 dij ≠ 0 , 如果 ai 与 aj 被 调度 到 同一 处理器 上 , 那么 它们 之间 的 通信 延迟 可以 忽略 , 否则 , 就 必须 考虑 这个 通信 延迟 . 事实上 , 如果 目标 机器 是 异构 的 , 那么 各 处理器 的 执行 速度 也 不尽相同 , 这时 , 同一 任务分配 到 不同 处理器 上 的 计算 时间 也 是 不 一样 的 , 所以 , 在 这时 的 任务 图中 各 结点 的 权重 也 是 可变 的 , 因而 结点 的 出口 长度 和 入口 长度 也 是 可变 的 . 在 下面 的 分析 讨论 中 , 假定 处理器 之间 是 全 连接 的 , 任务 图中 的 任务 结点 权重 和 通信 边 权重 已 换算 成 同一时间 单位 , 并且 通信 边 权重 已 包含 消息传递 启动 时间 . 
 2   表 调度 算法 的 基本 思想 
 　 　 为了 在 分布 存储 的 并行 模型 上 采用 静态 的 启发式 任务调度 算法 , 我们 也 可用 结点 的 出口 计算长度 作为 主要 启发 信息 , 但 在 求解 任务 ai 的 起始 执行 时刻 时 , 还 必须 考虑 ai 的 所有 直接 前趋 任务 与 ai 之间 的 通信 延迟 带来 的 开销 . 其实 , 在 给 一个 任务 ai 分配 处理器 时 , 优先 考虑 包含 IMP ( ai ) 结点 的 处理器 , 通过 把 消息传递 量 较大 的 源 结点 和 目标 结点 放在 同一 处理器 上以 减少 通信 延迟 . 
 设 任务 ai 在 处理器 p ( ai ) 上 的 起始 执行 时刻 为 est ( ai , p ( ai ) ) , 执行 完成 时刻 为 ect ( ai , p ( ai ) ) , 那么 , ect ( ai , p ( ai ) ) = est ( ai , p ( ai ) ) + w ( ai ) . 
 　 　 定义 4 .   设 一个 任务 au 在 处理器 Pv 上 的 消息 就绪 时刻 用 mrdt ( au , Pv ) 表示 , 它 为 任务 au 在 Pv 上 执行 时 , 接收 到 所 需 全部 消息 的 最早 时刻 . 
 　 　 一个 任务 的 消息 就绪 时刻 主要 由 它 的 直接 前趋 任务 结点 所 决定 , 即 
 mrdt ( au , Pv ) = maxak ∈ IMP ( au ) { ect ( ak , p ( ak ) ) + dku } . 
 （ 1 ） 
 　 　 一个 任务 的 消息 就绪 时刻 与 该 任务 所在 的 处理器 有关 , 如果 一个 任务 被 分配 到 它 的 某 一前 趋 所在 处理器 上 的话 , 那么 与 该 直接 前趋 的 通信 延迟 可 忽略 . 使式 （ 1 ） 取得 最大值 的 前 趋 任务 也 叫做 任务 au 的 关键 前趋 , 由于 au 的 每个 直接 前趋 任务 的 执行 完成 时刻 不同 , 所以 , au 的 关键 前趋 不 一定 是 与 au 间 通信量 最大 的 直接 前趋 . 
 　 　 如果 想 把 任务 au 分配 在 Pv 上 执行 , 那么 至少 要 等到 消息 就绪 时刻 mrdt ( au , Pv ) 才 有 可能 开始 执行 , 至于 到 该 时刻 能否 真正 开始 执行 , 还要 看 Pv 上 已 分配 的 其他 任务 的 执行 情况 . 我们 把 一个 处理器 已 执行 完其 上面 已 分配任务 的 时刻 称为 该 处理器 的 就绪 时刻 , 用 prdt ( Pi ) 来 表示 处理器 Pi 的 就绪 时刻 , 如果 不 考虑 消息 就绪 时刻 的话 , 它 也 就是 Pi 能 执行 其他 再 分配任务 的 最早 时刻 . 在 整个 系统 中 , 当前 具有 最早 就绪 时刻 的 处理器 称为 最先 就绪 处理器 . 
 　 　 根据 上面 的 分析 可知 , 如果 把 一个 任务 au 分配 到 处理器 Pv 上 执行 , 那么 任务 au 在 Pv 上 的 最早 起始 执行 时刻 为 
 est ( au , Pv ) = max { prdt ( Pv ) , mrdt ( au , Pv ) } . 
 （ 2 ） 
 　 　 目前 , 并行 分布 计算 中 基于 表 调度 的 启发式 任务调度 算法 就是 按照 式 （ 2 ） 来 选择 使 当前任务 具有 最早 起始 执行 时刻 的 处理器 . 
 　 　 图 1 是 一个 示例 任务 图 , 把 每个 任务 的 出口 计算长度 作为 该 任务 的 优先级 . 图 2 是 以 出口 计算长度 为 启发 信息 的 表 调度 算法 LS1 对 该 任务 图 进行 调度 所 获得 的 Gantt 图 , 其 调度 长度 为 12 . 
 
 图 1   示例 任务 图 
 
 图 2   LS1 所 求得 的 Gantt 图 
 　 　 现在 对图 2 稍加 分析 观察 可知 , 对 调度 长度 具有 直接 影响 的 是 任务 执行 序列 ( a1 , a3 , a4 , a5 , a6 , a7 ) , 这个 序列 我们 也 称为 关键 任务 序列 . 从图 2 简单 地 来看 , 任务 a5 似乎 对 调度 长度 影响 不 大 , 但 实际上 , 正是 因为 a5 到 a6 也 存在 较大 的 通信 延迟 , 使得 a6 不能 与 a4 放在 同一个 处理器 上 , 所以 , a5 也 对 调度 长度 有 直接 影响 , 也 属于 关键 任务 序列 . 而 任务 a2 虽然 具有 较 高 的 优先级 , 但是 从图 2 可以 看出 , 即使 晚 一些 执行 a2 , 也 不会 对 调度 长度 产生 什么 影响 . 既然 直接 影响 调度 长度 的 是 关键 任务 序列 , 那么 任务调度 算法 能否 优先 考虑 该 关键 任务 序列 的 执行 呢 ? 实际上 , 在 获得 表示 调度 结果 的 Gantt 图 之前 , 我们 并 不 了解 直接 影响 调度 长度 的 关键 任务 序列 , 通过 图 1 与 图 2 对比 可 发现 , ( a1 , a3 , a4 , a6 , a7 ) 刚好 是 示例 任务 图 的 关键 路径 . 一般 情况 下 , 关键 路径 与 关键 任务 序列 并不一定 相同 , 但 我们 可以 利用 关键 路径 作为 主要 启发 信息 进行 任务调度 . 
 　 　 关键 路径 上 的 任务 偏序 关系 是 确定 的 . 以 关键 路径 作为 主要 启发 信息 的 表 调度 算法 LS2 根据 关键 路径 上 任务 的 偏序 关系 选择 任务 ai , 依 消息 就绪 时刻 的 非增 次序 选择 IMP ( ai ) 中 的 任务 结点 au , 然后 按照 任务 au 能 获得 最早 起始 时刻 为 目标 选择 处理器 号 , 同时 也 确定 了 它 的 执行 时刻 , 最后 , 参照 上面 定义 的 任务 优先级 调度 G 中 其余 的 结点 , 这些 结点 的 执行 对 关键 路径 上 的 任务 没有 影响 . 图 3 显示 了 LS2 算法 对图 1 的 调度 结果 , 很 明显 , 调度 长度 比图 2 少 1 . 
 
 图 3   LS2 所 求得 的 Gantt 图 
 3   对 目标 处理器 选择 规则 的 改进 
 　 　 通过 对图 2 和 图 3 的 分析 观察 可以 发现 , 不管 把 任务 a6 放到 哪个 处理器 上 执行 , 由于 任务 a4 与 a5 到 任务 a6 的 通信量 都 比较 大 , 而 a4 与 a5 又 放在 不同 的 处理器 上 , 所以 a6 不 可能 有 较 早 的 起始 执行 时刻 . 但是 , 如果 把 任务 a4 与 a5 分配 到 同一 处理器 上 执行 , 如图 4 所示 , 这时 反而 能 获得 较 短 的 调度 长度 , 调度 长度 为 8 . 分析 其 原因 可以 发现 , 在 上面 的 启发式 调度 算法 中 , 主要 基于 以 每个 当前任务 ac 具有 最早 的 起始 执行 时刻 为 目标 来 选择 处理器 , 其 目的 就是 为了 使该 任务 的 后继 结点 有 可能 尽早 开始 执行 , 以此类推 , 最终目标 就是 使 出口 结点 能 尽早 执行 , 从而 使 调度 长度 较 小 . 
 
 图 4   选择 策略 改进 后 的 调度 结果 
 　 　 但是 , 局部 最优 调度 某 任务 ac 使 其 具有 最早 起始 执行 时刻 这种 思想 忽略 了 这样 一个 事实 , 即 IMS ( ac ) 的 其他 已 分配 直接 前趋 与 ac 一起 , 对 IMS ( ac ) 的 最早 起始 执行 时刻 是 相互作用 、 相互影响 的 . 有时 在 某些 条件 下 , 如果 局部 地以 当前任务 ac 具有 最早 起始 执行 时刻 来 选择 处理器 , 反而 使得 IMS ( ac ) 中 的 某些 结点 不能 尽早 执行 . 例如 图 2 , 如果 在 给 任务 a5 分配 处理器 P3 时 , 再进一步 测试 如果 把 a5 分配 到 与 a4 相同 的 处理器 上时 , 能否 使 它们 的 共同 直接 后继 结点 a6 的 起始 执行 时刻 提前 . 很 明显 , 如果 把 a5 放到 与 a4 相同 的 处理器 上 , 与 把 a5 分配 到 处理器 P3 相比 , 虽然 a5 晚 0.5 个 时间 单位 开始 执行 , 违背 了 以 当前任务 具有 最早 起始 执行 时刻 为 目标 选择 处理器 的 规则 , 但 它 有 可能 使得 a4 , a5 到 a6 的 通信 延迟 都 为 零 （ 只要 把 a6 分配 到 与 a4 , a5 相同 的 处理器 上 即可 ） , 因而 把 a6 的 起始 执行 时刻 提早到 6 , 并且 只 需要 两个 处理器 就 能 获得 这个 调度 长度 , 所以 这时 就 不能 单以 a5 具有 最早 起始 执行 时刻 来 选择 处理器 . 
 　 　 既然 局部 地以 当前任务 具有 最早 起始 执行 时刻 为 目标 来 分配 处理器 并 不能 获得 较 小 的 调度 长度 , 那么 到底 在 什么样 情况 下 , 我们 才 考虑 把 同为 某 一 结点 的 一些 直接 前趋 任务分配 到 同一 处理器 上 呢 ？ 还是 以图 2 与 图 4 为 例来 说明 , 以 a4 , a5 和 a6 这 3 个 任务 的 局部 小 范围 调度 而言 , 如果 不断 增加 a5 的 计算 时间 , 那么 图 4 的 调度 长度 就 会 相应 地 增加 , 而图 2 的 调度 长度 不变 , 因此 , 把 a5 与 a4 分配 到 同一 处理器 上 所 获得 的 收益 也 相对 减小 . 当 a5 的 计算 时间 增加 到 5 时 , 图 4 中 把 a5 与 a4 分配 到 同一 处理器 上 所 获得 的 调度 长度 也 为 12 , 与 图 2 相同 . 如果 a5 的 计算 时间 大于 5 , 这时 图 4 中 把 a5 与 a4 分配 到 同一 处理器 上 所 获得 的 调度 长度 将 大于 12 . 
 　 　 如果 a5 的 计算 时间 保持 不变 , 而 不断 减小 a4 到 a6 的 通信 时间 , 也 会 使 图 2 的 调度 长度 不断 减小 , 而图 4 的 调度 长度 不变 . 当 a4 到 a6 的 通信 时间 减小 到 1 时 , 图 2 的 调度 长度 也 为 8 , 与 图 4 相同 . 同样 地 , 如果 考虑 减少 a5 到 a6 的 通信 时间 , 也 会 使得 图 2 的 调度 长度 不断 减小 . 与 减小 a4 到 a6 的 通信 时间 所 不同 的 是 , 这时 应 把 a6 分配 到 与 a4 相同 的 处理器 上 . 
 　 　 一般 地 , 在 选定 使 ac 具有 最早 起始 执行 时刻 的 处理器 p ( ac ) 以后 , 还要 进一步 测试 与 ac 具有 相同 后继 ai 的 其他 已 分配 的 直接 前趋 , 从中 选择 其 执行 处理器 不为 p ( ac ) ( 即 p ( aj ) ≠ p ( ac ) ) , 并且 到 p ( ac ) 具有 最大 消息 就绪 时刻 的 任务 aj , 然后 检查 是否 满足 下面 的 条件 : 
 est ( ac , p ( aj ) ) + w ( ac ) ＜ ect ( aj , p ( aj ) ) + dji . 
 ( 3 ) 
 　 　 如果 满足 上 式 条件 , 那么 很 明显 , 把 ac 分配 到 p ( aj ) 上时 , 就 有 可能 使 它们 共同 的 直接 后继 结点 ai 的 起始 执行 时刻 提前 . 
 　 　 定理 1 .   设 一个 任务 结点 au 的 直接 前 趋集 为 { au1 , au2 , ... , auk } , aur 是 使 max { ( ect ( auj , p ( auj ) ) + duju0 ) ｜ j = 1 , 2 , ... , k } 取得 最大值 的 结点 , 其中 u0 = u . 如果 任给 y = 1 , 2 , ... , k 且 y ≠ r , 满足 duju0 ≤ w ( aur ) - ( est ( auy , p ( auy ) ) - est ( aur , p ( aur ) ) ) , 那么 把 任务 au 分配 到 p ( aur ) 上 , 这样 总能 使 任务 au 具有 最早 的 起始 执行 时刻 Tu , Tu = max { ect ( aur , p ( aur ) ) , ( ect ( auj , p ( auj ) ) + duju0 ) ｜ j = 1 , 2 , ... , k , 且 j ≠ r } . 
 　 　 证明 : 可 分 两种 情形 来 说明 . 
 　 　 ( 1 )   如果 上式 中 的 Tu 是 由 ect ( aur , p ( aur ) ) 取得 , 那么 , ect ( aur , p ( aur ) ) ≥ ( ect ( auj , p ( auj ) ) + duju0 ) ｜ j = 1 , 2 , ... , k , 且 j ≠ r ) , 也就是说 , 在 aur 执行 完 以前 , au 的 所有 其他 直接 前趋 任务 的 消息 可以 传送 到 处理器 p ( aur ) 上 , 所以 , 任务 au 不 可能 有 比 ect ( aur , p ( aur ) ) 更 早 的 起始 执行 时刻 . 
 　 　 ( 2 )   如果 上式 中 的 Tu 是 由 max { ( ect ( auj , p ( auj ) ) + duju0 ) ｜ j = 1 , 2 , ... , k , 且 j ≠ r } 取得 , 不妨 设 j = q 时 取得 最大值 , 那么 可以 通过 两种 途径 来 减小 Tu . 
 　 　 ( 2.1 )   把 au 分配 到 处理器 p ( auq ) 上 , 这时 , Tu = max { ect ( auq , p ( auq ) ) , ( ect ( auj , p ( auj ) ) + duju0 ) ｜ j = 1 , 2 , ... , k , 且 j ≠ q } . 根据 条件 , ect ( aur , p ( aur ) ) + duru0 具有 最大值 , 所以 
 ect ( aur , p ( aur ) ) + duru0 ≥ ect ( auq , p ( auq ) ) + duqu0 ＞ ect ( auq , p ( auq ) ) . 
 因此 , 这时 , Tu = ect ( aur , p ( aur ) ) + duru0 , 即 反而 增大 了 au 的 起始 执行 时刻 . 
 　 　 ( 2.2 )   把 任务 auq 与 aur 放到 同一 处理器 上 , 根据 条件 
 duyu0 ≤ w ( aur ) - ( est ( auy , p ( auy ) ) - est ( aur , p ( aur ) ) ) ,   其中 y = 1 , 2 , ... , k 且 y ≠ r , 
 可 得 
 est ( aur , p ( aur ) ) + w ( aur ) ≥ est ( auq , p ( auq ) ) + duqu0 . 
 　 　 在 不等式 两边 同时 加上 w ( auq ) ， 可 得 
 est ( aur , p ( aur ) ) + w ( aur ) + w ( auq ) ≥ est ( auq , p ( auq ) ) + w ( auq ) + duqu0 , 
 即 
 ect ( aur , p ( aur ) ) + w ( auq ) ≥ ect ( auq , p ( auq ) ) + duqu0 . 
 　 　 定理 1 给出 了 在 什么 条件 下 使用 以 “ 当前任务 具有 最早 起始 执行 时刻 ” 为 目标 选择 执行 处理器 才 比较 有效 , 而 当 拥有 相同 后继 结点 的 任务 间 满足条件 ( 3 ) 时 , 应 以 “ 当前任务 的 后继 结点 具有 最早 起始 执行 时刻 ” 为 目标 来 选择 执行 处理器 . 
 4   结   论 
 　 　 目前 , 基于 任务 静态 优先级 的 启发式 任务调度 算法 都 是 以 “ 当前任务 具有 最早 起始 执行 时刻 ” 为 目标 选择 执行 处理器 , 但 在 某些 条件 下 , 这 反而 会 引起 后继 结点 的 延迟 执行 . 本文 在 详细分析 讨论 了 该种 调度 策略 的 基础 上 , 指出 了 以 该 目标 选择 执行 处理器 所 存在 的 不足之处 , 并 提出 了 以 “ 当前任务 的 直接 后继 具有 最早 起始 执行 时刻 ” 为 目标 选择 处理器 的 调度 方法 , 同时 给出 了 相应 的 约束条件 . 
 基金项目 ： 本文 研究 得到 国家 863 高科技 项目 基金 和 安徽省 自然科学 基金 资助 . 
 作者简介 ： 陈华平 , 1965 年生 , 博士 , 副教授 , 主要 研究 领域 为 并行 分布 计算 , 网络 计算 . 
 　 　 　 　 　 黄刘生 , 1957 年生 , 副教授 ， 主要 研究 领域 为 分布 算法 , OODB . 
 作者 单位 ： 国家 高性能 计算中心   合肥   230027 
 　 　 　 　 　 中国 科学技术 大学 计算机 科学技术 系   合肥   230027 
 　 　 　 　 　 E - mail :   hpchen @ ustc . edu . cn 
 本文 通讯联系 人 : 陈华平 ， 合肥   230027 , 国家 高性能 计算中心 
 参考文献 
 　 1   El - Rewini   H ,   Lewis   T   G ,   Ali   H   H .   Task   Scheduling .   New   Jersey :   PTR   Prentice   Hall ,   1994 .   56 ～ 78 
 　 2   陈华平 , 林洪 , 陈国良 . 并行 分布 计算 中 的 启发式 任务调度 . 计算机 研究 与 发展 , 1997 , 34 （ 增刊 ） : 74 ～ 78 
 ( Chen   Hua - ping ,   Lin   Hong ,   Chen   Guo - liang .   Heuristic   task   scheduling   in   parallel   distributed   computing .   Computer   Research   and   Development ,   1997 , 34 ( supplement ) : 74 ～ 78 ) 
 　 3   Sevcik   K   C .   Application   scheduling   and   processor   allcation   in   multiprogrammed   parallel   processing   systems .   Performance   Evaluation ,   1994 , 19 ( 2 / 3 ) : 107 ～ 140 
 　 4   陈华平 , 李京 , 陈国良 . 并行 分布 计算 中 的 任务调度 问题 ( 1 ) . 计算机科学 , 1997 , 24 （ 2 ） : 23 ～ 27 
 ( Chen   Hua - ping ,   Li   Jing ,   Chen   Guo - liang .   Task   scheduling   in   parallel   distributed   computing   ( Part   1 ) .   Computer   Science ,   1997 , 24 ( 2 ) : 23 ～ 27 ) 
 　 5   Ahmad   I ,   Kwork   Y   K .   A   new   approach   to   scheduling   parallel   programs   using   task   duplication .   In :   Proceedings   of   the   International   Conference   on   Parallel   Processing .   Los   Alamitos :   IEEE   Computer   Society   Press ,   1994 .   326 ～ 333 
 本文 1998 - 09 - 18 收到 原稿 , 1999 - 03 - 01 收到 修改稿 
