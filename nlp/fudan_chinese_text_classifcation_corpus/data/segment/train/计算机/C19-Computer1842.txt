微型机 与 应用 
 MICROCOMPUTER   &   ITS   APPLICATIONS 
 2000   Vol.19   No.2   P.45 - 47 
 
 
 
 
 地图 应用 中 层次 － 关系 型 DBMS 的 实 视图 及其 增量 维护 
 王元珍 　 陈懿 
 摘   要 ：   讨论 了 基于 层次 － 关系 模型 的 视图 机制 ， 并 以 OEM 模型 为 基础 ， 提出 了 一个 增量 维护 的 算法 。 
 关键词 ：   GIS   实 视图   对象 交换 模型   层次 － 关系 模型   增量 维护 
 　 　 地理信息系统 （ GIS ） 的 核心 是 地理 数据库 ， 它 要 保存 描述 地图 上 实体 的 属性数据 和 描述 地物 空间 特性 的 空间数据 。 空间数据 量 很大 而且 具有 定位 、 定性 的 特性 ， 选择 适当 的 数据模型 是 提高 系统 性能 的 关键 。 我们 采用 层次 － 关系 的 混合 模型 （ 如图 1 所示 ） ， 将 地图 的 基本 信息 用 上层 关系 来 描述 ， 对于 地图 中 的 各类 地物 ， 用 下层 关系 来 刻画 ， 既 结合 了 层次模型 的 空间 描述 能力 ， 又 能 利用 成熟 的 关系数据库 技术 提高 地理信息系统 的 性能 。 
 　 　 视图 （ view ） 是 通过 查询 语句 定义 的 从 1 个 或 多个 数据源 中 导出 的 表 ， 在 分布式 地图 应用 中 ， 地图 数据 的 数据量 大 ， 还要 面向 常规 信息 的 查询 ， 拓朴 查询 、 空间 分析 以及 屏幕显示 ， 所以 我们 应用 实 视图 机制 ， 在 客户端 保留 一部分 原始数据 的 副本 ， 以 减少 网络 传输 量 ， 减轻 服务器 负荷 ， 提高 地图 应用 的 整体 性能 。 传统 的 关系 模型 数据库 上 的 查询 的 返回值 集 本身 实际上 是 结构 完整 的 “ 小 ” 数据库 。 而 层次 － 关系 模型 是 个 混合 模型 ， 它 同时 包含 描述 层次 的 指针 结构 数据 和 描述 传统 关系 的 表 结构 数据 。 我们 可以 扩充 定义 实 视图 的 SQL 语句 ， 保证 实 视图 与 原始数据 的 结构 一致性 。 这种 实 视图 定义 语句 局限于 特定 的 数据模型 。 本文 我们 将 采用 对象 交换 模型 （ OEM ） 为 中间 模型 ， 讨论 层次 － 关系数据库 上 的 实 视图 机制 和 它 的 增量 维护 算法 。 
 1   DM2 中 的 对象 交换 模型 
 　 　 对象 交换 模型 OEM 是 面向对象 的 模型 ， 已 广泛 用作 异构 数据库 集成 的 中间 模型 。 在 DM2 中 我们 用 OEM 作为 定义 来 实现 实体 视图 的 概念模型 ， 以 简化 混合 模型 上 的 复杂 操作 。 每 一个 对象 （ object ） 由 1 个 四元组 ＜ OID ， label ， type ， value ＞ 表示 。 OID 是 全局 唯一 的 标识 ， label 是 对 对象 的 描述 ， type 可以 是 诸如 integer 和 string 的 原子 类型 ， 也 可以 是 集合 类型 （ set ） 。 集合 类型 的 值 是 一些 其它 对象 的 OID 的 集合 。 OEM 模型 可以 用 只有 1 个根 节点 的 有向图 表示 。 从根 节点 出发 可以 遍历 到 图 中 任一 节点 。 
 　 　 DM2 中 对于 关系 模型 ， 我们 可以 用根  root  表示 关系 名 ， 根 的 每个 孩子 就是 关系 中 的 每个 元组 ， 记为 tuple ． ， 层次 关系 则 用 图 2 中 的 父子关系 描述 ， 层次 － 关系 模型 就 转换 为 OEM 模型 。 
 　 　 例 1 ： 用 OEM 模型 描述 图 2 中 的 层次 － 关系数据库 （ 为了 表示 方便 我们 略去 了 四元组 中 的 类型 和 值 2 个域 ） 。 
 
 图 1 　 层次 - 关系 混合 模型 
 
 图 2 　 层次 - 关系数据库 
 
 图 3 　 OEM 模型 描述 的 图 2 的 层次 一 关系数据库 
 　 　 ROOT 是 1 个 集合 类型 的 对象 ， 它 有 2 个 儿子 ， 分别 代表 地图 的 2 个子 图 。 N1 ， L1 是 原子 类型 。 定义 label （ o ） 表示 对象 的 标注 ， value （ o ） 表示 o 的 值 ， 例如 label （ M11 ） ＝ tuple ， value （ M11 ） ＝ ｛ N1 ， L1 ｝ 。 为 方便 视图 机制 的 描述 ， 作 以下 定义 。 
 　 　 定义 1 ： 一条 路径 （ path ） 是 零个 或 多个 标注 （ label ） 和 点 号 交替 排列 的 序列 ： p ＝ l1 ． l2 … ln 。 例如 river ． R2 就是 一条 路径 。 
 　 　 定义 2 ： N ． p 表示 所有 能 从 对象 N 经 路径 p 达到 的 对象 的 集合 。 如果 N2 ∈ N1 ． p ， 则 N1 是 N2 的 祖先 （ ancestor ） ， N2 是 N1 的 1 个 后代 （ descendent ） ， p 中 的 第一个 标注 是 N1 的 儿子 ， 最后 一个 标注 则 与 N2 的 标注 相同 。 如果 有 N2 ∈ N1 ． p1 ， N3 ∈ N2 ． p2 ， 则 N3 ∈ N1 ． p1 ． p2 。 在 图 3 中 ， 节点 M12 是 节点 ROOT 的 后代 ， 可以 从 ROOT 节点 经 路径 river ． tuple 到达 ， 即 M12   ROOT ． river ． tuple 。 
 　 　 定义 3 ： 集合 类型 的 对象 可 进行 集合 操作 ， union （ S1 ， S2 ） 表示 1 个值 为 ｛ （ value  S1 ） ∪ value （ S2 ） ｝ 的 对象 ， 其中 S1 ， S2 都 是 集合 类型 的 对象 。 定义 int （ S1 ， S2 ） 表示 值为 ｛ value （ S1 ） ∩ value （ S2 ） ｝ 的 对象 。 
 2   视图 与实 视图 
 　 　 基于 面向对象 的 方法 ， 我们 用 以下 形式 的 查询 语句 来 定义 视图 ： 
 　 　 SELECT   OBJ ． Sel ＿ path ＿ exp   X 
 　 　 FROM   DB 
 　 　 WHERE   cond （ X ． cond ＿ path ＿ exp ） 
 　 　 系统 将 查询 所有 由 路径 OBJ ． Sel ＿ path ＿ exp 能 得到 的 对象 ， 当 它 满足条件 cond （ X ． cond ＿ path ＿ exp ） 时 ， 将 它 存入 结果 对象 ＜ ANS ， answer ， set ， value （ ANS ） ＞ 。 这个 结果 对象 就是 视图 的 面向对象 的 描述 。 
 　 　 在 DM2 中 把 结果 对象 与 原来 的 层次 OBJ ． Sel ＿ path ＿ exp 结合 起来 就 能 构造 出 1 个 层次 － 关系 结构 的 结果 数据库 。 该 查询 实现 的 视图 定义 为 ： 
 　 　 define   view   MapView   as ：   
 　 　 　 SELECT   ROOT ． river ． *   X   
 　 　 　 FROM   MAP   
 　 　 　 WHERE   X ． length ＞ 250   
 　 　 这个 视图 用 1 个 对象 ＜ V ， view ， set ， value （ V ） ＞ 表示 。 
 　 　 实体化 的 视图 就是 物理 上 实现 的 视图 ， 它 通过 物理 上 存储 视图 固定 定义 的 数据 ， 减少 查询 时间 。 这 对于 数据仓库 这样 大型 的 数据 基地 的 复杂 查询 ， 具有 很大 的 性能 优势 。 
 　 　 我们 重新 定义 视图 中 对象 的 OID ， 用 类似 路径 的 方式 保持 视图 结构 与 原 数据库 结构 的 一致性 ， 使得 实体 视图 仍然 是 1 个 层次 － 关系数据库 。 当 1 个 新 对象 X 被 创建 并 加入 视图 V 时 ， 把 X 的 OID 改为 V ． X 。   
 　 　 例 2 ： 定义 实体 视图 如下 。   
 　 　 define   mview   MMAPVIEW   as ：   
 　 　 　 　 SELECT   ROOT ． river ． tuple   X   
 　 　 　 　 FROM   MAP   
 　 　 　 　 WHERE   X ． length ＞ 250 
 　 　 得到 的 视图 表示 
 如图 4 所示 。 
 
 图 4 　 实体 视图 
 
 图 5 　 实体 视图 
 　 　 虽然 视图 对象 只有 1 层叶 节点 ， 该叶 节点 对象 的 OID 已 充分 表现 了 原 数据库 的 层次结构 。 
 3   实 视图 的 增量 维护 
 　 　 实体 视图 增加 了 系统 的 维护 代价 ， 系统 必须 在 实体 视图 生成 之后 跟踪 数据源 的 变化 情况 ， 通过 刷新 实现 视图 数据 或 增量 维护 的 方法 保持 实体 视图 与 数据源 的 一致性 。 一般 情况 下 ， 增量 维护 的 代价 小于 刷新 实体 视图 的 代价 。 
 　 　 考虑 3 种 基本 更新 ： 
 　 　 1 ． insert （ N1 ， N2 ） ： 将 N2 的 OID 加入 到 value （ N1 ） ， N1 必须 是 集合 类型 ， 更新 完成 后 N2 成为 N1 的 儿子 。 
 　 　 2 ． delete （ N1 ， N1 ） ： 将 N2 的 OID 从 value （ N1 ） 中 删除 。 前提 是 N2 是 N1 的 儿子 。 
 　 　 3 ． modify （ N ， oldv ， newv ） ： 把 原子 类型 的 对象 从 oldv 更新 为 newv 。 
 　 　 假设 例 1 数据库 中 执行 更新 inser （ M1 ， M13 ） ， 这时 M13 只是 个空 对象 ， 对 实体 视图 没有 影响 。 再 执行 更新 insert （ M13 ， L13 ） ， 其中 L13 表示 对象 ＜ L13 ， length ， interger ， 350 ＞ ， 这时 实体 视图 就 受到 影响 ， 如图 5 所示 。 因此 我们 这里 的 基本 更新 不 包括 第一次 执行 的 插入 更新 。 同理 ， 当 删除 1 个 地物 的 某个 属性 时 ， 如果 该 属性 满足 cond  X ． cond ＿ path ＿ exp  ， 那么 该 属性 的 某个 祖先 对象 就要 被 删除 。 下面 的 算法 1 就是 根据 OEM 树 的 特性 ， 检测 被 更新 对象 在 实 视图 对象 中 对应 的 祖先 ， 然后 对 这个 祖先 进行 更新 。 
 算法 ： 视图 MV 的 增量 维护 
 
 
 　 　 注意 到 从 1 个 节点 到 另 1 个 节点 最 多 只有 1 条 路径 ， 我们 用 path （ N1 ， N2 ） 来 表示 从 N1 到 N2 的 路径 ， 如果 N1 不是 N2 的 祖先 ， 则 path （ N1 ， N2 ） ＝ φ   。 我们 为 算法 1 作 以下 定义 ： （ 1 ） ancestor （ N ， p ） 表示 N 的 祖先 X ， 它 满足 path （ X ， N ） ＝ p 。 如果 不 存在 这样 的 对象 ， ancestor （ N ， p ） ＝ φ   。 （ 2 ） eval （ N ， p ， cond ） 返回 N ． p 中 满足 cond （ N ． p ） 的 所有 对象 的 集合 。 当 没有 对象 满足 该 条件 时 返回   。 （ 3 ） Vinsert （ VN1 ， VN2 ） 表示 创建对象 VN2 并 把 它 加入 到 value （ VN1 ） 中 。 如果 VN2 已经 在 value （ VN1 ） 中 ， 该 操作 忽略 。 （ 4 ） Vdelete （ VN1 ， VN2 ） 表示 将 对象 VN2 从 value （ VN1 ） 中 删除 。 如果 value （ VN1 ） 中 不 存在 VN2 ， 该 操作 忽略 。   
 　 　 例 2 中 数据库 执行 insert  M1 ， M13  更新 时 视图 不用 更新 ， 执行 insert  M13 ， L13  更新 时 ， 视图 增量 维护 过程 将 根据 算法 1 执行 以下 步骤 ： 
 第 1 步 ： 检测 到 发生 视图 更新 操作 insert （ M13 ， L13 ） ； 第 2 步 ： 因为 path （ ROOT ， M13 ） ＝ river ． tuple ， sel ＿ path ＝ river ． tuple ， cond ＿ path ＝ length ， 有 sel ＿ path ． cond ＿ path ＝ path （ ROOT ， M13 ） ． label （ L13 ） ． p ， 此时 p ＝   φ ； 
 第 3 步 ： 令 S ＝ eval （ L13 ， φ ， cond ） ＝ （ L13 ） ， L13 存在 于 S 中 ， 因为 value （ L13 ） ＝ 350 ＞ 250 。 因此 对 L13 的 插入 将 使得 L13 的 某个 祖先 要 被 插入 视图 ； 第 4 步 ： 令 Y ＝ ancestor （ L13 ， length ） ＝ M13 ， 执行 Vinsert （ MMAPVIEW ， MMAPVIEW ． M13 ） 。 此时 MMAPVIEW ． M13 成为 视图 MMAPVIEW 的 儿子 。   
 　 　 本文 讨论 了 地图 应用 中 层次 － 关系 混合 模型 上 的 实 视图 定义 与 实现 ， 并 给出 了 基于 OEM 的 实 视图 增量 维护 算法 。 数据库 实 视图 应该 保留 数据源 的 层次 － 关系 结构 。 对象 交换 模型 OEM 普遍 用于 异构 数据 集成 的 中间 模型 ， 同时 能够 作为 混合 模型 的 数据库 上 的 中间 模型 使 视图 定义 与 实现 更 统一 自然 。 它 使得 同一 视图 定义 语句 能 从 不同 结构 的 数据源 导出 实 视图 ， 提高 了 地图 应用 系统 的 适应性 ， 缺点 是 需要 额外 的 模型 转换 工作 。 
 王元珍 （ 武昌 华中理工大学 数据库 与 多媒体技术 研究所  430074 ） 
 陈懿 （ 武昌 华中理工大学 数据库 与 多媒体技术 研究所  430074 ） 
 收稿 日期 ： 1999 － 08 － 21 
