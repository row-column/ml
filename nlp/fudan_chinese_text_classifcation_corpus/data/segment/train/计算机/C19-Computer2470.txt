软件 学报 
 JOURNAL   OF   SOFTWARE 
 2000 　 Vol.11 　 No.2 　 P.240 - 250 
 
 
 
 电子商务 安全 协议 及其 非 单调 动态 逻辑 验证 
 陈庆锋 　 白硕 　 王驹 　 张师超 　 隋立颖 
 摘 　 要 ： 该文 介绍 了 SET ( secure   electronic   transactions ) 的 付费 业务流程 , 对 NDL ( non - monotomic   dynamic   logic ) 的 逻辑 框架 进行 了 扩展 , 即 针对 SET 协议 , 增加 了 新 的 公理 , 重新 给出 积累 规则 的 定义 . 在 此基础 上 , 用 对 SET 中 的 几个 重要 的 范例 进行 的 逻辑 验证 , 说明 了 NDL 在 验证 电子商务 协议 上 的 重要性 , 并 初步 提出 了 积累 规则 中 需要 进一步 研究 的 问题 . 
 关键词 ： 信息安全 , 逻辑 验证 , 电子商务 , 注册 , 付费 . 
 分类号 ： TP309 
 The   Secure   Electronic   Transactions   Protocol   and   Its   Logical   Verification   with   Non - Monotomic   Dynamic   Logic 
 CHEN   Qing - feng 　 BAI   Shuo 　 Sui   Li - ying 
 ( National   Research   Center   for   Intelligent   Computing   Systems   Beijing   100080 ) 
 CHEN   Qing - feng 　 ZHANG   Shi - chao 
 ( Department   of   Mathemetics   Computer   Science   Guangxi   Normal   University   Guilin   541004 ) 
 WANG   Ju 
 ( Institute   of   Software   The   Chinese   Academy   of   Sciences   Beijing   100080 ) 
 Abstract ： This   paper   introduces   the   payment   process   of   SET ( secure   electronic   transactions ) protocol , and   extends   the   logical   framework   of   NDL   to   fit   the   purpose   of   logical   verification   of   SET . This   means   to   add   some   new   axioms   about   SET   protocols   and   redefine   some   given   inference   rules . Based   on   these , the   logical   verification   for   key   fragments   of   SET   protocol   is   given   to   show   the   importance   of   NDL   and   its   extensions   in   E - commerce . Topics   for   further   research   on   the   “ Rule   of   Accumulation ”   are   also   proposed . 
 Key   words ： Information   security , logical   verification , electronic   commerce , registration , payment . ▲ 
 　 　 随着 Internet 国际 互联网 的 日趋 流行 , 它 已经 渗透到 社会 上 的 各行各业 , 在 金融 、 教学 、 科研 上起 着 重要 作用 . 同时 , 由于 互联网 上 传播 信息量 的 增加 , 如何 保证 网上 信息 传播 的 安全 成 了 人们 日益 关注 的 一个 重要 问题 . 在 这个 过程 当中 , 因为 电子商务 与 人们 日常生活 的 关系 最 密切 , 它 的 安全性 问题 就 成 了 最 敏感 的 领域 . 实际上 , 电子商务 对 传统 金融业 的 冲击 已经 是 不可否认 的 事实 , 任何 组织 和 个人 只要 在 互联网 上 建立 一个 WWW 站点 地址 , 就 可以 通过 网络 进行 购物 和 付费 , 可以 说 , Internet 改变 了 人们 传统 的 生活 方式 . 正 因为 电子商务 的 重要性 , 为了 提供 一种 安全 、 有效 的 购物 方式 , 世界 上 的 几大 公司 , 如 IBM , Microsoft , Netscape , RSA , SAIC , Terisa 和 Versign 共同 制定 了 SET ( secure   electronic   transactions ) 电子商务 安全 协议 ［ 1 , 2 ］ . 
 　 　 以往 对 安全 协议 的 验证 有 很多 手段 , 一种 是 用 常规 的 方法 , 对 协议 进行 实际 攻击 , 另 一种 是从 表面 上 进行 直观 检测 . 但是 , 前者 必须 在 系统 已经 建立 之后 才能 检测 出 它 的 错误 ; 后者 由于 检测 手段 不够 严密 , 难免 有 疏漏 之处 . 形式化 逻辑 方法 的 出现 , 使得 我们 可以 在 安全 协议 付诸实施 之前 , 用 一种 严密 可靠 的 方法 对 它 的 安全 性质 进行 验证 , 正是 由于 它 的 严密性 , 使 它 成为 信息安全 领域 中 的 一个 重要 研究 方向 . 
 　 　 在 众多 的 验证 逻辑 , 如 BAN ［ 3 ］ , GNY ［ 4 ］ , AUTLOG ［ 5 ］ 中 , 要么 没有 监听 者 , 要么 过于 复杂 , 要么 过于 简单 , 并 不能 从根本上 解决问题 . Kailar ［ 6 ］ 提出 的 方法 比较 明确 地 针对 安全 协议 中 的 “ 责任 性 ” , 他 所 建立 的 框架 保证 任何一方 一旦 做 了 某个 动作 , 用 逻辑 的 方法 就 能够 证明 , 使 他 对 所 做 过 的 动作 无法 抵赖 . 
 　 　 而 在 文献 ［ 7 ］ 中 提出 的 NDL ( non - monotomic   dynamic   logic ) 验证 逻辑 , 引入 了 通信安全 问题 上 的 动态性 ( dynamic ) 和 非 单调 性 ( non - monotonic ) 两种 概念 , 使 它 更加 符合 SET 协议 中 电子商务 的 特征 , 也 为 我们 对 SET 协议 进行 逻辑 验证 打下 了 坚实 的 基础 . 
 　 　 本文 的 第 1 节是 SET 协议 简介 . 第 2 节对 NDL 进行 了 扩展 . 第 3 节是 对 SET 中 的 几个 范例 的 验证 . 第 4 节对 全文 进行 总结 , 并 提出 了 积累 规则 的 符号 表示 中 可能 存在 的 一些 问题 . 
 1   SET 的 付费 业务流程 简介 
 　 　 SET 的 付费 业务 处理 ［ 1 , 2 ］ 主要 由 持卡人 注册 、 商家 注册 、 购买 请求 付费 认证 、 付费 获得 这 几个 部分 组成 . 
 1.1   持卡人 注册 
 　 　 持卡人 C 向 商家 发送 SET 消息 之前 , 必须 向 证书 授权 当局 CA ( certificate   authorities ) 注册 , 同时 为了 能 向 CA 发送 SET 消息 , 持卡人 必须 知道 CA 的 数据交换 公钥 , 它 由 CA 的 数据交换 公钥 证书 提供 . 当 持卡人 要求 CA 的 数据交换 公钥 证书 时 , 处理过程 开始 . 具体步骤 如下 : 
 　 　 . 持卡人 软件 
 　 　 ( 1 )   持卡人 向 证书 授权 当局 CA 发出 初始化 请求 . 
 　 　 . 证书 授权 当局 
 　 　 ( 2 )   证书 授权 当局 收到 初始化 请求 . 
 　 　 ( 3 )   证书 授权 当局 产生 初始化 回答 , 并 产生 初始化 回答 的 消息 文摘 , 然后 用 证书 授权 当局 CA 的 签名 私钥 加密 该 消息 文摘 , 得到 初始化 回答 消息 的 数字签名 . 
 　 　 ( 4 )   证书 授权 当局 向 持卡人 发送 初始化 回答 、 初始化 回答 消息 的 数字签名 、 CA 的 签名 公钥 证书 和 CA 的 数据交换 公钥 证书 . 
 　 　 . 持卡人 软件 
 　 　 ( 5 )   持卡人 收到 初始化 回答 , 并 通过 PKI ( public   key   infrastructure ) 信任 树 , 即 沿着 信任 链 直到 树根 , 逐级 验证 CA 证书 的 合法性 . 
 　 　 ( 6 )   持卡人 通过 比较 用 CA 的 签名 公钥 解开 CA 签名 得到 的 结果 和 收到 的 初始化 回答 消息 产生 的 消息 文摘 是否 一致 来 验证 CA 签名 的 合法性 . 
 　 　 ( 7 )   持卡人 输入 他 的 帐号 . 
 　 　 ( 8 )   持卡人 软件 产生 注册表 请求 . 
 　 　 ( 9 )   持卡人 软件 用 一个 随机 产生 的 单钥 k1 加密 注册表 请求 消息 , 并用 CA 的 数据交换 公钥 加密 k1 与 持卡人 的 帐号 , 形成 数字 信封 . 
 　 　 ( 10 )   持卡人 软件 将 所 产生 的 消息 发送给 CA . 
 　 　 . 证书 授权 当局 
 　 　 ( 11 )   CA 用 他 的 数据交换 私钥 解 出 持卡人 的 单钥 k1 及 帐号 , 然后 用 k1 解出 注册表 请求 . 
 　 　 ( 12 )   CA 用 帐号 的 前 6 ～ 11 位来 识别 持卡人 的 金融机构 , 并 选定 合适 的 注册表 . CA 产生 注册表 的 消息 文摘 , 然后 用 CA 的 签名 私钥 加密 , 得到 注册表 的 数字签名 . 
 　 　 ( 13 )   CA 向 持卡人 发送 注册表 和 他 的 签名 公钥 证书 . 
 　 　 . 持卡人 软件 
 　 　 ( 14 )   持卡人 软件 收到 注册表 , 然后 通过 PKI 信任 树 验证 CA 签名 证书 的 合法性 . 
 　 　 ( 15 )   持卡人 软件 通过 比较 用 CA 签名 公钥 解开 CA 签名 所 得到 的 结果 和 自己 产生 的 所 收到 的 注册表 消息 的 消息 文摘 是否 一致 , 来 验证 CA 签名 的 合法性 . 
 　 　 ( 16 )   持卡人 软件 产生 一对 签名 密钥 . 
 　 　 ( 17 )   持卡人 完成 注册表 ( 向 注册表 填 信息 , 例如 持卡人 名称 、 届满 日期 、 帐单 地址 及其 他 一些 被 金融机构 用来 辨别 是否 有效 的 持卡人 的 信息 ) . 
 　 　 ( 18 )   持卡人 软件 产生 包含 输入 注册表 信息 的 证书 请求 . 
 　 　 ( 19 )   持卡人 软件 将 证书 请求 、 持卡人 的 签名 公钥 和 一个 新 产生 的 单钥 k2 一起 形成 一个 新 的 消息 , 然后 用 持卡人 的 签名 私钥 对 它 签名 . 
 　 　 ( 20 )   持卡人 软件 用 一个 随机 产生 的 单钥 k3 加密 第 ( 19 ) 步 产生 的 结果 , 并用 CA 的 数据交换 公钥 加密 k3 与 持卡人 的 帐户 信息 , 形成 数字 信封 . 
 　 　 ( 21 )   持卡人 软件 将 所 产生 的 消息 发送给 CA . 
 　 　 . 证书 授权 当局 
 　 　 ( 22 )   CA 用 他 的 数据交换 私钥 解出 k3 与 持卡人 帐号 , 然后 用 k3 解出 证书 请求 . 
 　 　 ( 23 )   CA 通过 比较 用 持卡人 的 签名 公钥 解开 持卡人 签名 得到 的 结果 和 自己 产生 的 所 收到 消息 的 消息 文摘 是否 一致 , 来 验证 持卡人 签名 的 合法性 . 
 　 　 ( 24 )   CA 用 持卡人 的 帐户 信息 和 从 注册表 得到 的 信息 验证 证书 请求 的 合法性 . 
 　 　 ( 25 )   基于 第 ( 24 ) 步 的 验证 , CA 产生 持卡人 签名 公钥 证书 , 并用 CA 的 签名 私钥 对 它 签名 . 
 　 　 ( 26 )   CA 产生 证书 回答 , 并用 CA 的 签名 私钥 对 它 作 数字签名 . 
 　 　 ( 27 )   CA 用 从 持卡人 请求 得到 k2 的 加密 第 ( 26 ) 步时 所 产生 的 消息 . 
 　 　 ( 28 )   CA 将 加密 的 证书 回答 、 持卡人 的 签名 公钥 证书 和 CA 的 签名 公钥 一起 发送给 持卡人 . 
 　 　 . 持卡人 软件 
 　 　 ( 29 )   持卡人 软件 通过 PKI 树 验证 CA 的 签名 公钥 证书 和 持卡人 的 签名 公钥 证书 的 合法性 . 
 　 　 ( 30 )   持卡人 软件 用 第 ( 19 ) 步 存储 的 k2 解出 回答 . 
 　 　 ( 31 )   持卡人 软件 通过 比较 用 CA 的 签名 公钥 解开 CA 签名 得到 的 结果 和 回答 消息 新 产生 的 消息 文摘 是否 一致 来 验证 CA 签名 的 合法性 . 
 　 　 ( 32 )   持卡人 软件 为 将来 的 电子 交易 存储 签名 公钥 证书 和 从 回答 得到 的 相关 信息 . 
 1.2   商家 注册 
 　 　 为了 能 从 持卡人 收到 SET 付费 指令 或能 通过 付费 网关 处理 SET 业务 , 商家 M 必须 先 向 证书 授权 当局 CA 注册 . 同时 , 为了 向 CA 发送 SET 消息 , 商家 必须 知道 CA 的 数据交换 公钥 , 它 由 CA 的 数据交换 公钥 证书 提供 . 此外 , 商家 还 需要 从 商家 金融机构 得到 注册表 . 
 　 　 当 商家 软件 要求 CA 的 数据交换 公钥 证书 和 适合 自己 的 注册表 时 , 注册 过程 开始 . 具体步骤 如下 : 
 　 　 . 商家 软件 
 　 　 ( 1 )   商家 软件 向 CA 发出 初始化 请求 . 
 　 　 . 证书 授权 当局 
 　 　 ( 2 )   CA 收到 初始化 请求 . 
 　 　 ( 3 )   CA 选定 合适 的 注册表 , 产生 注册表 的 消息 文摘 , 然后 用 CA 的 签名 私钥 加密 , 产生 数字签名 . 
 　 　 ( 4 )   CA 向 商家 发送 注册表 、 CA 的 签名 公钥 证书 和 数据交换 公钥 证书 . 
 　 　 . 商家 软件 
 　 　 ( 5 )   商家 软件 收到 注册表 , 并 通过 PKI 验证 CA 的 证书 的 合法性 . 
 　 　 ( 6 )   商家 软件 通过 比较 用 CA 的 签名 公钥 解开 CA 签名 得到 的 结果 和 收到 的 注册表 消息 新 产生 的 消息 文摘 是否 一致 来 验证 CA 签名 的 合法性 . 
 　 　 ( 7 )   商家 软件 产生 两对 密钥 , 一对 为 其 签名 密钥 , 另 一对 为 其 数据交换 密钥 . 
 　 　 ( 8 )   商家 完成 注册表 ( 例如 姓名 、 地址 、 身份证号 等 ) . 
 　 　 ( 9 )   商家 软件 产生 证书 请求 . 
 　 　 ( 10 )   商家 软件 将 证书 请求 、 商家 产生 的 签名 公钥 和 数据交换 公钥 一起 形成 一个 消息 , 然后 用 商家 的 签名 私钥 加密 该 消息 的 消息 文摘 得到 数字签名 . 
 　 　 ( 11 )   商家 软件 用 一个 随机 产生 的 单钥 k1 加密 第 ( 10 ) 步 产生 的 消息 . 然后 用 CA 的 数据交换 公钥 加密 k1 和 商家 的 帐户 数据 形成 数字 信封 . 
 　 　 ( 12 )   商家 软件 向 CA 发送 加密 的 证书 请求 消息 . 
 　 　 . 证书 授权 当局 
 　 　 ( 13 )   CA 用 自己 的 数据交换 私钥 解出 k1 和 商家 的 帐户 数据 , 然后 用 k1 解出 证书 请求 消息 . 
 　 　 ( 14 )   CA 通过 比较 用 商家 的 签名 公钥 解开 商家 签名 得到 的 结果 和 证书 请求 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 商家 签名 的 合法性 . 
 　 　 ( 15 )   CA 用 商家 的 帐户 信息 和 注册表 上 的 信息 来 确认 证书 请求 的 合法性 . 
 　 　 ( 16 )   基于 上述 验证 , CA 用 自己 的 签名 私钥 对 CA 产生 的 商家 证书 签名 . 
 　 　 ( 17 )   CA 产生 证书 回答 , 并用 自己 的 签名 私钥 对 它 作 数字签名 . 
 　 　 ( 18 )   CA 向 商家 发送 回答 . 
 　 　 . 商家 软件 
 　 　 ( 19 )   商家 软件 通过 PKI 树 验证 收到 的 证书 的 合法性 . 
 　 　 ( 20 )   商家 软件 通过 比较 用 CA 的 签名 公钥 解开 CA 签名 得到 的 结果 和 回答 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 CA 签名 的 合法性 . 
 　 　 ( 21 )   商家 软件 为 将来 的 电子 交易 存储 证书 和 从 回答 得到 的 消息 . 
 1.3   购买 请求 
 　 　 当 持卡人 已 完成 浏览 、 选择 和 定货 后 , SET 协议 才 起 作用 . 为了 向 商家 发送 SET 消息 , 持卡人 必须 知道 付费 网关 P 的 数据交换 密钥 . 当 持卡人 软件 要求 付费 网关 的 数据交换 公钥 证书 时 , SET 的 订购 处理 开始 . 持卡人 发出 的 消息 表明 , 在 交易 中将 使用 哪 一种 付费卡 品牌 . 具体步骤 如下 : 
 　 　 . 持卡人 软件 
 　 　 ( 1 )   持卡人 完成 浏览 和 选购 . 
 　 　 ( 2 )   持卡人 软件 向 商家 发送 初始化 请求 . 
 　 　 . 商家 软件 
 　 　 ( 3 )   商家 软件 收到 初始化 请求 . 
 　 　 ( 4 )   商家 软件 产生 回答 , 并用 商家 的 签名 私钥 加密 回答 的 消息 文摘 , 产生 回答 的 数字签名 . 
 　 　 ( 5 )   商家 软件 向 持卡人 发送 回答 , 商家 的 签名 公钥 证书 和 付费 网关 P 的 数据交换 公钥 证书 . 
 　 　 . 持卡人 软件 
 　 　 ( 6 )   持卡人 软件 收到 初始化 回答 , 并 通过 PKI 树 验证 商家 和 付费 网关 证书 的 合法性 . 
 　 　 ( 7 )   持卡人 软件 通过 比较 用 商家 签名 公钥 解开 商家 签名 得到 的 结果 和 回答 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 商家 签名 的 合法性 . 
 　 　 ( 8 )   持卡人 软件 用 从 浏览 和 选购 阶段 得到 的 信息 产生 订购 信息 OI ( order   information ) . 
 　 　 ( 9 )   持卡人 软件 完成 付费 指令 PI ( payment   instruction ) . 
 　 　 ( 10 )   持卡人 软件 用 自己 的 签名 私钥 产生 OI 和 PI 的 双重 签名 . 
 　 　 ( 11 )   持卡人 软件 用 一个 随机 产生 的 单钥 k1 加密 PI 的 双重 签名 . 然后 将 k1 与 持卡人 的 帐户 信息 一起 , 用 付费 网关 的 数据交换 公钥 加密 , 形成 数字 信封 . 
 　 　 ( 12 )   持卡人 软件 向 商家 发送 OI 、 加密 后 的 PI 、 双重 签名 和 持卡人 的 签名 证书 . 
 　 　 . 商家 软件 
 　 　 ( 13 )   商家 软件 通过 PKI 树 验证 持卡人 证书 的 合法性 . 
 　 　 ( 14 )   商家 软件 用 持卡人 签名 公钥 解开 OI 的 双重 签名 , 通过 比较 得到 的 结果 和 OI 及 PI 的 消息 文摘 连接 后 得到 的 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 OI 上 双重 签名 的 合法性 . 
 　 　 ( 15 )   商家 M 处理 请求 ( 包括 将 付费 指令 PI 提交 付费 网关 P 认证 ) . 
 　 　 ( 16 )   商家 软件 产生 包含 有 商家 签名 证书 的 购买 回答 , 然后 用 商家 的 签名 私钥 对 它 作 数字签名 . 
 　 　 ( 17 )   商家 软件 向 持卡人 传送 购买 回答 和 他 自己 的 签名 公钥 证书 . 
 　 　 ( 18 )   若 业务 被 认证 , 商家 履行 持卡人 的 业务 要求 ( 例如 , 发货 ) . 
 　 　 . 持卡人 软件 
 　 　 ( 19 )   持卡人 软件 通过 PKI 树 验证 商家 签名 的 合法性 . 
 　 　 ( 20 )   持卡人 软件 通过 比较 用 商家 的 签名 公钥 解开 商家 签名 得到 的 结果 和 购买 回答 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 商家 签名 的 合法性 . 
 　 　 ( 21 )   持卡人 软件 存储 购买 回答 . 
 1.4   付费 认证 
 　 　 当 处理 持卡人 的 定货 时 , 商家 将 认证 该项 业务 . 具体步骤 如下 : 
 　 　 . 商家 软件 
 　 　 ( 1 )   商家 软件 产生 认证 请求 . 
 　 　 ( 2 )   商家 软件 用 自己 的 签名 私钥 加密 认证 请求 的 消息 文摘 , 产生 认证 请求 的 数字签名 . 
 　 　 ( 3 )   商家 软件 用 一个 随机 产生 的 单钥 k2 加密 认证 请求 和 其 数字签名 . 然后 用 付费 网关 的 数据交换 公钥 加密 k2 , 形成 数字 信封 . 
 　 　 ( 4 )   商家 软件 将 加密 的 认证 请求 及 数字签名 、 从 持卡人 的 购买 请求 得到 的 加密 的 PI 、 持卡人 的 签名 公钥 证书 和 商家 的 证书 传送 给 付费 网关 . 
 　 　 . 付费 网关 
 　 　 ( 5 )   付费 网关 用 PKI 树 验证 商家 证书 的 合法性 . 
 　 　 ( 6 )   付费 网关 用 自己 的 数据交换 私钥 解出 k2 , 并用 k2 解出 认证 请求 . 
 　 　 ( 7 )   付费 网关 通过 比较 用 商家 签名 公钥 解开 商家 签名 得到 的 结果 和 认证 请求 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 商家 签名 的 合法性 . 
 　 　 ( 8 )   付费 网关 用 PKI 树 验证 持卡人 的 签名 公钥 证书 的 合法性 . 
 　 　 ( 9 )   付费 网关 用 自己 的 数据交换 私钥 解出 k1 和 持卡人 的 帐户 信息 . 然后 用 k1 解出 PI . 
 　 　 ( 10 )   付费 网关 利用 持卡人 的 签名 公钥 验证 持卡人 在 PI 上 的 双重 签名 的 合法性 . 
 　 　 ( 11 )   付费 网关 确认 商家 的 认证 请求 与 持卡人 的 付费 指令 PI 之间 的 一致性 . 
 　 　 ( 12 )   付费 网关 通过 金融网 把 认证 请求 传给 持卡人 的 金融机构 . 
 　 　 ( 13 )   付费 网关 产生 认证 回答 , 然后 用 付费 网关 的 签名 私钥 加密 认证 回答 的 消息 文摘 , 得到 认证 回答 消息 的 数字签名 . 
 　 　 ( 14 )   付费 网关 用 一个 新 的 随机 产生 的 单钥 k3 加密 认证 回答 . 然后 用 商家 的 数据交换 公钥 加密 k3 和 持卡人 的 帐户 信息 , 形成 数字 信封 . 
 　 　 ( 15 )   付费 网关 产生 获得 令牌 （ CapToken ） , 用 付费 网关 的 签名 私钥 加密 获得 令牌 的 消息 文摘 , 得到 数字签名 . 
 　 　 ( 16 )   付费 网关 用 一个 新 的 随机 产生 的 单钥 k4 加密 获得 令牌 . 然后 用 付费 网关 的 数据交换 公钥 加密 k4 跟 持卡人 的 帐户 信息 , 形成 数字 信封 . 
 　 　 ( 17 )   付费 网关 向 商家 传送 认证 回答 . 
 　 　 . 商家 软件 
 　 　 ( 18 )   商家 软件 用 PKI 树 验证 付费 网关 签名 公钥 证书 的 合法性 . 
 　 　 ( 19 )   商家 软件 用 商家 的 数据交换 私钥 解出 k3 , 然后 用 k3 解出 认证 回答 . 
 　 　 ( 20 )   商家 软件 通过 比较 用 付费 网关 的 签名 公钥 解开 付费 网关 签名 得到 结果 和 认证 回答 消息 新 产生 消息 文摘 是否 一致 , 来 验证 付费 网关 签名 的 合法性 . 
 　 　 ( 21 )   商家 软件 为 以后 的 获得 处理 而 存储 加密 的 获得 令牌 和 信封 . 
 　 　 ( 22 )   商家 完成 购买 请求 处理 . 
 1.5   付费 获得 
 　 　 当 完成 持卡人 的 定货 处理 后 , 商家 将 请求 付费 . 具体步骤 如下 : 
 　 　 . 商家 软件 
 　 　 ( 1 )   商家 软件 产生 获得 请求 . 
 　 　 ( 2 )   商家 软件 在 获得 请求 中 加入 商家 的 证书 , 并用 商家 的 签名 私钥 加密 获得 请求 的 消息 文摘 , 产生 数字签名 . 
 　 　 ( 3 )   商家 软件 用 一个 随机 产生 的 单钥 k5 加密 获得 请求 , 然后 用 付费 网关 的 数据交换 公钥 加密 k5 , 形成 数字 信封 . 
 　 　 ( 4 )   商家 软件 向 付费 网关 传送 加密 的 获得 请求 和 以前 从 认证 回答 存储 的 加密 的 获得 令牌 及 商家 的 证书 . 
 　 　 . 付费 网关 
 　 　 ( 5 )   付费 网关 用 PKI 树 验证 商家 证书 的 合法性 . 
 　 　 ( 6 )   付费 网关 用 自己 的 数据交换 私钥 解出 k5 , 然后 用 k5 解出 获得 请求 . 
 　 　 ( 7 )   付费 网关 通过 比较 用 商家 签名 公钥 解开 商家 签名 得到 的 结果 和 获得 请求 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 商家 签名 的 合法性 . 
 　 　 ( 8 )   付费 网关 用 自己 的 数据交换 私钥 解出 k4 , 然后 用 k4 解出 获得 令牌 . 
 　 　 ( 9 )   付费 网关 确认 商家 的 获得 请求 和 获得 令牌 之间 的 一致性 . 
 　 　 ( 10 )   付费 网关 通过 一个 金融网 向 持卡人 的 金融机构 发送 获得 请求 . 
 　 　 ( 11 )   付费 网关 产生 获得 回答 信息 , 包括 付费 网关 的 签名 证书 , 并用 付费 网关 的 签名 私钥 加密 获得 回答 消息 的 消息 文摘 , 产生 数字签名 . 
 　 　 ( 12 )   付费 网关 用 一个 新 的 随机 产生 的 单钥 k6 加密 获得 回答 , 然后 用 商家 的 数据交换 公钥 加密 k6 . 
 　 　 ( 13 )   付费 网关 向 商家 发送 加密 的 获得 回答 . 
 　 　 . 商家 软件 
 　 　 ( 14 )   商家 软件 用 PKI 树 验证 付费 网关 证书 的 合法性 . 
 　 　 ( 15 )   商家 软件 用 自己 的 数据交换 私钥 解出 k6 , 然后 用 k6 解出 获得 回答 . 
 　 　 ( 16 )   商家 软件 通过 比较 用 付费 网关 的 签名 公钥 解开 付费 网关 签名 得到 的 结果 和 获得 回答 消息 新 产生 的 消息 文摘 是否 一致 , 来 验证 付费 网关 签名 的 合法性 . 
 　 　 ( 17 )   为了 与 请求者 收到 的 付费 保持一致 , 商家 软件 存储 获得 回答 . 
 上面 给出 了 SET 协议 的 5 个 付费 流程 的 介绍 , 为了 对 SET 进行 逻辑 验证 , 必须 扩展 NDL 的 公理 系统 和 积累 规则 . 下面 , 我们 将 扩充 NDL 的 公理 及 重新 定义 积累 规则 . 
 2   NDL 逻辑系统 的 扩展 
 2.1   扩展 的 动作 
 　 　 在 文献 ［ 7 ］ 的 NDL 框架 的 基础 上 , 结合 SET 安全 协议 的 具体内容 , 我们 在 NDL 系统 里 扩充 一个 基本 动作 : 验证 ( verify ) 和 合法性 ( legal ) . 动作 Verify 的 作用 是 , 当 参与方 收到 其他 参与方 发来 的 证书 时 , 要 通过 树状 链 结构 PKI 对 证书 的 合法性 逐级 进行 验证 , 为了 能够 更好 地 表示 这一 认证 过程 , 在 扩展 的 公理 中 引入 了 这个 动作 , 其中 x 为 动作 执行者 , Cert 为 要 验证 的 证书 , 〈 CA , X2 , ... , Xn - 1 , root 〉 为 PKI 树 的 各级 证书 授权 当局 . 动作 Legal ( CA , CerReq ) 表示 CA 验证 注册表 请求 合法性 这个 过程 , CA 是 动作 的 执行者 . 
 　 　 Verify ( x , Cert , 〈 CA1 , CA2 , ... , CARoot 〉 ) 　 　 x 沿 PKI 逐级 验证 由 CA1 发出 的 证书 Cert 的 合法 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 性 . 此 动作 仅 在 Know ( x , Spb ( CARoot ) ) 和 Know 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( x , Cert ) 同时 成立 时才 可以 做 . 
 　 　 Legal ( CA , CertReq ) 　 　 　 　 　 　 　 　 　 　 　 　 　 CA 验证 注册表 请求 的 合法性 . 
 2.2   扩展 的 谓词 
 　 　 在 文献 ［ 1 ］ 的 NDL 框架 的 基础 上 , 增加 一个 IsVerified 谓词 . 
 　 　 IsVerified ( x , CA , Cert ) 　 　 当 x 作完 动作 Verify 后 , 若 证明 证书 Cert 是 合法 的 , 则 IsVerified ( x , Cert , CA ) 的 值 为 真 , 否则 为 假 . 其 真假 值 依赖于 动作 Verify 的 成功 与否 , 即 依赖于 证书 Cert 的 合法 与否 （ 其值 不能 由 我们 决定 , 是 开放 的 ) . CA 是 发放 Cert 的 证书 授权 机构 . 
 2.3   扩展 的 公理 
 　 　 （ 1 ) 加密 公理 
 　 　 1 - 1 　 　 Know ( x , m ) ∧ Know ( x , k ) → Know ( x , E ( m , k ) ) 
 　 　 1 - 2 　 　 Know ( x , m ) ∧ Know ( x , Kpb ( y ) ) → Know ( x , S ( m , Kpb ( y ) ) ) 
 　 　 ( 2 )   密钥 分配 公理 
 　 　 2 - 1 　 　 Know ( x , Kpv ( x ) ) 
 　 　 2 - 2 　 　 Know ( x , Spv ( x ) ) 
 　 　 2 - 3 　 　 Know ( x , Spb ( x ) ) 
 　 　 2 - 4 　 　 Know ( x , Kpb ( x ) ) 
 　 　 2 - 5 　 　 Know ( x , Spb ( CARoot ) ) 
 　 　 2 - 6 　 　 Know ( x , Kpb ( CARoot ) ) 
 　 　 ( 3 )   解密 公理 
 　 　 3 - 1 　 　 Know ( x , k ) ∧ Know ( x , E ( m , k ) → Know ( x , m ) 
 　 　 3 - 2 　 　 Know ( x , Kpv ( y ) ) ∧ Know ( x , S ( m , Kpb ( y ) ) ) → Know ( x , m ) 
 　 　 ( 4 )   签名 公理 
 　 　 4 - 1 　 　 Know ( x , m ) → Know ( x , H ( m ) ) 
 　 　 4 - 2 　 　 Know ( x , m ) ∧ Know ( x , Spv ( y ) ) → Know ( x , S ( H ( m ) , Spv ( y ) ) ) 
 　 　 ( 5 )   认证 公理 
 　 　 5 - 1 　 　 Know ( x , m ) ∧ Know ( x , S ( H ( m ) , Spv ( y ) ) ) ∧ Know ( x , Spb ( y ) ) → Auth ( x , y , m ) 
 　 　 5 - 2 　 　 Know ( x , m ) ∧ Auth ( x , y , H ( m ) ) → Auth ( x , y , m ) 
 　 　 ( 6 )   分 合 公理 
 　 　 6 - 1 　 　 Know ( x , 〈 m1 , ... , mn 〉 ) Know ( x , m1 ) ∧ ... ∧ Know ( x , mn ) 
 　 　 6 - 2 　 　 Auth ( x , y , 〈 m1 , ... , mn 〉 ) → Auth ( x , y , m1 ) ∧ ... ∧ Auth ( x , y , mn ) 
 　 　 ( 7 )   PKI 公理 
 　 　 7 - 1 　 　 IsVerified ( x , CA , CertS ( y ) ) → Auth ( x , CA , 〈 y , Spb ( y ) 〉 ) 
 　 　 7 - 2 　 　 IsVerified ( x , CA , CertK ( y ) ) → Auth ( x , CA , 〈 y , Kpb ( y ) 〉 ) 
 　 　 在 这里 , CA 指 的 是 发放 CertS 或 CertK 给 y 的 那个 CA . 
 　 　 以上 公理 是 在 NDL 框架 的 基础 上 结合 SET 安全 协议 的 具体内容 对 NDL 公理 系统 的 扩充 , 在 稍后 的 范例 验证 中 我们 将会 看到 它 的 应用 . 
 2.4   规则 的 扩展 
 2.4 . 1   新增 的 规则 
 　 　 在 文献 ［ 7 ］ 中 提出 的 NDL 框架 的 基础 上 , 结合 SET 安全 协议 的 具体内容 , 我们 还 需 对 NDL 规则 系统 进行 如下 的 扩充 , 新 增加 一条 验证 规则 : 
 　 　 ( R - 7 )   PKI 验证 规则 
 Verify ( x , Cert , 〈 CA , ... , CARoot 〉 ) IsVerified ( x , CA , Cert ) 
 　 　 正如 我们 前面 所说 的 , IsVerified ( x , CA , Cert ) 成立 与否 是 依赖于 动作 Verify 的 结果 的 , 而 只有 当 ( Know   x , Cert ) 和 Know ( x , Spb ( CARoot ) ) 同时 成立 时 , 才 有 可能 做 动作 Verify , 且 此 规则 仅 适用 于 Verify 验证 成功 的 情况 . 
 2.4 . 2   积累 规则 的 扩展 
 　 　 在 文献 ［ 7 ］ 中 提到 的 积累 规则 只 适用 于 在 SET 业务 处理过程 中 , 不 更换 密钥 并且 对 消息 有 “ 记忆 “ 功能 的 情况 . 但是 , 在 实际 业务 中 , 密钥 是 允许 修改 的 , 而且 对 某些 消息 可能 没有 “ 记忆 “ 功能 , 为了 能够 满足 在 电子商务 中 可能 发生 的 各种 情况 , 在 本文 中 , 我们 扩展 了 积累 规则 . 
 　 　 在 电子商务 中 , SET 协议 最 可能 发生 改变 的 是 密钥 k , Spb ( x ) , Spv ( x ) , Kpb ( x ) , Kpv ( x ) . 对于 〈 Spv ( x ) , Spb ( x ) 〉 与 〈 Kpv ( x ) , Kpb ( x ) 〉 , 它们 分别 是 同时 产生 的 签名 密钥 对 和 数据交换 密钥 对 , 因此 , 更改 其中 的 任何 一个 , 另 一个 也 会 发生 改变 . 除了 密钥 可能 会 发生 改变 外 , 某些 消息 也 会 发生 改变 , 总的来说 大致 可以 分为 以下 3 种 情况 : 
 　 　 ( 1 )   k , 〈 Spb ( x ) , Spv ( x ) 〉 , 〈 Kpb ( x ) , Kpv ( x ) 〉 中有 改变 , 但 有 “ 记忆 ” 功能 . 
 　 　 ( 2 )   k , 〈 Spb ( x ) , Spv ( x ) 〉 , 〈 Kpb ( x ) , Kpv ( x ) 〉 都 不 改变 , 但 没有 “ 记忆 ” 功能 . 
 　 　 ( 3 )   k , 〈 Spb ( x ) , Spv ( x ) 〉 , 〈 Kpb ( x ) , Kpv ( x ) 〉 中有 改变 , 且 没有 “ 记忆 ” 功能 . 
 　 　 ( 1 ) 又 可 分为 两种 情况 . 一种 是 x 随机 产生 密钥 k , 〈 Spb ( x ) , Spv ( x ) 〉 或 〈 Kpb ( x ) , Kpv ( x ) 〉 , 但 相应 地 让 y 知道 k , Spb ( x ) 或 Kpb ( x ) . 由于 有 “ 记忆 ” 功能 , 其他 消息 仍然 存在 , 因此 , 文献 ［ 7 ］ 中 的 积累 规则 仍然 起 作用 . 另 一种 是 在 执行 过程 中 , x 自己 单方面 更改 了 密钥 , 但 没有 让 y 知道 . 这时候 , y 对 原来 密钥 的 知识 已经 “ 作废 ” , 积累 规则 不再 起 作用 . 根据 上面 两种 情况 , 可以 相应 地 得到 以下 两条 规则 . 
 　 　 ( R - 3 - 1 )   积累 规则 1 
 
 　 　 在 整个 动作 发生 的 过程 中 , x 改变 密钥 , 且 让 对方 知道 . 那么 已 证明 成立 的 结论 经过 动作 Generate ( x , newkey ) 后 仍然 成立 . 其中 newkey 为 k , Spb ( x ) , Kpb ( x ) 中 的 任何 一个 . 注意 , Spv ( x ) 和 Kpv ( x ) 不能 让 y 知道 . 
 　 　 ( R - 3 - 2 )   积累 规则 2 
 
 　 　 x 改变 了 密钥 , 但 没 让 y 知道 , 那么 原来 成立 的 结论 Q , 现在 可以 非 单调 地说 , 经过 动作 Generate ( x , newkey ) 后 , Q 不 成立 . 
 　 　 ( 2 ) 是 密钥 没有 改变 , 但是 实体 在 整个 协议 执行 过程 中 对 某些 消息 没有 “ 记忆 ” 功能 . 
 　 　 ( R - 3 - 3 )   积累 规则 3 
 
 　 　 m ′ 为 几个 消息 的 集合 , 即 〈 m1 , m2 , ... , mn 〉 . x 随机 产生 新 消息 m , 且 m 与 原来 产生 的 消息 m ′ 一致 , 没有 发生变化 , 则 经过 动作 Generate ( x , m ) 后 , Q 仍然 成立 . 
 　 　 ( R - 3 - 4 )   积累 规则 4 
 
 　 　 x 产生 新 消息 m , 但是 m 与 原来 产生 的 消息 m ′ 不 一致 , 已经 发生 了 变化 . 那么 可以 非 单调 地说 , 经过 动作 Generate ( x , m ) 后 , Q 不 成立 . 
 　 　 ( 3 ) 是 密钥 改变 , 且 实体 在 协议 执行 过程 中 对 消息 没有 记忆 功能 . 它 可以 分为 以下 4 种 情况 : 
 　 　 ( R - 3 - 5 )   积累 规则 5 
 
 　 　 在 协议 执行 过程 中 , x 改变 密钥 , 且 让 y 知道 发生 改变 的 密钥 . 同时 , x 新 产生 的 消息 m 与 原来 的 消息 m ′ 保持一致 , 则 经过 动作 Generate ( x , newkey ) 。 Generate ( x , m ) 后 , Q 仍然 成立 . 
 　 　 ( R - 3 - 6 )   积累 规则 6 
 
 　 　 在 协议 执行 过程 中 , x 改变 密钥 , 且 让 y 知道 发生 改变 的 密钥 . 但是 , x 新 产生 的 消息 m 与 原来 的 消息 m ′ 不 一致 , 则 可以 非 单调 地说 , 经过 动作 Generate ( x , newkey ) 。 Generate ( x , m ) 后 , Q 不 成立 . 
 　 　 ( R - 3 - 7 )   积累 规则 7 
 
 　 　 在 协议 执行 过程 中 , x 改变 密钥 , 但是 不让 y 知道 . x 新 产生 的 消息 m 与 原来 的 消息 m ′ 保持一致 , 则 可以 非 单调 地说 , 经过 动作 Generate ( x , newkey ) 。 Generate ( x , m ) 后 , Q 不 成立 . 
 　 　 ( R - 3 - 8 )   积累 规则 8 
 
 　 　 在 协议 执行 过程 中 , x 改变 密钥 , 但 不让 y 知道 . 且 x 新 产生 的 消息 m 与 原来 的 消息 m ′ 不 一致 , 则 可以 非 单调 地说 , 经过 动作 Generate ( x , newkey ) 。 Generate ( x , m ) 后 , Q 不 成立 . 
 　 　 扩展 后 的 积累 规则 , 综合 考虑 了 电子商务 中 可能 出现 的 各种 意外 情况 . 但 必须 指出 , 对于 规则 中 的 一些 符号 的 描述 仍然 存在 一些 问题 , 像 密钥 的 表示 符号 , 只要 对象 x 被 指定 后 , 它 似乎 不再 发生 改变 , 实际上 它 随着 时间 的 变化 也 在 不断 地 改变 . 因此 , 如果 要 使 规则 的 定义 更加 准确 , 必须 对 现有 的 符号 系统 进行 改进 , 对此 我们 将 另文 讨论 . 
 3   SET 协议 验证 示例 
 3.1   SET 协议 的 片段 的 验证 示例 
 　 　 下面 , 我们 将 用 “ 持卡人 注册 ” 和 “ 商家 注册 ” 阶段 中 的 两个 例子 来 说明 扩展 后 的 NDL 逻辑 框架 在 SET 协议 验证 上 的 应用 . 
 　 　 例 1 : 已知 
 　 　 P = { Know ( C , Spb ( CARoot ) ) , Know ( C , Kpb ( CARoot ) ) } , 
 　 　 α = Generate ( CA , InitRes ) 。 Send ( CA , C , Sign ( CA , InitRes ) )  
 　 　 　 　 Send ( CA , C , CertS ( CA ) ) 。 Send ( CA , C , CertK ( CA ) )  
 　 　 　 　 Verify ( C , CertS ( CA ) , 〈 X2 , ... , Xn - 1 , root 〉 )  
 　 　 　 　 Verify ( C , CertK ( CA ) , 〈 X2 , ... , Xn - 1 , root 〉 ) , 
 　 　 Q = { Auth ( C , X2 , 〈 CA , Spb ( CA ) 〉 ) ; Auth ( C , X2 , 〈 CA , Kpb ( CA ) 〉 ) } . 
 　 　 求证 : P α Q 
 　 　 证明 : 
 　 　 ( 1 ) 　 　 　 　 Know ( C , Spb ( CARoot ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 2 ) 　 　 　 　 Know ( C , Kpb ( CARoot ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 3 )   Generate ( CA , InitRes ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 4 ) 　 　 　 　 Know ( CA , InitRes ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 3 ) ［ R - 2 ］ 
 　 　 ( 5 ) 　 　 　 　 Know ( CA , Spv ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 2 - 2 ］ 
 　 　 ( 6 ) 　 　 　 　 Know ( CA , S ( H ( InitRes ) , Spv ( CA ) ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 4 ) ( 5 ) ［ 4 - 2 ］ 
 　 　 ( 7 ) 　 　 　 　 Know ( CA , 〈 InitRes , S ( H ( InitRes ) , Spv ( CA ) ) 〉 ) 　 　 　 　 　 　 　 ( 4 ) ( 6 ) ［ 6 - 1 ］ 
 　 　 ( 8 ) 　 　 　 　 Know ( CA , Sign ( CA , InitRes ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 7 ) ［ 定义 ］ 
 　 　 ( 9 )   Send ( CA , C , Sign ( CA , InitRes ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 10 )   Send ( CA , C , CertS ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 11 )   Send ( CA , C , CertK ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 12 ) 　 　 　 　 Know ( C , Sign ( CA , InitRes ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 9 ) ［ R - 1 ］ 
 　 　 ( 13 ) 　 　 　 　 Know ( C , CertS ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 10 ) ［ R - 1 ］ 
 　 　 ( 14 ) 　 　 　 　 Know ( C , CertK ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 11 ) ［ R - 1 ］ 
 　 　 ( 15 )   Verify ( C , CertS ( CA ) , 〈 X2 , ... , Xn - 1 , CARoot 〉 ) 　 　 　 　 　 　 　 　 　 ( 1 ) ( 13 ) ［ 动作 ］ 
 　 　 　 　 　 　 　 　 / * 如果 检验 失败 , C 没有 在 PKI 树中 找到 root , 则 持卡人 停止 注册 . * / 
 　 　 ( 16 ) 　 　 　 　 IsVerified ( C , X2 , CertS ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 15 ) ［ R - 6 ］ 
 　 　 ( 17 ) 　 　 　 　 Auth ( C , X2 , 〈 CA , Spb ( CA ) 〉 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 16 ) ［ 7 - 1 ］ 
 　 　 ( 18 )   Verify ( C , CertS ( CA ) , 〈 X2 , ... , Xn - 1 , CARoot 〉 ) 　 　 　 　 　 　 　 　 　 ( 1 ) ( 14 ) ［ 动作 ］ 
 　 　 　 　 　 　 　 　 / * 如果 检验 失败 , C 没有 在 PKI 树中 找到 root , 则 持卡人 停止 注册 . * / 
 　 　 ( 19 ) 　 　 　 　 IsVerified ( C , X2 , CertK ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 18 ) ［ R - 6 ］ 
 　 　 ( 20 ) 　 　 　 　 Auth ( C , X2 , 〈 CA , Kpb ( CA ) 〉 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 19 ) ［ 7 - 1 ］ 
 　 　 　 　 　 　 　 　 / * CA , X2 , ... , Xn - 1 , CARoot 为 PKI 树 的 各级 证书 授权 当局 . * / 
 　 　 式 ( 18 ) 和 ( 20 ) 即 所要 证明 的 结果 . 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 □ 
 　 　 例 2 : 已知 
 　 　 P = { Know ( M , Acct ( M ) ) , Know ( M , Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) ) , Know ( CA , Spb ( M ) ) , Know ( M , Kpb ( CA ) ) } , 
 　 　 α = Generate ( M , k1 ) 。 Send ( M , CA , E ( Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) , k1 ) )  
 　 　 　 　 Send ( M , CA , S ( 〈 Acct ( M ) , k1 〉 , Kpb ( CA ) ) ) 。 Legal ( CA , CerReq ) , 
 　 　 Q = { Auth ( CA , M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) } . 
 　 　 求证 : P α Q 
 　 　 证明 : 
 　 　 ( 1 ) 　 　 　 　 Know ( M , Acct ( M ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 2 ) 　 　 　 　 Know ( M , Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) ) 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 3 ) 　 　 　 　 Know ( CA , Spb ( M ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 4 )   Generate ( M , k1 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 5 ) 　 　 　 　 Know ( M , k1 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 4 ) ［ R - 2 ］ 
 　 　 ( 6 ) 　 　 　 　 Know ( M , E ( Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) , k1 ) ) 　 　 　 　 ( 2 ) ( 5 ) ［ 1 - 1 ］ 
 　 　 ( 7 ) 　 　 　 　 Know ( M , 〈 Acct ( M ) , k1 〉 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 1 ) ( 5 ) ［ 6 - 1 ］ 
 　 　 ( 8 ) 　 　 　 　 Know ( M , Kpb ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 前提 ］ 
 　 　 ( 9 ) 　 　 　 　 Know ( M , S ( 〈 Acct ( M ) , k1 〉 , Kpb ( CA ) ) ) 　 　 　 　 　 　 　 　 　 　 　 ( 7 ) ( 8 ) ［ 1 - 2 ］ 
 　 　 ( 10 )   Send ( M , CA , E ( Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) , k1 ) ) 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 11 )   Send ( M , CA , S ( 〈 Acct ( M ) , k1 〉 , Kpb ( CA ) ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 ( 12 ) 　 　 　 　 Know ( CA , E ( Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) , k1 ) ) 　 　 　 　 ( 10 ) ［ R - 1 ］ 
 　 　 ( 13 ) 　 　 　 　 Know ( CA , S ( 〈 Acct ( M ) , k1 〉 , Kpb ( CA ) ) ) 　 　 　 　 　 　 　 　 　 　 　 ( 11 ) ［ R - 1 ］ 
 　 　 ( 14 ) 　 　 　 　 Know ( CA , Kpv ( CA ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 2 - 1 ］ 
 　 　 ( 15 ) 　 　 　 　 Know ( CA , 〈 Acct ( M ) , k1 〉 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 13 ) ( 14 ) ［ 3 - 2 ］ 
 　 　 ( 16 ) 　 　 　 　 Know ( CA , Acct ( M ) ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 15 ) ［ 6 - 1 ］ 
 　 　 ( 17 ) 　 　 　 　 Know ( CA , k1 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 15 ) ［ 6 - 1 ］ 
 　 　 ( 18 ) 　 　 　 　 Know ( CA , Sign ( M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) ) 　 　 　 　 　 ( 12 ) ( 17 ) ［ 3 - 1 ］ 
 　 　 ( 19 ) 　 　 　 　 Auth ( CA , M , 〈 CertReq , Spb ( M ) , Kpb ( M ) 〉 ) 　 　 　 　 　 　 　 　 ( 3 ) ( 16 ) ［ 定理 2 ］ 
 　 　 ( 20 ) 　 　 　 　 Know ( CA , CertReq ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ( 18 ) ［ 定义 ］ 
 　 　 ( 21 )   Legal ( CA , CerReq ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 ［ 动作 ］ 
 　 　 　 　 　 　 　 　 / * CA 用 已知 的 商家 的 信息 检验 CertReq 中 的 注册表 的 合法性 . * / 
 　 　 ( 19 ) 式 即 为 所要 证明 的 结果 . 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 □ 
 　 　 第 1 个 例子 属于 “ 持卡人 注册 ” 阶段 , 第 2 个 例子 属于 “ 商家 注册 ” 阶段 . 在 第 1 个 范例 证明 中 , 都 使用 了 动作 Verify ( x , Cert , 〈 CA , X2 , ... , Xn - 1 , root 〉 ) , 因为 接收 方在 验证 发送 方 传给 自己 的 证书 时 , 要 通过 树状 链 结构 PKI 对 证书 的 合法性 逐级 进行 验证 , 为了 能够 更好 地 表示 这一 认证 过程 , 在 扩展 的 公理 中 引入 了 这个 动作 , 其中 x 为 动作 执行者 , Cert 为 要 验证 的 证书 , 〈 CA , X2 , ... , Xn - 1 , root 〉 为 PKI 树 的 各级 证书 授权 当局 . 动作 Legal ( CA , CerReq ) 表示 CA 验证 注册表 请求 合法性 这个 过程 , CA 是 动作 的 执行者 . 从 上面 3 个 范例 的 验证 可以 看出 , 不 引入 这些 符号 , 要 表示 这 两个 动作 是 非常 困难 的 事 , 而用 简洁 的 符号 来 表示 这些 复杂 且 难以描述 的 动作 , 就 使 人 很 容易 理解 . 
 3.2   验证 逻辑 的 Prolog 程序实现 
 　 　 由于 逻辑 推导 所 涉及 的 东西 大多 是 符号 和 规则 , 此 推理 过程 若要 由 人来 完成 , 则 无论 在 人力 上 , 还是 在 时间 上 均 是 一个 极大 的 浪费 . 但 逻辑推理 具有 易 在 机器 上 验证 的 特点 , 因此 我们 编制 了 基于 NDL 逻辑 框架 的 Prolog “ 安全 协议 验证 系统 ” , 其 规则 系统 即为 NDL 的 公理 和 规则 , 用户 可以 根据 增加 的 需要 输入 前提 , 来 达到 验证 安全 协议 是否 存在 漏洞 的 目的 . 
 4   结束语 
 　 　 上面 介绍 了 SET 协议 的 付费 业务流程 , 对 NDL 的 公理 系统 和 积累 规则 进行 了 扩展 , 并用 3 个 例子 的 验证 来 说明 NDL 在 验证 安全 协议 上 的 应用 . 可以 看出 , 扩展 后 的 NDL 逻辑 框架 能 对 相当 大 一部分 安全 协议 的 安全性 进行 验证 , 对于 每种 安全 协议 , 只要 在 现有 的 逻辑系统 的 基础 上 稍加 扩充 , 就 可以 用来 对 很多 问题 进行 证明 . 
 　 　 但是 应该 看到 , 对于 如何 用 符号 准确 地 表示 密钥 和 消息 的 变化 , 需要 我们 做 进一步 的 研究 . 本文 主要 介绍 SET 协议 的 内容 和 NDL 逻辑 框架 的 扩展 . 只是 用 SET 中 几个 简单 的 例子 说明 了 NDL 的 应用 , 并 没有 给出 SET 付费 业务流程 的 完整 的 验证 过程 , 对此 也 需要 另文 进行 研究 . 
 　 　 在 上面 3 个 例子 的 证明 过程 中 , 我们 已经 发现 了 SET 协议 中 可能 存在 的 一些 问题 , 在 对 SET 进行 全面 的 验证 之后 , 我们 将会 指出 SET 中 的 一些 漏洞 , 并 探讨 它 的 解决 方法 . ■ 
 基金项目 ： 本文 研究 得到 国家 863 高科技 项目 基金 ( No.863 - 306 - ZD - 10 - 02 ) 资助 . 
 作者简介 ： 陈庆锋 , 1971 年生 , 助理 工程师 , 主要 研究 领域 这 信息安全 , 电子商务 . 
 　 　 　 　 　 白硕 , 1956 年生 , 博士 , 研究员 , 博士生 导师 , 主要 研究 领域 为 人工智能 , 计算机 语言 
 　 　 　 　 　 学 , Internet / Intranet 应用软件 . 
 　 　 　 　 　 王驹 , 1950 年生 , 博士 , 研究员 , 主要 研究 领域 为 数理逻辑 , 计算机 理论 . 
 　 　 　 　 　 张师超 , 1962 年生 , 博士 , 教授 , 主要 研究 领域 为 人工智能 , 数据库 技术 . 
 　 　 　 　 　 隋立颖 , 女 , 1973 年生 , 硕士 , 主要 研究 领域 为 Internet / Intranet 应用软件 , 计算机 理 
 　 　 　 　 　 论 . 
 作者 单位 ： 陈庆锋 ( 国家 智能 计算机 研究 开发 中心 　 北京 　 100080 ) 
 　 　 　 　 　 陈庆锋 ( 广西师范大学 数学 与 计算机科学 系 　 桂林 　 541004 ) 
 　 　 　 　 　 白硕 ( 国家 智能 计算机 研究 开发 中心 　 北京 　 100080 ) 
 　 　 　 　 　 王驹 ( 中国科学院 软件 研究所   北京 　 100080 ) 
 　 　 　 　 　 　 张师超 ( 广西师范大学 数学 与 计算机科学 系 　 桂林 　 541004 ) 
 　 　 　 　 　 　 隋立颖 ( 国家 智能 计算机 研究 开发 中心 　 北京 　 100080 ) 
 参考文献 ： 
 ［ 1 ］ SET   Secure   Electronic   Transaction   Specification . Book   1 : Business   Description   Version   1.0 . May   31 , 1997 
 ［ 2 ］ SET   Secure   Electronic   Transaction   Specification . Book   2 : Programmer ' s   Guide   Version   1.0 . May   31 , 1997 
 ［ 3 ］ Burrows   M , Abadi   M , Needham   R . A   logic   of   authentication . ACM   Transactions   on   Computer   System , 1990 , 8 ( 1 ) : 18 ～ 36 
 ［ 4 ］ Abadi   M , Tuttle   M . A   semantics   for   a   logic   of   authentication . In : Proceedings   of   the   10th   Annual   ACM   Symposium   on   Principles   of   Distributed   Computing . Montreal : ACM   Press , 1991.201 ～ 216 
 ［ 5 ］ Kessler   V , Wedel   C . AUTLOG — — an   advanced   logic   of   authentication . In : Wernered   B   ed . Proceedings   of   the   7th   IEEE   Computer   Security   Foundations   Workshop . Los   Alamitors , CA : IEEE   Computer   Society   Press , 1994.90 ～ 99 
 ［ 6 ］ Kailar   R . Accountability   in   electronic   commerce   protocols . Proceedings   of   the   IEEE   Transactions   on   Software   Engineering , 1996 , 22 ( 5 ) : 313 ～ 328 
 ［ 7 ］ Bai   Shuo , Sui   Li - ying , Chen   Qing - feng   et   al . Authentication   logic   for   secure   protocols . Journal   of   Software , 2000 , 11 ( 2 ) : 213 ～ 221 
 （ 白硕 , 隋立颖 , 陈庆锋 等 . 安全 协议 的 验证 逻辑 . 软件 学报 , 2000 , 11 ( 2 ) : 213 ～ 221 ) 
 收稿 日期 ： 2998 - 04 - 03 
 修稿 日期 ： 1999 - 03 - 22 
