软件 学报 
 JOURN   AL   OF   SOFTWARE 
 1999 年 　 第 10 卷 　 第 10 期 　 Vol.10 　 No.10 　 1999 
 
 
 
 关联 规则 的 开采 与 更新   
 周 海岩 
 摘要 　 对 关联 规则 的 增量 式 更新 算法 — — IUA ( incremental   updating   algorithm ) 进行 了 分析 , 指出 其 存在 的 问题 , 并 给出 一个 改进 的 算法 NEWIUA ( new   IUA ) . NEWIUA 算法 对 已 存在 的 和 本次 更新 时新 产生 的 频繁 项目 集都 加以 充分 的 利用 , 因此 , 在 保证 算法 有效 的 同时 提高 了 效率 . 文章 提出 了 3 种 关联 规则 开采 的 并行算法 , 并 对 各 算法 进行 了 分析 和 讨论 . 
 关键词 　 数据 开采 , 关联 规则 , 增量 式 更新 , 频繁 项目 集 , 并行算法 . 
 中图法 分类号 　 TP311 
 Data   Mining   and   Incremental   Updating   on   Association   Rules 
 ZHOU   Hai - yan 
 ( Taiyuan   Teachers '   College   Taiyuan   030001 ) 
 Abstract 　 In   this   paper ,   the   author   analyzes   the   incremental   updating   algorithm   ( IUA )   on   association   rules ,   points   out   its   existing   problems ,   and   presents   an   improved   algorithm ,   NEWIUA   ( new   IUA ) ,   which   takes   full   use   of   already   existing   and   the   current   updated   new   frequent   itemsets ,   therefore   the   efficiency   is   increased   besides   guaranteeing   the   validity   of   the   algorithm .   Three   parallel   algorithms   for   data   mining   on   association   rules   are   presented ,   the   analysis   and   discussion   on   each   algorithm   are   also   presented . 
 Key   words 　 Data   mining ,   association   rules ,   incremental   updating ,   frequent   itemsets ,   parallel   algorithm . 
 　 　 数据 开采 ( data   mining ) 是 数据库 中 的 知识 发现 KDD ( knowledge   discovery   in   databases ) 的 核心 步骤 , 是 一种 从 大规模 数据库 或 数据仓库 中 提取 隐藏 的 预测性 信息 的 新 方法 . 此 方法 的 提出 让 人们 有 能力 最终 认识 数据 的 真正 价值 , 即 数据 中 潜在 的 可用 信息 和 知识 . 数据 开采 是 目前 在 国际 上 数据库 、 数据仓库 和 信息 决策 领域 最前沿 的 方向 之一 , 引起 了 国内外 学术界 和 工商业界 的 广泛 关注 . 国际 上 许多 研究 机构 和 实验室 都 在 这个 领域 开展 了 各种各样 的 研究 . 研究 的 主要 目标 是 发展 有关 的 方法论 、 理论 工具 , 以 支持 从 大量 数据 中 提取 有用 的 和 让 人 感兴趣 的 知识 、 模式 和 规则 . 
 　 　 在 数据 开采 的 研究 领域 , 对于 关联 规则 开采 的 研究 开展 得 比较 积极 和 深入 . 关于 关联 规则 开采 的 一般 对象 、 主要 应用领域 及 关联 规则 在 实际 问题 中 的 含义 在 文献 [ 1 ~ 3 ] 中均 有 详细 叙述 , 在 此 不再 重述 . 本文 第 1 节 给出 了 问题 的 详细描述 . 第 2 节 指出 了 IUA ( incremental   updating   algorithm ) 算法 存在 的 问题 , 对 IUA 算法 的 效率 进行 了 分析 , 并 给出 了 一种 改进 算法 . 第 3 节 提出 了 3 种 关联 规则 开采 的 并行算法 , 并 进行 了 相应 的 分析 与 讨论 . 第 4 节 作出 总结 . 
 1 　 问题 描述 
 　 　 为了 使 行文 方便 和 完整 , 将 关联 规则 开采 问题 的 形式化 描述 如下 [ 1 , 2 ] . 
 　 　 设 I = { i1 , i2 , ... , im } 是 m 个 不同 项目 的 集合 , 给定 一个 事务 数据库 D , 其中 每 一个 交易 T 是 I 中 一些 项目 的 集合 , 即 T ì   I . 每 一个 交易 T 都 与 一个 唯一 的 标识符 TID 相联 . 如果 对于 I 中 的 一个 子集 X , 有 X   T , 我们 就 说 一个 交易 T 包含 X . 一条 关联 规则 ( association   rule ) 就是 一个 形如 X   Y 的 蕴涵 式 , 其中 X , YI , 而且 X ∩ Y = φ . X 称作 规则 的 前提 , Y 是 结果 . 
 　 　 一般 把 一些 项目 的 集合 称作 项目 集 . 在 一个 项目 集中 所 含 项目 的 个数 称为 该 项目 集 的 长度 , 即 X 为 项目 集 , X 的 长度 │ X │ = X 中 项目 的 个数 . 对于 XI , 如果 D 中 包含 X 的 交易 数目 为 s , 则 称 s 为 X 的 支持 度 . 若用 Support ( X ) 表示 X 的 支持 度 , 则 Support ( X ) = s . 关联 规则 X   Y 的 支持 度 定义 为 Support ( X   Y ) = Support ( X ∪ Y ) , 而 一个 关联 规则 也 有 其 衡量标准 , 称其为 “ 置信度 ” ( confidence ) , 定义 为 Confidence ( XY ) = Support ( X ∪ Y ) / Support ( X ) . 关联 规则 的 开采 问题 就是 在 D 中 筛选 出 所有 具有 用户 指定 的 最小 支持 度 和 最小 可信度 的 关联 规则 , 即 这些 关联 规则 的 支持 度 和 可信度 分别 不 小于 最小 支持 度 和 最小 可信度 . 
 　 　 关联 规则 的 开采 问题 可以 分解 为 以下 两个 子 问题 : 
 　 　 ①   筛选 出 事务 数据库 D 中 所有 具有 用户 指定 的 最小 支持 度 的 项目 集 ( itemset , I 的 非 空子 集 ) . 具有 最小 支持 度 的 项目 集 称为 频繁 项目 集 , 反之 就 称为 非 频繁 项目 集 . 
 　 　 ②   利用 频繁 项目 集 生成 所有 的 关联 规则 . 对 每 一个 频繁 项目 集 A , 找出 A 的 所有 非 空子 集 a , 如果 比率 Support ( A ) / support ( a ) > minconf , 就 生成 关联 规则 a ( A - a ) . 其中 minconf 为 用户 指定 的 最小 可信度 . 
 　 　 由于 子 问题 ② 相对来说 较为 容易 , 因而 目前 研究 的 重点 集中 在 第 ① 个子 问题 上 . 
 2 　 关于 关联 规则 的 增量 式 更新 算法 
 　 　 在 关联 规则 开采 的 过程 中 , 为了 发现 事先 未知 的 关联 规则 , 用户 必然 需要 通过 对 最小 支持 度 和 最小 可信度 这 两个 阈值 的 不断 调整 来 逐步 聚焦 到 那些 真正 令其 感兴趣 的 关联 规则 上去 , 这 将 是 一个 动态 的 交互 过程 . 因此 , 迫切需要 高效 的 更新 算法 来 满足用户 对 较 快 的 响应 时间 的 需求 . 
 　 　 传统 的 关联 规则 的 更新 问题 考虑 的 是 , 当 基础 数据库 或 数据仓库 中 数据 发生变化 时 , 如何 高效 地 进行 规则 更新 而 勿需 从头做起 , 而 本文 及 文献 [ 1 ] 所 考虑 的 是 数据库 D 中 数据 保持 不变 , 当 用户 所 给定 的 阈值 ( 主要 指 支持 度 ) 改变 时 关联 规则 的 更新 问题 . 
 　 　 由于 篇幅 所 限 , 在 此 对 关联 规则 增量 式 更新 算法 IUA 不作 详细 介绍 , 详情 见 文献 [ 1 ] , 并且 下文 中 所用 符号 及其 含义 除非 特别 说明 , 均 与 文献 [ 1 ] 相同 . 
 2.1   IUA 算法 存在 的 问题 
 　 　 IUA 算法 与 Apriori 算法 ( 见 文献 [ 3 ] ) 的 主要 区别 在于 iua _ gen 函数 , 但是 在 iua _ gen 函数 的 第 2 步 修剪 中 , 会 将 Ck3 中 由 L1 中 的 k -   1 个 项目 与 L1 ＂   中 的 一个 项目 所 构成 的 k - 项目 集 和 由 L1 ＂ 中 的 一个 项目 与 L12   中 的 k -   1 个 项目 所 构成 的 k - 项目 集 全部 修剪 掉 . 这样 导致 关联 规则 在 更新 时会 使 一些 频繁 项目 集 以及 一些 有效 规则 开采 不 出来 . 
 　 　 例 : 设 数据库 D 有 4 次 交易 为 T1 = { A , B , C } , T2 = { A , B , D } , T3 = { A , D , E } , T4 = { A , B , C , D } . 设旧 的 最小 支持 度 s = 3 , 与 之 对应 的 所有 频繁 k - 项目 集 ( 即 长度 为 k 的 频繁 项目 集 ) 所 构成 的 集合 记为 Lk ( k = 1 , 2 , ... , m1 ) , 这里 m1 为 所有 频繁 项目 集中 的 最大 长度 , 于是 L1 = { { A } , { B } , { D } } , L2 = { { AB } , { AD } } , 此时 m1 = 2 . 
 　 　 设新 的 最小 支持 度 s ￠   = 2 . 用 IUA 算法 来 进行 关联 规则 更新 得 : 
 　 　 L1 = { { A } , { B } , { D } } ,   L1 ＂   = { { C } } ,   L11 = L1 ,   L12 = L1 ＂ ,   L13 = φ   ,   L1 ＇   = L1 ∪ L1 ＂   ,   C21 = apriori _ gen ( Lk - 11 ) - Lk = apriori _ gen ( L11 ) -   L2 = { { BD } } ( 此处 k = 2 ) , C22 = apriori _ gen ( L12 ) = φ . 
 　 　 执行 iua _ gen 函数 来求 C23 , 执行 iua _ gen 函数 的 第 1 步 拼接 得 C23 = { { AC } , { BC } , { DC } } , 执行 iua _ gen 函数 的 第 2 步 修剪 , 取 { AC } ∈ C23 , 因为 { A } 是 { AC } 的 k - 1 = 1 个 元素 的 子集 , 但 { A } ∈ L13 = φ , 则 { AC } 在 C23 中 被 删除 , 同样 地 , { BC } , { CD } 通过 iua _ gen 函数 的 修剪 都 将 在 C23 中 被 删除 , 最后 得 C23 = φ   . 于是 得 L20 = { { BD } } , 从而 L21 = L20 ∪ L2 = { { AB } , { AD } , { BD } } , 因为 C22 = φ   , C23 = φ   , 则 L22 = , L23 = φ   , 从而 得 L2 ＇ = L21 ∪ L22 ∪ L23 = { { AB } , { AD } ,   { BD } } , C31 = apriori _ gen ( L21 ) -   L3 = { { ABD } } ( L3 = φ ) , C32 = apriori _ gen ( L22 ) = φ   ( 因为 L22 = φ   ) . 
 　 　 执行 iua _ gen 函数 第 1 步 拼接 得 C33 = { { ABC } , { ADC } , { BCD } } , 经 iua _ gen 函数 的 修剪 最后 得 C33 = φ   ( 因为 L23 = φ   , 任取 c ∈ C33 , 则 c 的 任意 一个 有 两个 项目 的 子集 c ＇   均 有 c ＇ L23 故应 在 C33 中将 c 删除 ) , 于是 得 L30 = { { ABD } } . 从而 L31 = L30 ∪ L3 = { { ABD } } , L32 = φ   ( 因为 C32 = φ   ) , L33 = φ   ( C33 = φ   ) , 所以 L3 ＇   = L31 ∪ L32 ∪ L33 = L31 =   { { ABD } } . 
 　 　 这样 , 由 IUA 算法 所 得到 的 数据库 D 在 最小 支持 度 s ＇ = 2 下 的 所有 频繁 项目 集 为 { { A } , { B } , { C } , { D } , { AB } ,   { AD } , { BD } , { ABD } } , 而 实际上 数据库 D 在 最小 支持 度 s ＇ = 2 下 的 所有 频繁 项目 集 为 { { A } , { B } , { C } , { D } , { AB } ,   { AC } , { AD } , { BC } , { BD } , { ABD } , { ABC } } , IUA 算法 没有 把 频繁 项目 集 { AC } , { BC } 及 { ABC } 开采 出来 . 
 　 　 由上 例知 , IUA 算法 不能 将 大量 的 频繁 项目 集 以及 许多 有效 规则 开采 出来 . 故此 算法 不是 关联 规则 的 增量 式 更新 的 有效 算法 . 
 2.2   IUA 算法 效率 分析 
 　 　 基本 性质 1 .   一个 频繁 项目 集 的 任一 非 空子 集 必定 也 是 频繁 项目 集 . 
 　 　 ①   IUA 算法 与 Apriori 算法 一样 主要 利用 了 上述 基本 性质 1 . 根据 这一 基本 性质 可知 , 对于 任一 项目 i , 如果 i 不是 任一 j ( j < k ) 项目 集 的 元素 , 则 i 一定 不是 k - 项目 集 的 元素 , 而 在 IUA 算法 的 第 ⑥ ～ ⑧ 步 ( 见 文献 [ 1 ] ) 的 循环 中 , 每 调用 一次 iua _ gen 函数 , 通过 该 函数 的 拼接 将会 使 一些 已 明显 不是 频繁 k - 项目 集 的 k - 项目 集 成为 候选 k - 项目 集 Ck3 中 的 元素 , 从而 给 iua _ gen 函数 中 的 修剪 增加 运算量 , 因此 增加 了 算法 的 时间 复杂性 . 
 　 　 ②   IUA 算法 在 关联 规则 更新 时 , 对 k - 项目 集 的 开采 , 只是 注意 到 利用 已 存在 的 频繁 k - 项目 集 的 集合 Lk , 没有 注意 基于 基本 性质 1 在 本次 更新 时 , 对 新 产生 的 频繁 ( k -   1 ) - 项目 集 的 集合 Lk -   1 ￠   加以 利用 . 这 在 IUA 算法 中 对 Ck3 的 产生 以及 由 Ck3 来 确定 Lk3 完全 能够 体现 这 一点 . 另一方面 , 由 以上 对 IUA 算法 的 分析 及 iua _ gen 函数 存在 的 问题 , 于是 PIUA 算法 也 将 失去 其 意义 . 
 　 　 基于 上述 对 IUA 算法 的 分析 和 讨论 , 下面 给出 IUA 算法 的 改进 算法 . 
 2.3   增量 式 更新 算法 NEWIUA   
 　 　 给定 事务 数据库 D , 一个 项目 集 的 支持 度 可以 认为 就是 所有 包含 该 项目 集 的 交易 的 数目 . 设旧 的 最小 支持 度为 s , Lk 为 数据库 D 在 最小 支持 度 s 下 对应 的 长度 为 k 的 所有 频繁 项目 集所 构成 的 集合 , k = 1 , 2 , ... , m1 , 此处 m1 为 所有 频繁 项目 集 的 最大 长度 . 对于 新 的 最小 支持 度 s ＇   , 设 Lk ＇ 为 对应 的 所有 频繁 k - 项目 集 的 集合 , k = 1 , 2 , ... , m2 , 同样 地 , m2 为 所有 具有 最小 支持 度 s ' 的 频繁 项目 集 的 最大 长度 . 对于 每 一个 项目 集都 有 一个 域 count 用来 保存 它 的 支持 度 计数 . 
 　 　 当 最小 支持 度 发生变化 时 , 只有 两种 情况 : ①   s ＇   > s , ②   s ＇   < s . 对于 情况 ① , 文献 [ 1 ] 中 已 得到 较 完美 的 处理 , 故 NEWIUA 算法 只 对 情况 ② 作出 处理 . 
 　 　 　 NEWIUA 算法 的 基本 框架 与 IUA 算法 和 Apriori 算法 一致 , 对 k = 1 , 2 , ... , m2 , 采用 某种 策略 来 生成 候选 k - 项目 集 的 集合 Ck , 然后 扫描 数据库 来 确定 Ck 中 哪些 k - 项目 集是 频繁 项目 集 . 
 　 　 NEWIUA 算法 与 传统 的 增量 式 更新 算法 不同之处 主要 体现 在 以下 两点 . 
 　 　 ①   因为 有 s ＇ < s , 所以 , 原来 所有 在 旧 的 最小 支持 度 s 下 的 频繁 k - 项目 集在 新 的 最小 支持 度 s ＇   下 仍 是 频繁 k - 项目 集 , 因此 在 每 一趟 扫描 数据库 D 计算 候选 k - 项目 集 的 支持 度 计数 时 , 就 没有 必要 对 Lk 中 的 项目 集 重新 再 计算 一次 . 因此 NEWIUA 算法 在 生成 候选 k - 项目 集 的 集合 Ck 时不含 Lk 中 的 项目 集 , 这 在 下列 NEWIUA 算法 的 基本 框架 描述 中 的 第 ( 1 ) 步 、 第 ( 8 ) 步 和 第 ( 8 ) ＇ 步中 能够 体现 这 一点 . 
 　 　 ②   NEWIUA 算法 在 生成 候选 k - 项目 集 的 集合 Ck 时 , 不但 利用 了 已 存在 的 频繁 k - 项目 集 的 集合 Lk , 而且 注意 到 , 基于 基本 性质 1 对 本次 更新 时新 产生 的 频繁 ( k -   1 ) - 项目 集 的 集合 Lk -   1 ＇   加以 充分利用 . 这 一点 由 NEWIUA 算法 中 的 第 ( 9 ) ～ ( 12 ) 步来 体现 . 
 　 　 IUA 算法 的 改进 算法 — — NEWIUA 算法 的 基本 框架 描述 如下 . 
 　 　 记 Lk ＂ = Lk ＇   -   Lk , Ck 为 所有 候选 k - 项目 集所 构成 的 集合 . 
 　 　 NEWIUA 算法 ( s ＇   < s ) . 
 　 　 ( 1 )   C1 = { all   1 - itemsets   c   of   I } -   L1 
 　 　 ( 2 )   for   all   transactions   t ∈ D   do   begin 
 　 　 ( 3 )   Ct = subset ( C1 , t ) ;   　 　 / *   C1 中 包含 于 交易 t 的 候选 1 - 项目 集 构成 Ct   * / 
 　 　 ( 4 )   for   all   candidates   c ∈ Ct   do 
 　 　 　 　 　 　 c . count ++ ;   　 　 　 / *   Ct 中 候选 1 - 项目 集 的 支持 度 记数 加 1   * / 
 　 　 ( 5 )   end   
 　 　 ( 6 )   L10 = { c ∈ C1 │ c . count3   s ＇   } ;   L1 ＇   = L10 ∪ L1 
 　 　 ( 7 )   for   ( k = 2 ;   Lk -   1 ＇   ≠ φ   ;   k ++ )   do   begin 
 　 　 ( 8 )   Ck = apriori _ gen ( Lk -   1 ＇   ) -   Lk 
 　 　 ( 9 )   for   all   itemsets   c ∈ Ck   do   　 　 　 / *   对 Ck 进行 修剪   * / 
 　 　 ( 10 )   for   all   ( k -   1 ) - subset   s   of   c   do   
 　 　 ( 11 )   if   ( sLk -   1 ＇ )   then 
 　 　 ( 12 )   delete   c   from   Ck ; 
 　 　 ( 13 )   for   all   transactions   t ∈ D   do   begin 
 　 　 ( 14 )   Ct = subset ( Ck , t )   　 　 　 / *   Ck 中 包含 于 交易 t 的 候选 k - 项目 集 构成 Ct   * / 
 　 　 ( 15 )   for   all   candidates   c ∈ Ct   do 
 　 　 ( 16 )   c . count ++ ;   / *   Ct 中 候选 k - 项目 集 的 支持 度 计数 加 1   * / 
 　 　 ( 17 )   end 
 　 　 ( 18 )   Lk2   = { c ∈ Ck │ c . conut3   s ＇   } ; Lk ＇   = Lk2   ∪ Lk ; 
 　 　 ( 19 )   end 
 　 　 ( 20 )   Answer = ∪ kLk ＇   
 　 　 我们 也 可以 将 上述 算法 的 第 ( 8 ) 步 改为 如下 形式 : 
 　 　 ( 8 ) ＇ Ck ＇   = ∪ c ( c ∈ Lk -   1 ＇   ) ; Ck = { all   k - subset   c   of   Ck ＇   } -   Lk . 
 在 NEWIUA 算法 中 选用 ( 8 ) 或 ( 8 ) ＇   要 根据 数据库 D 的 特点 来 确定 其 优劣 . 
 　 　 在 上述 算法 中 , 第 ( 1 ) 步 用来 生成 候选 1 - 项目 集 C1 ; 第 ( 2 ) ～ ( 5 ) 步 计算 所有 候选 1 - 项目 集 的 支持 度 计数 ; 第 ( 6 ) 步 生成 新 的 所有 频繁 1 - 项目 集 ; 第 ( 8 ) 步 生成 所有 候选 k - 项目 集 的 集合 Ck ; 第 ( 9 ) ～ ( 12 ) 步对 Ck 进行 修剪 ; 第 ( 13 ) ～ ( 17 ) 步 计算 所有 候选 k - 项目 集 的 支持 度 计数 ; 第 ( 18 ) 步 生成 新 的 所有 频繁 k - 项目 集 ; 第 ( 20 ) 步是 结论 . 
 3 　 关联 规则 开采 的 并行算法 
 　 　 数据 开采 问题 的 主要 挑战性 在于 数据量 巨大 , 因此 算法 的 效率 是 关键 . 为了 提高 数据 开采 的 效率 , 可 有 两种 途径 来 解决 此 问题 : 一种 是 产生 高效率 的 算法 , 另 一种 是 计算机系统 结构 的 改进 . 在 目前 的 情况 下 , 后者 更 具有 吸引力 . 于是 我们 采用 多处理机 并行计算 模型 来 进行 关联 规则 的 开采 . 所 采用 的 多处理机 并行计算 模型 是 这样 的 : 各 处理机 有 各自 的 内存 , 事务 数据库 D 储存 于 一个 各 处理机 都 能 共享 的 大 外部 存储器 中 . 在 计算机 互连网 高度发达 , 高性能 工作站 通过 局域网 互连 而 构成 工作站 机群系统 的 今天 , 提出 以上 并行计算 模型 是 很 有 意义 的 . 
 　 　 以下 所 提出 的 各 关联 规则 开采 并行算法 的 基本 思想 与 NEWIUA 算法 一样 . 对于 k = 1 , 2 , ... , 首先 采用 某种 策略 来 生成 候选 k - 项目 集 的 集合 Ck 利用 一些 技巧 对 Ck 进行 修剪 , 然后 扫描 数据库 确定 频繁 k - 项目 集 的 集合 Lk , 最后 给出 结果 ∪ kLk . 
 3.1   多趟 扫描 数据库 的 并行算法 
 　 　 当 处理机 数远 小于 数据库 的 项目数 时 , 采用 以下 的 并行算法 来 进行 关联 规则 开采 . 不妨 设有 两台 处理机 P1 , P2 . 设 给定 最小 支持 度为 s , 关联 规则 开采 的 基本 框架 如下 . 
 　 　 并行算法 1 .   
 　 　 处理机 P1 并行执行 如下 步骤 : 
 　 　 ( 1 )   C1 = {   all   1 - itemsets   s   of   I   } 
 　 　 ( 2 )   for   all   transactions   t ∈ D   do   begin 
 　 　 ( 3 )   　 Ct1 = subset ( C1 , t )   　 　 　 / *   C1 中 包含 于 交易 t 的 候选 1 - 项目 集 构成 Ct1   * / 
 　 　 ( 4 )   　 for   all   candidates   c ∈ Ct1   do 
 　 　 ( 5 )   　 　 　 c . count ++ ;   　 　 　 　 / *   Ct1 中 候选 1 - 项目 集 的 支持 度 记数 加 1   * / 
 　 　 ( 6 )   end 
 　 　 ( 7 )   L1 = { c ∈ C1 │ c . counts } 
 　 　 ( 8 )   for   ( k = 3 ; Lk -   2 ≠ φ   ; k = k + 2 )   do   begin 
 　 　 ( 9 )   　 　 　 C1 = ∪ c   ( c ∈ Lk -   2 ) 
 　 　 ( 10 )   　 　 　 Ck = { all   k - itemsets   s   of   C1   } 
 　 　 ( 11 )   　 　 　 for   all   itemsets   c ∈ Ck   do   / *   对 Ck 修剪   * / 
 　 　 ( 12 )   　 　 　 　 for   all   ( k -   2 ) - subsets   s   of   C 
 　 　 ( 13 )   　 　 　 　 　 if   ( sLk -   2 )   then 
 　 　 ( 14 )   　 　 　 　 　 　 delete   c   from   Ck ; 
 　 　 ( 15 )   　 　 for   all   transactions   t ∈ D   do   begin 
 　 　 ( 16 )   　 　 　 Ct1 = subset ( Ck , t )   / *   Ck 中 包含 于 交易 t 的 候选 k - 项目 集 构成 Ct1   * / 
 　 　 ( 17 ) 　 　 　   for   all   candidates   c ∈ Ct   do 
 　 　 ( 18 )   　 　 　 　 c . count ++ ; 　 　 / *   Ct1 中 候选 k - 项目 集 的 支持 度 计数 加 1   * / 
 　 　 ( 19 ) 　 　   end 
 　 　 ( 20 ) 　 　   Lk = { c ∈ Ck │ c . count3   s } 
 　 　 ( 21 )   end 
 　 　 理机 P2 并行执行 如下 步骤 : 
 　 　 ( 1 )   　 C2 = { all   2 - itemsets   s   of   I } 
 　 　 ( 2 )   　 for   all   transactions   t ∈ D   do   begin 
 　 　 ( 3 ) 　 　 　   Ct2 = subset ( C2 , t )   / *   C2 中 包含 于 交易 t 的 候选 2 - 项目 集 构成 Ct2   * / 
 　 　 ( 4 )   　 　 for   all   candidates   c ∈ Ct2   do 
 　 　 ( 5 )   　 　 　 　 c . count ++ ;   / *   Ct2 中 候选 2 - 项目 集 的 支持 度 计数 加 1   * / 
 　 　 ( 6 )   end 
 　 　 ( 7 )   L2 = { c ∈ C2 │ c . count3   s } 
 　 　 ( 8 )   for   ( m = 4 ;   Lm － 2 ≠ φ   ; m = m + 2 )   do   begin 
 　 　 ( 9 )   　 　 　 C2 = ∪ c ( c ∈ Lm -   2 ) 
 　 　 ( 10 ) 　 　   Cm = { all   m - itemsets   s   of   C2 } 
 　 　 ( 11 )   　 　 for   all   itemsets   c ∈ Cm   do 
 　 　 ( 12 )   　 　 　 for   all   ( m -   2 ) - subsets   s   of   C 
 　 　 ( 13 )   　 　 　 　 if   ( sLm -   2 )   then 
 　 　 ( 14 ) 　 　 　 　 　 　 　 delete   c   from   Cm ; 
 　 　 ( 15 )   　 　 for   all   transactions   t ∈ c   do   begin 
 　 　 ( 16 ) 　 　 　 　   Ct2 = subset ( Cm , t )   　 　 　 / *   Cm 中 包含 于 交易 t 的 候选 m - 项目 集 构成 Ct2   * / 
 　 　 ( 17 ) 　 　 　 　   for   all   candidates   c ∈ Ct2   do 
 　 　 ( 18 )   　 　 　 　 　 　 c . count ++ ; 　 　   / *   Ct2 中 候选 m - 项目 集 的 支持 度 计数 加 1   * / 
 　 　 ( 19 )   　 　 end 
 　 　 ( 20 ) 　 　 　 Lm = { c ∈ Cm │ c . count3   s } 
 　 　 ( 21 )   end 
 　 　 当 P1 , P2 各自 都 完成 计算 后 , 由 其中 一台 处理机 计算 Answer = ∪ kLk , 则 算法 全部 结束 . 
 　 　 并行算法 1 采用 的 方法 是 处理机 P1 , P2 并行执行 . P1 用来 产生 所有 长度 是 奇数 的 频繁 项目 集 , P2 用来 产生 所有 长度 是 偶数 的 频繁 项目 集 , 然后 由 其中 一台 处理机 计算 出 最后 结果 . 
 　 　 设 数据库 D 在 最小 支持 度 s 下 所有 频繁 项目 集中 最大 的 长度 为 m1 , 则 Apriori 算法 需 扫描 数据库 m1 次 或 m1 + 1 次 . 这种 情况 下 , 在 并行算法 1 中 , 两台 处理机 分别 并行 地 扫描 数据库 最 多 [ m1 / 2 ] + 1 次 , 故 并行算法 1 与 Apriori 算法 相比 , 执行 效率 提高 将近 1 倍 . 而 并行算法 1 也 可以 增加 处理机 的 数量 , 以 提高 数据 开采 的 速度 . 但 在 并行算法 1 中 , 并非 处理机 数量 越多越好 , 这 是因为 当 处理机 数量 增加 时 , 会 将 很多 根本 不 可能 是 频繁 项目 集 的 项目 集 添加 到 对应 的 候选 项目 集中 , 于是 就 增加 了 无谓 的 计算 量 . 因此 , 在 采用 并行算法 1 进行 关联 规则 开采 时 , 应适当 选用 处理机 数目 . 
 3.2 分 部分 扫描 数据库 的 并行算法 
 　 　 设有 n 台 处理机 P1 , P2 , ... , Pn , 我们 可以 采用 下列 并行算法 来 进行 关联 规则 的 开采 . 
 　 　 并行算法 2 . 
 　 　 ( 1 )   将 数据库 D 均匀 地 分为 n 个 部分 D1 , D2 , ... , Dn ; 
 　 　 ( 2 )   处理机 P1 生成 I 的 所有 1 - 项目 集 构成 候选 1 - 项目 集 的 集合 C1 ; 
 　 　 ( 3 )   处理机 Pj ( j = 1 , 2 , ... , n ) 并行 扫描 数据库 D 的 对应 部分 Dj , 计算 候选 1 - 项目 集 的 支持 度计 
 　 　 　 　 数 ; 
 　 　 ( 4 )   根据 各 处理机 的 计算结果 , 处理机 P1 计算 出 所有 候选 1 - 项目 集 的 最后 支持 度 计数 , 并 生成 
 　 　 　 　 L1 ; 
 　 　 ( 5 )   循环 ( k = 2 ; Lk -   1 ≠ φ ; k ++ )   do   begin 
 　 　 ( 6 )   由 处理机 P1 生成 候选 k - 项目 集 的 集合 Ck , 即 Ck = apriori _ gen ( Lk - 1 ) ; 
 　 　 ( 7 )   各 处理机 Pj ( j = 1 , 2 , ... , n ) 并行 地 扫描 数据库 D 的 对应 部分 Dj   , 计算 候选 k - 项目 集 的 支持 
 　 　 　 　 度 计数 ; 
 　 　 ( 8 )   根据 各 处理机 的 计算结果 , 处理机 P1 计算 出 所有 候选 k - 项目 集 的 最后 支持 度 计数 , 并生 
 　 　 　 　 成 Lk ; 
 　 　 ( 9 )   循环 结束 ; 
 　 　 ( 10 )   处理机 P1 最后 生成 Answer . 
 　 　 注 : 各 处理机 在 并行执行 时 由 处理机 P1 负责 同步 . 
 　 　 并行算法 2 扫描 数据库 的 趟 数 与 Apriori 算法 相同 , 但 在 每 一趟 扫描 数据库 时 , 由于 各 处理机 分别 并行 地 扫描 数据库 的 一个 部分 , 故 从 理论 上 讲 , 并行算法 2 扫描 数据库 的 效率 是 Apriori 算法 的 n 倍 . 即 并行算法 2 比 Apriori 算法 的 效率 提高 了 近 n 倍 . 
 　 　 本文 提出 的 并行算法 2 , 在 当前 大规模 并行 计算机 中 以及 互连网 技术 高度 发展 的 情况 下 是 一种 非常 实用 和 有效 的 算法 . 在 分布式 数据库 中 进行 关联 规则 的 开采 , 并行算法 2 也 是 一种 有效 的 算法 . 在 并行算法 2 中 , 扫描 数据库 以 计算 项目 集 的 支持 度 计数 的 执行 效率 是 非常 高 的 , 而此 算法 所 面临 的 是 在 并行计算 模型 中 的 消息 发送 与 接收 的 速度 问题 . 若 在 一个 消息 发送 与 接收 高效 的 系统 中 , 利用 并行算法 2 来 对 数据库 ( 或 分布式 数据库 ) 进行 关联 规则 的 开采 则 是 非常 高效 的 . 
 3.3   两趟 扫描 数据库 的 并行算法 
 　 　 设有 m 台 处理机 , 分别 为 P1 , P2 , P3 , ... , Pm . 与 数据库 D 的 项目数 相等 时 , 一种 最 简单明了 的 算法 是 : 处理机 Pj ( j = 1 , 2 , 3 , ... , m ) 并行 地 执行 如下 操作 : 
 　 　 ( 1 )   Cj = { all   j - subsets   s   of   I } ,   / *   I 的 所有 j - 项目 集所 构成 的 集合 作为 候选 j - 项目 集 * / 
 　 　 ( 2 )   扫描 数据库 D , 计算 各 候选 项目 集 的 支持 度 计数 , 
 　 　 ( 3 )   Lj = { c ∈ Cj │ c . count   s } . 
 　 　 当 所有 处理机 都 完成 计算 后 , 由 其中 一台 处理机 计算 Answer = ∪ kLk , 则 算法 结束 . 
 　 　 采用 上述 算法 虽然 各 处理机 并行 地 扫描 一次 数据库 即可 完成 关联 规则 的 开采 , 但是 此 算法 的 计算 量 是 非常 大 的 , 要 计算 I 的 2m -   1 个 非 空子 集 的 支持 度 . 但是 若 事先 已知 I 的 某 一 项目 所 构成 的 集合 不是 频繁 1 - 项目 集 , 则 只 计算 I 的 2m -   1 -   1 个 非 空子 集 的 支持 度 , 运算量 下降 了 1 倍 . 在 实际 的 关联 规则 开采 时 , 一般 情况 下 有 下列 两个 特点 : ①   在 由 m 个 项目 组成 的 项目 集 I 中 , 所有 项目 构成 的 1 - 项目 集 不 可能 全是 频繁 1 - 项目 集 . ②   I 中 所有 项目 所 构成 的 m - 项目 集 不 可能 是 频繁 项目 集 . 根据上述 两个 特点 , 为了 减少 计算 量 , 我们 提出 以下 并行算法 . 
 　 　 并行算法 3 . 
 　 　 ( 1 )   各 处理机 Pj 并行 地 扫描 数据库 , 计算 1 - 项目 集 { ij } 的 支持 度 , 最后 根据 各 处理机 的 计算结果 由 其中 一台 处理机 确定 出 L1 , 并 计算 C = ∪ c ( c ∈ L1 ) 或 ( 1 ) ＇ 由 其中 一台 处理机 计算 出 L1 , 并 计算 C = ∪ c ( c ∈ L1 ) . 设 L1 中 频繁 1 - 项目 集 的 数目 为 mp , 则 mpm ; 
 　 　 ( 2 )   各 处理机 Pj ( j = 1 , 2 , ... , mp -   1 ) 并行执行 以下 操作 : 
 　 　 ①   Cj + 1 = { all   ( j + 1 ) - subsets   s   of   C } ;   / *   产生 候选 ( j + 1 ) - 项目 集   * / 
 　 　 ②   扫描 数据库 D , 计算 各 候选 集 的 支持 度 ; 
 　 　 ③   Lj + 1 = { c ∈ Cj + 1 │ c . counts } ;   / *   确定 频繁 ( j + 1 ) - 项目 集   * / 
 　 　 ( 3 )   由 其中 一 处理机 计算 Answer = ∪ kLk . 
 　 　 一般 情况 下 , 经过 并行算法 3 的 第 ( 1 ) 步 处理 后 , 在 执行 算法 的 第 ( 2 ) 步 , 各 处理机 并行执行 所 产生 的 候选 项目 集数 目的 总和 要 比 2m -   1 少得 多 . 这样 , 在 各 处理机 分别 并行 地 扫描 数据库 D 以 计算 各 候选 项目 集 的 支持 度 计数 时 , 计算 量会 大幅度 下降 , 加之 并行算法 3 用于 关联 规则 开采 时仅 对 数据库 扫描 两次 , 从而 大大提高 了 关联 规则 开采 的 效率 . 
 　 　 在 处理机 数量 非常 多 的 并行计算 模型 中 , 对 数据库 进行 开采 时 , 本文 提出 的 并行算法 3 是 一种 高速 算法 . 此 算法 是 以 某些 处理机 执行 无用 的 计算 ( 即 计算 那些 明显 不是 频繁 项目 集 的 支持 度 ) 为 代价 来 换取 速度 的 . 以 机器 的 数量 换取 数据 开采 的 速度 , 这 在 计算机硬件 大幅度 降价 的 今天 , 也 是 一种 很 有 意义 的 方案 . 
 　 　 本文 提出 的 并行算法 3 可以 有 下列 两种 改进 方案 . ( 1 )   当 处理机 数量 不 增加 时 , 在 并行算法 3 中 , 当对 数据库 第 2 次 扫描 时 , 由于 有些 处理机 已 处于 空闲 状态 , 这时 可以 让 那些 空闲 的 处理机 去 分担 那些 计算 负荷 较大 的 处理机 的 计算 任务 . 这 需要 在 算法 中 采用 动态分配 处理机 的 方法 . ( 2 )   当 处理机 数量 是 项目 数量 的 若干倍 时 , 我们 可以 将 并行算法 2 和 并行算法 3 结合 起来 , 将 数据库 分为 若干 部分 , 每 一部分 利用 并行算法 3 进行 项目 集 的 支持 度 计算 . 
 　 　 对于 本文 提出 的 关联 规则 开采 并行算法 , 都 可以 根据 本文 提出 的 关联 规则 更新 算法 NEWIUA 中所 提供 的 方法 , 修改 成 效率 较 高 的 关联 规则 更新 的 并行算法 . 
 4 　 结束语 
 　 　 大量 数据 的 产生 和 收集 导致 了 信息 爆炸 , 要 从中 发现 有 价值 的 信息 或 知识 , 达到 为 决策 服务 的 目的 , 成为 非常 艰巨 的 任务 . 数据 开采 方法 正是 为此 目的 而 提出 的 . 
 　 　 数据 开采 所 面对 的 是 大型 数据库 或 大型 数据仓库 , 其 任务 是从 海量 数据 中 挖掘 有 价值 的 信息 或 知识 . 因此 , 数据 开采 所 面临 的 最大 的 挑战 是 计算 效率 问题 , 解决 这一 问题 的 途径 是 产生 高效 的 数据 开采 算法 与 并行处理 , 而 两者之间 的 结合 更 具有 引 吸力 . 也就是说 , 随着 现代 社会 的 信息量 的 急剧 增长 , 迫切需要 高效 的 并行 数据 开采 算法 的 产生 . 
 注释 ： 本文 研究 得到 国家自然科学基金 和 太原 师范 专科学校 科研 基 基金 资助 。 
 作者简介 ： 周 海岩 ： 1957 年生 , 讲师 , 主要 研究 领域 为 数据 开采 ， 信息 存储 ， 计算机 算法 ， 数据库 理论 
 作者 单位 : 太原 师范 专科学校   太原   030001 
 参考文献 
 1 　 冯玉才 , 冯剑琳 . 关联 规则 的 增量 式 更新 算法 . 软件 学报 , 1998 , 9 ( 4 ) : 301 ～ 306 
 　 ( Feng   Yu - cai ,   Feng   Jian - lin .   Incremental   updating   algorithms   for   mining   
 　 　 association   rules .   Journal   of   Software ,   1998 , 9 ( 4 ) : 301 ～ 306 ) 
 2 　 胡侃 , 夏绍玮 . 基于 大型 数据仓库 的 数据 采掘 : 研究 综述 . 软件 学报 , 1998 , 9 ( 1 ) : 53 ～ 63 
 　 ( Hu   Kan ,   Xia   Shao - wei .   Large   data   warehouse - based   data   mining :   a   survey .   Journal   
 　 　 of   Software ,   1998 , 9 ( 1 ) : 53 ～ 63 ) 
 3 　 Agrawal   R ,   Srikant   R .   Fast   algorithms   for   mining   association   rules .   In :   
 　 　 Proceedings   of   the   20th   International   Conference   on   Very   Large   Databases .   
 　 　 Santiago ,   Chile ,   1994 .   487 ～ 499 
 收稿 日期 : 1998 - 08 - 10 修稿 日期 ; 1998 - 10 - 14 
