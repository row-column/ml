计算机 工程 
 Computer   Engineering 
 1999 年 　 第 25 卷 　 第 9 期 　 Vol.25   No.9     1999 
 
 
 
 基于 自治 对象 的 分布 系统 研究 及 实现 
 宋 　 辉 　 尚文倩 　 朱 海滨 
 　 　 摘 　 要 ： 简单 介绍 造 分布式系统 的 R PC机 制 ， 描述 了 一个 使用 语言 实现 的 自治 对象 分布式系统 原形 ． 
 　 　 关键词 ： 自治 对象 ； 代理 ； Java ； 分布式系统 
 Research   and   Application   for   Distributed   System   Based   on   Sutoomous   Object 
 Song   Hui   Shang   Wenqian   Zhu   Haibin 
 ( School   of   Computer   Science ,   National   University   of   Defense   Technology ,   Changsha   410073 ) 
 　 　 Abstract 　 It   introduces   some   traditionary   technologies   for   constructing   distributed   system   and   decribes   an   autonomous   object   based   on   Java . 
 　 　 Key   words 　 Autonomous   object ;   Agent ;   Java ;   Distrbuted   system 
 　 　 Internet   将 数以百万计 的 计算机 连成 一体 ， 为 我们 提供 了 前所未有 的 计算能力 。 如何 在 这样 一个 巨大 的 网络 上 进行 分布式系统 应用 ， 成为 一个 很 重要 的 方向 。 鉴于 传统 的 构造 分布式系统 的 技术 在 大规模 网络 上 存在 许多 缺点 ， 有 必要 使用 新 的 技术 和 思想 来 构造 分布式系统 。 以下 介绍 构造 分布式系统 的 几种 传统 技术 。   
 1 　 R PC机 制 
 　 　 RPC ( 远程 过程 调用 )   是 一种 传统 的 构造 分布 应用 的 方法 ， 可以 说 它 是 其它 几种 机制 的 基础 。   
 　 　 RPC 操作 一般 在 本地 进程 进行 过程 调用 ， 而 在 服务器 上 执行 调用 。 RPC   的 基本原理 非常简单 ， 即 让 本地 计算机 中 的 某个 过程 调用 服务器 上 的 另外 一个 过程 。   RPC   的 执行 过程 是 ： 本地 过程 通过 消息传递 机制 将 过程 调用 请求 消息 传送 到 服务器 的 一个 进程 ， 该 过程 接收 这一 过程 调用 消息 ， 执行 被 调用 过程 ， 然后 通过 应答 消息 返回 执行 结果 给 调用 过程 。   RPC   的 语义 大部分 与 传统 过程 调用 一样 。   
 　 　 但是 ， 与 传统 过程 调用 所 不同 的 是 ， 远程 过程 调用   RPC   中 被 调用 的 远程 过程 不能 访问 调用 过程 运行 环境 中 的 变量 和 数据 ， 
 因为 两个 过程 执行 所在 的 地址 空间 不同   ( 两个 机器 上 不同 的 操作系统 管理 自己 不同 的 地址 空间 )   ， 因而 要 进行 参数 的 传递 。 
 　 　 这种 方法 ， 主程序 的 使用 比较简单 ， 缺点 是 系统 的 升级 比较 繁琐 。 由于 执行 的 主体 程序 在 服务器 上 ， 所以 必须 在 服务器上安装 所 需要 的 服务 进程 。 当 应用 的 规模较 小时 ， 问题 还 不 明显 ， 当 系统 的 规模 扩大 到 一定 程度 ， 整个 应用 的 升级 和 一致性 的 保持 就 很 困难 。 
 2 　 自治 对象 系统结构 
 2.1 　 自治 对象 技术 
 　 　 自治 对象 可以 称为 Agent 。 它 为了 用户 的 利益 ， 在 网络 上 根据 一定 的 规则 进行 移动 ， 在 合适 的 位置 执行 合适 的 动作 ， 完成 用户 的 要求 。   
 　 　 相对 前面 所说 的 构造 分布式系统 技术 ， 自治 系统 有 两个 最 显著 的 特点 ：   
 　 　 ( 1 )   自主 导航 性 　 自治 对象 可以 自动 寻找 完成 用户 赋予 的 任务 所 需要 协作 的 其他 自治 对象 或 场所 。 用户 不 需要 详细 指明 这些 信息 。 用户 只 需 在   Agent   启动 的 时候 指明 交给 它 的 任务 和 其它 一些 必要 信息 即可 。 自治 对象 自己 会 根据 已有 的 知识 到 合适 的 地方 获取 那些 信息 。 
 　 　 ( 2 )   代码 的 移动   牋   自治 对象 与 通常 的   RPC   等 机制 不 一样 。 它 在 移动 的 时候 ， 程序 之间 不仅 进行 了 控制 的 转移 ， 还 进行 了 代码 的 转移 。 服务器 上 不 需要 事先 安装 客户 的 程序 ， 它 只 需要 能够 解释 和 执行 用户 的 程序代码 即可 。 当 用户 的 代码 需要 在 某地 执行 的 时候 ， 它 就 携带 自身 的 执行 代码移动 到 该地 ， 该地 的 服务器 解释 执行 它 的 代码 。 这样 ， 整个 系统 的 结构 灵活性 大大提高 ， 有 很 好 的 可扩充性 。 
 2.2 　 自治 对象 的 体系结构 
 　 　 自治 对象 系统 由 两 部分 组成 ： Agent 和 场所 。 Agent 就是 一个 自治 对象 ， 它 提供 某种 服务 或 寻求 某种 服务 。 Agent 分为 两种 ： 用户 Agent 和 服务 Agent 。 用户 Agent 由 用户 发出 ， 代表 用户 的 利益 ， 可以 在 网络 上 各个 场所 之中 移动 。 服务 Agent 由该 场所 的 管理员 发出 ， 它 不能 在 网络 上 各个 场所 之中 移动 ， 它 固定 在 某个 场所 ， 提供 某种 特定 的 服务 ， 它 可以 与 用户 Agent   和 其它 的 服务   Agent   交流信息 。 场所 是 Agent 之间 进行 交易 的 地方 ， 一般 情况 下 ， 每个 场所 都 有 一个 服务   Agent   ， 用户 Agent 需要 某种 服务 时 必须 移动 到 提供 该 服务 的 场所 与 服务 Agent   进行 交互 才能 完成 交易 。 例如 某个 节点 定义 为 售票处 场所 ， 那么 这里 就 有 一个 售票 的 服务 Agent   ， 所有 要 购票 的 用户 Agent 必须 移动 到 该处 ， 与 这个 服务 Agent 进行 交易 。 
 
 图 1 　 自治 对象 系统 逻辑图 
 　 　 基于 自治 对象 的 分布式系统 分为 两层 ： 系统 服务 层 和 应用层 。 系统 服务 层有 ： Java 虚拟机 、 场所 间通信 器和类 服务器 ， 它 向 应用 提供 必要 的 系统 服务 。 Java 虚拟机 负责 系统 中 程序代码 的 解释 执行 。 场所 间通信 器 提供 了 网络 之间 的 通信 支持 ， 场所 之间 信息 的 交流 ， Agent 的 传输 和 节点 的 构造 等 。 每个 节点 对应 一个 场所 。 类 服务器 负责   Java 类库 的 加载 。 类库 可以 从 本地 磁盘 上 加载 ， 也 可以 从 网络 某个 节点 上 加载 。 应用层 由 针对 某个 特定 应用 开发 的 各种 Agent 和 场所 构成 ， 不同 的 应用 有 不同 的 组成 。 图 1 是 自治 对象 系统 的 逻辑 结构 。 
 2.3 　 自治 对象 的 实现 
 　 　 在 设计 实现 基于 自治 对象 的 分布式系统 时 ， 采用 了   Java   语言 ， 主要 原因 如下 ：   
 　 　 . Java   是 跨平台 的 语言   牋   采用 了 字节 码 ， 提供 了 跨平台 解释器 。 可以 在 不同 的 计算机系统 中 实现 自治 对象 。 
 　 　 . Java   是 面向对象 的 语言 在 Java 中 ， 一切 东西 都 是 对象 。 提供 了 很多 很 好 的 特性 ， 可以 有效 地 支持 对象 计算 。 使用 它 来 构造 分布式 对象 系统 显然 是 一个 很 好 的 选择 。   
 　 　 . Java   语言 自身 对   Internet   应用 的 支持   牋 Java   语言 的 最初 目的 就是 为了 进行 网络 计算 ， 因此 它 提供 了 良好 的 网络 支持 ， 且 提供 了 对象 系列化   ( Object 　 erialization )   包 ， 可以 方便 地 在 网络 上 存取 对象 。   
 　 　 自治 对象 应 具有 以下 属性 和 方法 ：   
 　 　 属性   CheckPoint ： 表示 纪录 转移 时 ， live 方法 中 语句 的 执行 位置 。 这样 在 移动 到 另外 的 场所 后 ， 就 可以 接着 执行 后继 动作 。 
 　 　 · . 方法 live ： 描述 了 自治 对象 在 生命 中 的 行为 。 它 也 是 自治 对象 移动 到 下 一个 场所 后 首先 执行 的 方法 。   
 　 　 . 方法 go ： 将 自治 对象 移动 到 另外 一个 场所 。 
 　 　 . 方法 meet ： 自治 对象 使用 该 方法 与 场所 中 的 服务 Agent 进行 交易 。 
 3 　 实现 基于 自治 对象 的 分布式系统 的 主要 问题 
 　 　 在 实现 基于 自治 对象 分布式系统 时 ， 主要 解决 了 3 个 技术 难点 ： 对象 的 转移 、 类库 的 加载 和 移动 对象 的 通信 。   
 　 　 ( 1 )   对象 的 转移   
 　 　 自治 对象 在 一生 中 经常 进行 转移 。 自治 对象 的 转移 不仅 是 执行 控制 的 转移 ， 还 包括 执行 代码 的 转移 ， 这 就 涉及 到 一个 经典 的 分布式系统 难题 － 进程 的 转移 。   
 　 　 在 构造 分布式系统 中 ， 一般 都 不 支持 进程 的 转移 。 这 是因为 进程 的 转移 非常 麻烦 ， 所 需要 的 代价 很大 。 进行 进程 转移 ， 需要 保存 进程 的 执行 环境 ， 同时 还要 在 另外 的 计算机 上 进行 进程 执行 环境 的 恢复 。 很难 对 异构 的 计算机 设计 一个 统一 的 方法 。 Java 虚拟机 是 一个 逻辑 上 的 计算机 ， 只要 是 支持 Java 语言 ， 使用 的 虚拟机 的 体系结构 就是 一样 的 。 因此 可以 设计 一种 统一 有效 的 进程 转移 方法 。 
 　 　 但是 使用 Java 虚拟机 仅仅 解决 了 平台 一致性 问题 ， 如果 要 解决 进程 转移 中 的 其它 问题 ， 就 必须 对 Java 虚拟机 进行 剖析 和 改造 ； 还 必须 保证 改造 后 的 虚拟机 的 兼容性 ， 实现 的 工程量 很大 。 因此 在 系统 中 使用 了 另外 一种 方法 － 对象 系列化 和 检查点 机制 结合 完成 转移 。 这种 方法 利用 了 Java 语言 中 提供 的 机制 ， 不 对 虚拟机 进行 改造 ， 能够 保证 兼容性 和 跨平台 性 ， 但是 对 程序 的 编制 有 要求 。 
 　 　 对象 的 状态 是 由 3 个 方面 决定 的 ： 成员 变量 状态 、 程序 的 代码 ( 程序 状态 ) 和 执行 状态 ( 语景 ) 。 只要 完成 上述 3 个 状态 的 转移 就 可以 认为 完成 了 对象 的 转移 。 程序 状态 和 成员 变量 状态 的 转移 可以 使用 对象 系列化 技术 来 解决 ， 执行 状态 的 转移 是 通过 检查点 机制 实现 转移 的 。 
 　 　 对象 系列化 　 它 使得 程序员 能够 方便 地 存取 对象 。 不论 它 是 在 本地 文件系统 ， 还是 在 网络 上 ， 每个 人 都 可以 把 对象 通过 网络 或是 其他 途径 发送到 另一台 计算机 上 运行 。 Java 对象 系列化 允许 对象 方便 地 通过 流 传输 ， 如 文件 流 、 Socket 数据流 。 使用 流 机制 程序员 能够 方便 地 将 复杂 的 对象 写入 文件 或 通过 网络 传输 。 对象 系列化 机制 实现 了 对 对象 类型 、 关联 ， 以及 对象 存储 细节 的 透明 处理 。 绝大部分 工作 都 由 系统 自动 完成 ， 使得 大多数 采用 对象 系列化 的 应用 实现 起来 相当 简单 。 
 　 　 大多数 情况 下 ， 要 实现 对象 的 系列化 ， 可以 通过 采用   Serializable   接口 来 得到 。   Serializable   接口 不 需要 实现 任何 特殊 方法 ， 但类 中 的 每 一个 数据 对象 必须 是 对象 系列化 对象 。   JDK1.1   中 的 所有 基本 对象 和 类型 ， 如   Int   、   String 、   Array   、   Vector 燞 ashtable   都 是 对象 系列化 对象 。 
 　 　 检查点 　 自治 对象 的 执行 状态 与 live 方法 的 执行 位置 有关 。 由于 自治 对象 的 行为 由该 方法 决定 ， 它 的 执行 位置 也 决定 了 该 对象 移动 到 另外 节点 的 什么 位置 执行 ， 且 保证 对象 活动 的 连续性 。 在 系统 中 ， 使用 了 检查点 机制 来 解决 执行 点 的 恢复 和 保存 。 对象 的 移动 并 不是 任何 时候 都 可以 进行 ， 移动 只能 在 检查点 上 进行 。 自治 对象 由 一个 私有 变量 CheckPoint ， 把 当前 Live 方法 执行 保存 到 检查点 的 位置 。 当 对象 移动 到 另外 一个 场所 后 ， 服务器 先 恢复 该 对象 的 成员 变量 ， 然后 执行 Live 方法 ， 该 方法 检查 变量 CheckPoint 的 值 ， 跳转 到 该 检查点 执行 。 这种 方法 比较简单 ， 但是 编程 不 方便 ， 必须 手工 进行 检查点 的 设置 ， 在 需要 转移 的 地方 进行 CheckPoint 的 设置 ， 增加 了 程序员 的 负担 。 但是 ， 它 的 最大 优点 是 可以 在 不 改动 编译器 的 情况 下 实现 对象 的 转移 。   
 　 　 ( 2 )   类库 的 动态 加载 
 　 　 由于 用户   Agent   的 执行 代码 是 解释 执行 的 ， 类库 是 动态 加载 的 ， 所以 Agent 的 对象 并 不 包含 它 继承 的 所有 类 代码 。 因此 当 用户 Agent 移动 到 某地 执行 ， 动态 加载 它 的 父类 时 ， 可能 该地 没有 该类 ， 因此 必须 从 该 Agent 上次 执行 的 节点 或 诞生 的 节点 处 获得 该类 代码 。 在 系统 中 ， 专门 提供 了 一个 类 服务器 。 负责 Agent 的 类库 代码 加载 。 如果 在 本地 磁盘 上 没有 该类 ， 它 就 向 该 Agent 的 诞生地 的 类 服务器发送 请求 。 当类 服务器 收到 请求 后 ， 就 查找 本地 类库 管理器 ， 如果 找到 了 
 该类 代码 ， 就 将 代码 发给 请求者 。 
 　 　 当 网络 的 规模 很大 时 ， 发出请求 的 节点 可能 与 用户 Agent 的 诞生地 非常 远 ， 直接 向 诞生地 请求 可能 效率 低 ， 因此 在 每个 节点 的 系统 中 增加 一个 类库 缓冲 ， 当 用户 的 Agent 离开 某个 节点 时 ， 类 服务器 将 收到 的 该 Agent 的 父类 代码 放入 类库 缓冲 。 用户 的 Agent 在 执行 时 ， 如果 本地 磁盘 上 没有 该类 ， 它 就 向 该 Agent 的 上次 执行 节点 的 类 服务器 请求 。 当类 服务器 收到 请求 后 ， 就 查找 本地 类库 管理器 ， 如果 找到 了 该类 代码 ， 就 将 代码 发给 请求者 ； 如果 没有 ， 就 返回   "   查无 此类   " 
 信息 。 类 服务器 收到   "   查无 此类   "   信息 就 向 该 Agent 的 诞生地 的 类 服务器发送 请求 。 
 　 　 ( 3 )   对象 间通信 
 　 　 自治 对象 的 不断 移动 带来 位置 的 不确定性 。 要 保证 通信 畅通 ， 就 必须 保证 该 对象 的 新 位置 能够 被 需要 的 对象 得到 。 自治 对象 的 位置 由   TCP / IP   协议 中 的 地址 和 端口号 组成 。 
 　 　 系统 中 存在   3   类 通信 ： 用户 Agent 之间 的 通信 、 用户 Agent 和 服务 Agent 之间 的 通信 和 场所 间通信 。 场所 间通信 实现 场所 之间 的 信息 交流 ， 主要 是 通过 Agent 之间 的 传输 和 虚拟 节点 的 构造 进行 信息 交换 。 由于 场所 是 固定 的 ， 它们 之间 可以 建立 固定 的 通信 连接 ， 交换 特定 的 消息 。   
 　 　 用户 Agent 和 服务 Agent 之间 的 通信 中 包含 目录 服务 通信 和 特定 服务 通信 。 目录 服务 Agent 不断 监听 某个 特定 端口 ， 向 用户 Agent 的 查询 消息 返回 结果 。 该 特定 端口 是 公开 的 。 特定 服务 通信 的 端口 可 由 开发者 自己 设定 ， 提供 服务 之前 需要 向 目录 服务   Agent   提交 自己 的 特征 信息   (   如 提供 的 服务类型 ， URL 等   )   。 用户 Agent 从 目录 服务 Agent 得到 该类 信息 后 再 与 该 服务 Agent 进行 信息 交互 。 
 　 　 用户 Agent 之间 的 信息 交互 由于 移动 产生 了 位置 的 不确定性 。 为了 保证 对象 在 任意 位置 都 能 与 其他 对象 通信 ， 因此 在 每个 节点 中 都 设有 一个 对象 管理 Agent ， 它 负责 本地 产生 的 对象 和 驻留 在 本地 对象 的 管理 。 具体 的 工作 如下 ： 
 　 　 ① 对象 管理 Agent 记录 和 维护 本地 出生 用户 Agent 的 特征 信息 ( 对象 名 ， ID ， 驻留 节点 ， 驻留 时 的 URL 等   ) ， 并 赋予 用户 Agent 一个 含有 出生地 信息 的 标识号 。 根据 本地 出生 用户 Agent 在 新 驻留 地 获得 的 临时 URL 修改 相应 的 记录 信息 。 用户 Agent 在 完成 任务 后 ， 向 出生 节点 的 对象 管理 Agent 注销 ， 然后 死亡 。   
 　 　 ② 对象 管理 Agent 记录 漫游 到 本地 的 外地 出生 用户 Agent 的 驻留 信息   ( 对象 名 ， ID ， 使用 的 端口号 等 ) ， 并 根据 本 节点 端口号 的 使用 情况 向 用户 Agent 分配 一个 新 的 端口号 或 让 它 保留 原有 端口号 。 当 用户 Agent 漫游 到 某 节点 时 ， 向 该 节点 的 对象 管理 Agent 登记 驻留 信息 。 用户 Agent 将 其 在 驻留 地 获得 的 URL 报告 给 出生地 对象 管理 Agent 。 当 Agent   A 第一次 有 消息 发送给   Agent   B 的 时候 ， 首先 向 Agent   B 出生地 的 对象 管理 Agent 查询 Agent   B 的 驻留 节点 的 URL ， 获得 后 ， 通过 该 URL 来 与 Agent   B 直接 通信 ， 以后 每次 都 直接 通信 。 当 连续 几次 通信 失败 后 ， 就 意味着   Agent   B 已经 移动 ， Agent   A 向 Agent   B 的 出生地 的 对象 管理 Agent 查询 Agent   B 的 驻留 节点 的 URL 。 
 4 　 结束语 
 　 　 目前 ， 网络 技术 的 迅速 发展 ， 使得 在 大规模 网络 上 构造 复杂 的 分布式应用 系统 成为 可能 。 未来 工作 的 一个 重要 方向 就是 代码 的 移动 。 目前 的 移动 做 得 还 很 不够 ， 效率 并 不 高 ， 对 程序 的 要求 却 比较 高 。 一种 方法 是 提供 一个 预 编译器 ， 对 程序 进行 预处理 ， 实现 检查点 的 透明 ； 另外 一种 就是 直接 在 Java 虚拟机 上 做 一些 改动 ， 使 它 能够 较 好 地 支持 代码移动 。 系统 中 对象 之间 的 安全性 也 是 一个 重要 问题 ， 需要 解决 相互之间 的 信任 问题 、 通信 内容 的 安全性 等 。   
 * 基金项目 ： 国防科技大学 预研 基金 
 作者简介 ： 宋 　 辉 ( 1974 ～ ) ， 男 ， 研究生 ， 主要 研究 方向 ： 计算机 体系结构 
 作者 单位 ： 国防科技大学 计算机 学院 ， 长沙 　 410073 
 参考文献 
 1 　 Griswold . Unleashing   Agents ： The   First   Wave   of   Products   Incorporation   Software   Agent   Technology   Has   Hit   the   Market . See   What ' s   Afoot . Internet   World , 1996   
 2 　 Luca   C . Mobile   Computation . http : / / www . research . digital . com / SRC /   
 3 　 Sun   公司   . JDK1.1 . 6   Document.1998 , http : / / www . javasoft . com   
 收稿 日期 ： 1998 － 11 － 30 
