微型机 与 应用 
 WEIXINGJI   YU   YINGYONG 
 1999 年 3 月   第 18 卷   第 3 期   vol.18   No.3 
 
 
 
 SQL   Server 数据库 性能 优化 技术 
 钱 文波 　 谢金宝 
 　 　 摘 　 要 ： 影响 SQL   Server 数据库 性能 的 一些 因素 及 SQL   Server 进行 性能 优化 的 原理 ， 并且 提出 了 一些 指导性 的 原则 来 优化 数据库 的 性能 。 
 　 　 关键词 ： SQL   Server 数据库 　 性能 优化 　 查询 
 　 　 设计 1 个 应用 系统 似乎 并 不难 ， 但是 要 想 使 系统 达到 最优化 的 性能 并 不是 一件 容易 的 事 。 在 开发工具 、 数据库 设计 、 应用程序 的 结构 、 查询 设计 、 接口 选择 等 方面 有 多种 选择 ， 这 取决于 特定 的 应用 需求 以及 开发 队伍 的 技能 。 本文 以 SQL   Server 为例 ， 从 后台 数据库 的 角度 讨论 应用程序 性能 优化 技巧 ， 并且 给出 了 一些 有益 的 建议 。 
 1 　 数据库 设计 
 　 　 要 在 良好 的 SQL   Server 方案 中 实现 最优 的 性能 ， 最 关键 的 是 要 有 1 个 很 好 的 数据库 设计方案 。 在 实际 工作 中 ， 许多 SQL   Server 方案 往往 是 由于 数据库 设计 得 不好 导致 性能 很差 。 所以 ， 要 实现 良好 的 数据库 设计 就 必须 考虑 这些 问题 。 
 1.1 　 逻辑 库 规范化 问题 
 　 　 一般来说 ， 逻辑 数据库 设计 会 满足 规范化 的 前 3 级 标准 ： 
 　 　 1 . 第 1 规范 ： 没有 重复 的 组 或 多值 的 列 。 
 　 　 2 . 第 2 规范 ： 每个 非 关键字 段 必须 依赖于 主 关键字 ， 不能 依赖于 1 个 组合式 主 关键字 的 某些 组成部分 。 
 　 　 3 . 第 3 规范 ： 1 个 非 关键字 段 不能 依赖于 另 1 个 非 关键字 段 。 
 　 　 遵守 这些 规则 的 设计 会 产生 较少 的 列 和 更 多 的 表 ， 因而 也 就 减少 了 数据 冗余 ， 也 减少 了 用于 存储 数据 的 页 。 但表 关系 也许 需要 通过 复杂 的 合并 来 处理 ， 这样 会 降低 系统 的 性能 。 某种程度 上 的 非 规范化 可以 改善 系统 的 性能 ， 非 规范化 过程 可以 根据 性能 方面 不同 的 考虑 用 多种不同 的 方法 进行 ， 但 以下 方法 经 实践 验证 往往 能 提高 性能 。 
 　 　 1 . 如果 规范化 设计 产生 了 许多 4 路 或 更 多路 合并 关系 ， 就 可以 考虑 在 数据库 实体 ( 表 ) 中 加入 重复 属性 ( 列 ) 。 
 　 　 2 . 常用 的 计算 字 段 ( 如 总计 、 最大值 等 ) 可以 考虑 存储 到 数据库 实体 中 。 
 　 　 比如 某 一个 项目 的 计划 管理系统 中有 计划表 ， 其字 段 为 ： 项目编号 、 年初 计划 、 二次 计划 、 调整计划 、 补列 计划 … ， 而 计划 总数 ( 年初 计划 + 二次 计划 + 调整计划 + 补列 计划 ) 是 用户 经常 需要 在 查询 和 报表 中 用到 的 ， 在 表 的 记录 量 很大 时 ， 有 必要 把 计划 总数 作为 1 个 独立 的 字 段 加入 到表中 。 这里 可以 采用 触发器 以 在 客户端 保持数据 的 一致性 。 
 　 　 3 . 重新 定义 实体 以 减少 外部 属性数据 或行 数据 的 开支 。 相应 的 非 规范化 类型 是 ： 
 　 　 ( 1 ) 把 1 个 实体 ( 表 ) 分割 成 2 个表 ( 把 所有 的 属性 分成 2 组 ) 。 这样 就 把 频繁 被 访问 的 数据 同较 少 被 访问 的 数据 分开 了 。 这种 方法 要求 在 每个 表中 复制 首要 关键字 。 这样 产生 的 设计 有利于 并行处理 ， 并 将 产生 列数 较 少 的 表 。 
 　 　 ( 2 ) 把 1 个 实体 ( 表 ) 分割 成 2 个表 ( 把 所有 的 行 分成 2 组 ) 。 这种 方法 适用 于 那些 将 包含 大量 数据 的 实体 ( 表 ) 。 在 应用 中常 要 保留 历史记录 ， 但是 历史记录 很少 用到 。 因此 可以 把 频繁 被 访问 的 数据 同较 少 被 访问 的 历史数据 分开 。 而且 如果 数据 行是 作为 子集 被 逻辑 工作组 ( 部门 、 销售 分区 、 地理 区域 等 ) 访问 的 ， 那么 这种 方法 也 是 很 有 好处 的 。 
 1.2 　 生成 物理 数据库 
 　 　 要 想 正确 选择 基本 物理 实现 策略 ， 必须 懂得 数据库 访问 格式 和 硬件资源 的 操作 特点 ， 主要 是 内存 和 磁盘 子系统 I / O 。 这是 一个 范围 广泛 的 话题 ， 但 以下 的 准则 可能 会 有所 帮助 。 
 　 　 1 . 与 每个 表列 相关 的 数据类型 应该 反映 数据 所 需 的 最小 存储空间 ， 特别 是 对于 被 索引 的 列 更是如此 。 比如 能 使用 smallint 类型 就 不要 用 integer 类型 ， 这样 索引 字 段 可以 被 更 快 地 读取 ， 而且 可以 在 1 个 数据 页 上 放置 更 多 的 数据 行 ， 因而 也 就 减少 了 I / O 操作 。 
 　 　 2 . 把 1 个表 放在 某个 物理 设备 上 ， 再 通过 SQL   Server 段 把 它 的 不分 簇 索引 放在 1 个 不同 的 物理 设备 上 ， 这样 能 提高 性能 。 尤其 是 系统 采用 了 多个 智能型 磁盘控制器 和 数据 分离 技术 的 情况 下 ， 这样 做 的 好处 更加 明显 。 
 　 　 3 . 用 SQL   Server 段 把 一个 频繁 使用 的 大表 分割 开 ， 并 放在 2 个 单独 的 智能型 磁盘控制器 的 数据库 设备 上 ， 这样 也 可以 提高 性能 。 因为 有 多个 磁头 在 查找 ， 所以 数据 分离 也 能 提高 性能 。 
 　 　 4 . 用 SQL   Server 段 把 文本 或 图像 列 的 数据 存放 在 1 个 单独 的 物理 设备 上 可以 提高 性能 。 1 个 专用 的 智能型 的 控制器 能 进一步提高 性能 。 
 2 　 与 SQL   Server 相关 的 硬件 系统 
 　 　 与 SQL   Server 有关 的 硬件 设计 包括 系统 处理器 、 内存 、 磁盘 子系统 和 网络 ， 这 4 个 部分 基本上 构成 了 硬件平台 ， Windows   NT 和 SQL   Server 运行 于 其 上 。 
 2.1 　 系统 处理器 ( CPU ) 
 　 　 根据 自己 的 具体 需要 确定 CPU 结构 的 过程 就是 估计 在 硬件平台 上 占用 CPU 的 工作量 的 过程 。 从 以往 的 经验 看 ， CPU 配置 最少 应是 1 个 80586 / 100 处理器 。 如果 只有 2 ～ 3 个 用户 ， 这 就 足够 了 ， 但 如果 打算 支持 更 多 的 用户 和 关键 应用 ， 推荐 采用 Pentium   Pro 或 P Ⅱ 级 CPU 。 
 2.2 　 内存 ( RAM ) 
 　 　 为 SQL   Server 方案 确定 合适 的 内存 设置 对于 实现 良好 的 性能 是 至关重要 的 。 SQL   Server 用 内存 做 过程 缓存 、 数据 和 索引 项 缓存 、 静态 服务器 开支 和 设置 开支 。 SQL   Server 最多能 利用 2GB 虚拟内存 ， 这 也 是 最大 的 设置 值 。 还有 一点 必须 考虑 的 是 Windows   NT 和 它 的 所有 相关 的 服务 也 要 占用 内存 。 
 　 　 Windows   NT 为 每个 WIN32 应用程序 提供 了 4GB 的 虚拟地址 空间 。 这个 虚拟地址 空间 由 Windows   NT 虚拟内存 管理器 ( VMM ) 映射 到 物理 内存 上 ， 在 某些 硬件平台 上 可以 达到 4GB 。 SQL   Server 应用程序 只 知道 虚拟地址 ， 所以 不能 直接 访问 物理 内存 ， 这个 访问 是 由 VMM 控制 的 。 Windows   NT 允许 产生 超出 可用 的 物理 内存 的 虚拟地址 空间 ， 这样 当给 SQL   Server 分配 的 虚拟内存 多于 可用 的 物理 内存 时 ， 会 降低 SQL   Server 的 性能 。 
 　 　 这些 地址 空间 是 专门 为 SQL   Server 系统 设置 的 ， 所以 如果 在 同一 硬件平台 上 还有 其它 软件 ( 如 文件 和 打印 共享 ， 应用程序 服务 等 ) 在 运行 ， 那么 应该 考虑 到 它们 也 占用 一部分 内存 。 一般来说 硬件平台 至少 要 配置 32MB 的 内存 ， 其中 ， Windows   NT 至少 要 占用 16MB 。 1 个 简单 的 法则 是 ， 给 每 一个 并发 的 用户 增加 100KB 的 内存 。 例如 ， 如果 有 100 个 并发 的 用户 ， 则 至少 需要 32MB + 100 用户 * 100KB ＝ 42MB 内存 ， 实际 的 使用 数量 还 需要 根据 运行 的 实际 情况 调整 。 可以 说 ， 提高 内存 是 提高 系统 性能 的 最 经济 的 途径 。 
 2.3 　 磁盘 子系统 
 　 　 设计 1 个 好 的 磁盘 I / O 系统 是 实现 良好 的 SQL   Server 方案 的 一个 很 重要 的 方面 。 这里 讨论 的 磁盘 子系统 至少 有 1 个 磁盘 控制 设备 和 1 个 或 多个 硬盘 单元 ， 还有 对 磁盘 设置 和 文件系统 的 考虑 。 智能型 SCSI - 2 磁盘控制器 或 磁盘 组 控制器 是 不错 的 选择 ， 其 特点 如下 ： 
 　 　 ( 1 ) 控制器 高速缓存 。 
 　 　 ( 2 ) 总线 主板 上 有 处理器 ， 可以 减少 对系统 CPU 的 中断 。 
 　 　 ( 3 ) 异步 读写 支持 。 
 　 　 ( 4 ) 32 位 RAID 支持 。 
 　 　 ( 5 ) 快速 SCSI — 2 驱动 。 
 　 　 ( 6 ) 超前 读 高速缓存 ( 至少 1 个 磁道 ) 。   
 3 　 检索 策略 
 　 　 在 精心 选择 了 硬件平台 ， 又 实现 了 1 个 良好 的 数据库 方案 ， 并且 具备 了 用户 需求 和 应用 方面 的 知识 后 ， 现在 应该 设计 查询 和 索引 了 。 有 2 个 方面 对于 在 SQL   Server 上 取得 良好 的 查询 和 索引 性能 是 十分 重要 的 ， 第 1 是 根据 SQL   Server 优化 器 方面 的 知识 生成 查询 和 索引 ； 第 2 是 利用 SQL   Server 的 性能 特点 ， 加强 数据 访问 操作 。 
 3.1 　 SQL   Server 优化 器 
 　 　 Microsoft   SQL   Server 数据库 内核 用 1 个 基于 费用 的 查询 优化 器 自动 优化 向 SQL 提交 的 数据 查询 操作 。 数据 操作 查询 是 指 支持 SQL 关键字 WHERE 或 HAVING 的 查询 ， 如 SELECT 、 DELETE 和 UPDATE 。 基于 费用 的 查询 优化 器 根据 统计 信息 产生 子句 的 费用 估算 。 
 　 　 了解 优化 器 数据处理 过程 的 简单 方法 是 检测 SHOWPLAN 命令 的 输出 结果 。 如果 用 基于 字符 的 工具 ( 例如 isql ) ， 可以 通过 键入 SHOW   SHOWPLAN   ON 来 得到 SHOWPLAN 命令 的 输出 。 如果 使用 图形化 查询 ， 比如 SQL   Enterprise   Manager 中 的 查询 工具 或 isql / w ， 可以 设定 配置 选项 来 提供 这一 信息 。 
 　 　 SQL   Server 的 优化 通过 3 个 阶段 完成 ： 查询 分析 、 索引 选择 、 合并 选择 。 
 　 　 1 . 查询 分析 
 　 　 在 查询 分析阶段 ， SQL   Server 优化 器 查看 每 一个 由 正规 查询 树 代表 的 子句 ， 并 判断 它 是否 能 被 优化 。 SQL   Server 一般 会 尽量 优化 那些 限制 扫描 的 子句 。 例如 ， 搜索 和 / 或 合并 子句 。 但是 不是 所有 合法 的 SQL 语法 都 可以 分成 可 优化 的 子句 ， 如 含有 SQL 不 等 关系 符 “ < > ” 的 子句 。 因为 “ < > ” 是 1 个 排斥性 的 操作符 ， 而 不是 1 个 包括 性 的 操作符 ， 所在 扫描 整个 表 之前 无法 确定 子句 的 选择 范围 会 有 多 大 。 当 1 个 关系 型 查询 中 含有 不可 优化 的 子句 时 ， 执行 计划 用表 扫描 来 访问 查询 的 这个 部分 ， 对于 查询 树中 可 优化 的 SQL   Server 子句 ， 则 由 优化 器 执行 索引 选择 。 
 　 　 2 . 索引 选择 
 　 　 对于 每个 可 优化 的 子句 ， 优化 器 都 查看 数据库系统 表 ， 以 确定 是否 有 相关 的 索引 能 用于 访问 数据 。 只有 当 索引 中 的 列 的 1 个 前缀 与 查询 子句 中 的 列 完全 匹配 时 ， 这个 索引 才 被 认为 是 有用 的 。 因为 索引 是 根据 列 的 顺序 构造 的 ， 所以 要求 匹配 是 精确 的 匹配 。 对于 分簇 索引 ， 原来 的 数据 也 是 根据 索引 列 顺序 排序 的 。 想 用 索引 的 次要 列 访问 数据 ， 就 像 想 在 电话本 中 查找 所有 姓 为 某个 姓氏 的 条目 一样 ， 排序 基本上 没有 什么 用 ， 因为 你 还是 得 查看 每 一行 以 确定 它 是否 符合条件 。 如果 1 个子 句 有 可用 的 索引 ， 那么 优化 器 就 会 为 它 确定 选择性 。 
 　 　 所以 在 设计 过程 中 ， 要 根据 查询 设计 准则 仔细检查 所有 的 查询 ， 以 查询 的 优化 特点 为 基础 设计 索引 。 
 　 　 ( 1 ) 比较 窄 的 索引 具有 比较 高 的 效率 。 对于 比较 窄 的 索引 来说 ， 每页 上能 存放 较 多 的 索引 行 ， 而且 索引 的 级别 也 较 少 。 所以 ， 缓存 中 能 放置 更 多 的 索引 页 ， 这样 也 减少 了 I / O 操作 。 
 　 　 ( 2 ) SQL   Server 优化 器能 分析 大量 的 索引 和 合并 可能性 。 所以 与 较 少 的 宽 索引 相比 ， 较 多 的 窄 索引 能 向 优化 器 提供 更 多 的 选择 。 但是 不要 保留 不必要 的 索引 ， 因为 它们 将 增加 存储 和 维护 的 开支 。 对于 复合 索引 、 组合 索引 或 多列 索引 ， SQL   Server 优化 器 只 保留 最 重要 的 列 的 分布 统计 信息 ， 这样 ， 索引 的 第 1 列 应该 有 很大 的 选择性 。 
 　 　 ( 3 ) 表上 的 索引 过多会 影响 UPDATE 、 INSERT 和 DELETE 的 性能 ， 因为 所有 的 索引 都 必须 做 相应 的 调整 。 另外 ， 所有 的 分页 操作 都 被 记录 在 日志 中 ， 这 也 会 增加 I / O 操作 。 　 　 
 　 　 ( 4 ) 对 1 个 经常 被 更新 的 列 建立 索引 ， 会 严重 影响 性能 。 
 　 　 ( 5 ) 由于 存储 开支 和 I / O 操作 方面 的 原因 ， 较 小 的 自组 索引 比较 大 的 索引 性能 更好 一些 。 但 它 的 缺点 是 要 维护 自组 的 列 。 
 　 　 ( 6 ) 尽量 分析 出 每 一个 重要 查询 的 使用 频度 ， 这样 可以 找出 使用 最多 的 索引 ， 然后 可以 先对 这些 索引 进行 适当 的 优化 。 
 　 　 ( 7 ) 查询 中 的 WHERE 子句 中 的 任何 列 都 很 可能 是 个 索引 列 ， 因为 优化 器 重点 处理 这个 子句 。 
 　 　 ( 8 ) 对 小于 1 个 范围 的 小型 表 进行 索引 是 不划算 的 ， 因为 对于 小表 来说 表 扫描 往往 更 快 而且 费用 低 。 
 　 　 ( 9 ) 与 “ ORDER   BY ” 或 “ GROUP   BY ” 一起 使用 的 列 一般 适于 做 分族 索引 。 如果 “ ORDER   BY ” 命令 中 用到 的 列上 有 分簇 索引 ， 那么 就 不会 再 生成 1 个 工作 表了 ， 因为 行 已经 排序 了 。 “ GROUP   BY ” 命令 则 一定 产生 1 个 工作 表 。 
 　 　 ( 10 ) 分簇 索引 不 应该 构造 在 经常 变化 的 列上 ， 因为 这会 引起 整行 的 移动 。 在 实现 大型 交易 处理 系统 时 ， 尤其 要 注意 这 一点 ， 因为 这些 系统 中 数据 往往 是 频繁 变化 的 。 
 　 　 3 . 合并 选择 
 　 　 当 索引 选择 结束 ， 并且 所有 的 子句 都 有 了 一个 基于 它们 的 访问 计划 的 处理 费用 时 ， 优化 器 开始 执行 合并 选择 。 合并 选择 被 用来 找出 一个 用于 合并 子句 访问 计划 的 有效 顺序 。 为了 做到 这 一点 ， 优化 器 比较 子句 的 不同 排序 ， 然后 选出 从 物理 磁盘 I / O 的 角度看 处理 费用 最低 的 合并 计划 。 因为 子句 组合 的 数量 会 随着 查询 的 复杂度 极快 地 增长 ， SQL   Server 查询 优化 器 使用 树 剪枝 技术 来 尽量减少 这些 比较 所 带来 的 开支 。 当 这个 合并 选择 阶段 结束 时 ， SQL   Server 查询 优化 器 已经 生成 了 1 个 基于 费用 的 查询 执行 计划 ， 这个 计划 充分利用 了 可用 的 索引 ， 并 以 最小 的 系统 开支 和 良好 的 执行 性能 访问 原来 的 数据 。 
 3.2 　 高效 的 查询 选择 
 　 　 从 以上 查询 优化 的 3 个 阶段 不难看出 ， 设计 出 物理 I / O 和 逻辑 I / O 最少 的 方案 并 掌握 好 处理器 时间 和 I / O 时间 的 平衡 ， 是 高效 查询 设计 的 主要 目标 。 也就是说 ， 希望 设计 出 这样 的 查询 ： 充分利用 索引 、 磁盘 读写 最少 、 最 高效 地 利用 了 内存 和 CPU 资源 。 
 　 　 以下 建议 是从 SQL   Server 优化 器 的 优化 策略 中 总结 出来 的 ， 对于 设计 高效 的 查询 是 很 有 帮助 的 。 
 　 　 1 . 如果 有 独特 的 索引 ， 那么 带有 “ ＝ ” 操作符 的 WHERE 子句 性能 最好 ， 其次 是 封闭 的 区间 ( 范围 ) ， 再其次 是 开放 的 区间 。 
 　 　 2 . 从 数据库 访问 的 角度看 ， 含有 不 连续 连接词 ( OR 和 IN ) 的 WHERE 子句 一般来说 性能 不会 太好 。 所以 ， 优化 器 可能 会 采用 R 策略 ， 这种 策略 会 生成 1 个 工作 表 ， 其中 含有 每个 可能 匹配 的 执行 的 标识符 ， 优化 器 把 这些 行 标志符 ( 页 号 和 行号 ) 看做 是 指向 1 个表中 匹配 的 行 的 “ 动态 索引 ” 。 优化 器 只 需 扫描 工作 表 ， 取出 每 一个 行 标志符 ， 再 从 数据表 中 取得 相应 的 行 ， 所以 R 策略 的 代价 是 生成 工作 表 。 
 　 　 3 . 包含 NOT 、 < > 、 或 ! 　 = 的 WHERE 子句 对于 优化 器 的 索引 选择 来说 没有 什么 用处 。 因为 这样 的 子句 是 排斥性 的 ， 而 不是 包括 性 的 ， 所以 在 扫描 整个 原来 数据表 之前 无法 确定 子句 的 选择性 。 
 　 　 4 . 限制 数据 转换 和 串 操作 ， 优化 器 一般 不会 根据 WHERE 子句 中 的 表达式 和 数据 转换 式 生成 索引 选择 。 例如 ： 
 　 　 paycheck   *   12 > 36000   or   substring ( lastname , 1 , 1 ) = “ L ” 
 　 　 如果 该表 建立 了 针对 paycheck 和 lastname 的 索引 ， 就 不能 利用 索引 进行 优化 ， 可以 改写 上面 的 条件 表达式 为 ： 
 　 　 paycheck < 36000 / 12   or   lastname   like   “ L% ” 
 　 　 5 . WHERE 子句 中 的 本地 变量 被 认为 是 不 被 优化 器 知道 和 考虑 的 ， 例外 的 情况 是 定义 为 储备 过程 输入 参数 的 变量 。 
 　 　 6 . 如果 没有 包含 合并 子句 的 索引 ， 那么 优化 器 构造 1 个 工作 表以 存放 合并 中 最小 的 表中 的 行 。 然后 再 在 这个 表上 构造 1 个分 簇 索引 以 完成 一个 高效 的 合并 。 这种 作法 的 代价 是 工作 表 的 生成 和 随后 的 分族 索引 的 生成 ， 这个 过程 叫 REFORMATTING 。 　 　 所以 应该 注意 RAM 中 或 磁盘 上 的 数据库 tempdb 的 大小 ( 除了 SELECT   INTO 语句 ) 。 另外 ， 如果 这些 类型 的 操作 是 很 常见 的 ， 那么 把 tempdb 放在 RAM 中 对于 提高 性能 是 很 有 好处 的 。   
 4 　 性能 优化 的 其他 考虑 
 　 　 上面 列出 了 影响 SQL   Server 的 一些 主要 因素 ， 实际上 远不止 这些 。 操作系统 的 影响 也 很大 ， 在 Windows   NT 下 ， 文件系统 的 选择 、 网络协议 、 开启 的 服务 、 SQL   Server 的 优先级 等 选项 也 不同 程度 上 影响 了 SQL   Server 的 性能 。 
 　 　 影响 性能 的 因素 是 如此 的 多 ， 而 应用 又 各不相同 ， 找出 1 个 通用 的 优化 方案 是 不 现实 的 ， 在 系统 开发 和 维护 的 过程 中 必须 针对 运行 的 情况 ， 不断 加以 调整 。 事实上 ， 绝大部分 的 优化 和 调整 工作 是 在 与 客户端 独立 的 服务器上进行 的 ， 因此 也 是 现实 可行 的 。 
 作者 单位 : 上海交通大学 网络信息中心 ( 200030 ) 
 参考文献 
 　 1 　 Schneider   R   D 著 ， 李小 坚译 . 规划 与 建立 高性能 的 SQL   Server6.5 数据库 . 北京 ： 机械 工业 出版社 ， 1997 
 ( 收稿 日期 ： 1998 - 09 - 11 ) 
