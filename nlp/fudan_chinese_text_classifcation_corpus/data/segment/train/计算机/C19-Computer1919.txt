微型机 与 应用 
 MICROCOMPUTER   &   ITS   APPLICATIONS 
 2000 　 Vol.19 　 No.6 　 P.10 - 12 
 
 
 
 
 面向对象 程序设计 语言 C++ 中 的 多态性 
 蓝雯飞 
 摘要 ： 面向对象 程序设计 语言 C++ 中 多态性 的 形式 、 特征 及其 在 程序设计 中 的 应用 。 
 关键词 ： C++ 语言   多态性   类   虚 函数 
 　 　 C++ 是 以 C语言 为 基础 ， 支持 数据抽象 和 面向对象 的 程序设计 语言 。 C++ 对 C语言 的 扩充 部分 汲取 了 许多 著名 语言 中 最 优秀 的 特征 ， 如 从 Algo168 中 吸取 了 操作符 重载 机制 等 。 由于 C++ 语言 具有 与 C语言 一样 的 高 执行 效率 ， 并 容易 被 熟悉 C语言 的 软件 人员 接受 ， 因而 很快 得以 流行 。 但 这种 混合型 面向对象 的 程序设计 语言 是 一种 新 的 程序设计 语言 ， 人们 对 它 许多 潜在 的 性能 ( 封装 、 继承 、 多态 等 ) 还 没有 充分 地 理解 和 应用 ， 没有 充分发挥 其 优势 。 多态性 是 面向对象 系统 的 重要 概念 之一 ， 它 指 的 是 同样 的 消息 能 被 发送到 父类 的 对象 和 它 的 子类 的 对象 。 本文 重点 讨论 多态性 在 程序设计 中 的 应用 。 
 1     多态性 的 实现 形式 
 　 　 从 广义 上 说 ， 多态性 是 指 一段 程序 能够 处理 多种类型 对象 的 能力 。 在 C++ 语言 中 ， 这种 多态性 可以 通过 强制 多态 、 重载 多态 、 类型 参数 化 多态 、 包含 多态 4 种 形式 来 实现 。 类型 参数 化 多态 和 包含 多态 统称 为 一般 多态性 ， 用来 系统地 刻画 语义上 相关 的 一组 类型 。 重载 多态 和 强制 多态 统称 为 特殊 多态性 ， 用来 刻画 语义上 无 关联 的 类型 间 的 关系 。 
 　 　 包含 多态 是 指 通过 子 类型化 ， 1 个 程序段 既 能 处理 类型 T 的 对象 ， 也 能够 处理 类型 T 的 子 类型 S 的 对象 ， 该 程序段 称为 多态 程序段 。 公有 继承 能够 实现 子 类型 。 在 包含 多态 中 ， 1 个 对象 可以 被 看作 属于 不同 的 类 ， 其间 包含 关系 的 存在 意味着 公共 结构 的 存在 。 包含 多态 在 不少 语言 中 存在 ， 如 整数 类型 中 的 子集 构成 1 个子 类型 。 每 一个 子 类型 中 的 对象 可以 被 用 在 高 一级 的 类型 中 ， 高 一级 类型 中 的 所有 操作 可 用于 下 一级 的 对象 。 在 C++ 中 公有 继承 关系 是 一种 包含 多态 ， 每 一个 类 可以 直接 公有 继承 父类 或 多个 父类 ， 如 语句 class   D  public   P1 ， public   P2 { … … } ； 表示 类 D 分别 是 类 P1 和 类 P2 的 子 类型 。 
 　 　 类型 参数 化 多态 是 指当 1 个 函数 ( 类 ) 统一 地 对 若干 类型 参数 操作 时 ， 这些 类型 表现 出 某些 公共 的 语义 特性 ， 而 该 函数 ( 类 ) 就是 用来 描述 该 特性 的 。 在 类型 参数 化 多态 中 ， 1 个 多 态函数 ( 类 ) 必须 至少 带有 1 个 类型 参数 ， 该 类型 参数 确定 函数 ( 类 ) 在 每次 执行 时 操作数 的 类型 。 这种 函数 ( 类 ) 也 称类 属 函数 ( 类 ) 。 类型 参数 化 多态 的 应用 较 广泛 ， 被 称为 最纯 的 多态 。 
 　 　 重载 是 指用 同一个 名字 命名 不同 的 函数 或 操作符 。 函数 重载 是 C++ 对 一般 程序设计 语言 中 操作符 重载 机制 的 扩充 ， 它 可 使 具有 相同 或 相近 含义 的 函数 用 相同 的 名字 ， 只要 其 参数 的 个数 、 次序 或 类型 不 一样 即可 。 例如 ： 
 　 　 int   min ( int   x ， int   y ) ； 　 　 　 　 　 ／ ／ 求 2 个 整数 的 最小 数 
 　 　 int   min ( int   x ， int   y ， int   z ) ； 　 ／ ／ 求 3 个 整数 的 最小 数 
 　 　 int   min （ int   n ， int   a ［ ］ ) ； 　 　 ／ ／ 求 n 个 整数 的 最小 数 
 　 　 当 用户 要求 增加 比较 2 个 字符串 大小 的 功能 时 ， 只 需 增加 ： 
 char * min ( char * ， char * ) ； 
 而 原来 如何 使用 这组 函数 的 逻辑 不需 改变 ， min 的 功能扩充 很 容易 ， 也就是说 维护 比较 容易 ， 同时 也 提高 了 程序 的 可 理解 性 ， “ min ” 表示 求 最小值 的 函数 。 
 　 　 强制 是 指 将 一种 类型 的 值 转换成 另 一种 类型 的 值 进行 的 语义 操作 ， 从而 防止 类型 错误 。 类型转换 可以 是 隐式 的 ， 在 编译 时 完成 ， 如 语句 D ＝ I 把 整型 变量 转换 为 实型 ； 也 可以 是 显式 的 ， 可 在 动态 运行 时 完成 。 
 　 　 从总体上 来说 ， 一般 多态性 是 真正 的 多态性 ； 特殊 多态性 只是 表面 的 多态性 。 因为 重载 只 允许 某 一个 符号 有 多种类型 ， 而 它 所 代表 的 值 分别 具有 不同 的 、 不相 兼容 的 类型 。 类似 地 ， 隐式 类型转换 也 不是 真正 的 多态 ， 因为 在 操作 开始 前 ， 各值 必须 转换 为 要求 的 类型 ， 而 输出 类型 也 与 输入 类型 无关 。 相比之下 ， 子类 与 继承 却是 真正 的 多态 。 类型 参数 化 多态 也 是 一种 纯正 的 多态 ， 同一 对象 或 函数 在 不同 的 类型 上下文 中 统一 地 使用 而 不 需 采用 隐式 类型转换 、 运行 时 检测 或 其它 各种 限制 。 
 2     多态性 应用 
 2.1   包含 多态 
 　 　 C++ 中 采用 虚拟 函数 实现 包含 多态 ， 虚拟 函数 为 C++ 提供 了 更为 灵活 的 多态 机制 ， 这种 多态性 在 程序运行 时 才能 确定 ， 因此 虚拟 函数 是 多态性 的 精华 ， 至少 含有 一个 虚拟 函数 的 类 称为 多态 类 。 包含 多态 在 程序设计 中 使用 十分 频繁 。 
 　 　 派生类 继承 基类 的 所有 操作 ， 或者说 ， 基类 的 操作 能 被 用于 操作 派生类 的 对象 ， 当 基类 的 操作 不能 适应 派生类 时 ， 派生类 需 重载 基类 的 操作 ， 见 下例 中 的 void   circle : : showarea ( ) 。 
 　 　 ＃ include   ＜ iostream . h ＞ 
 　 　 class   point     ／ ／ 屏幕 上 的 点类 
    ｛ int   x ， y ； 
 　 　 　 public ； 
 　 　 　 point ( int   x1 ， int   y1 ) 
 　 　 ｛ x ＝ x1 ； y ＝ y1 ； ｝ 
 　 　 　 void   showarea ( ) 
 　 　 ｛ cout ＜ ＜ ″ Area   of   point   is ： ″ ＜ ＜ 0.0 ＜ ＜ endl ； ｝ 
 　 　 } ； 
 　 　 class   circle ： public   point ／ ／ 圆类 
 　 　 ｛ int   radius ； 
 　 　 　 public ： 
 　 　 　 circle ( int   x ， int   y ， int   r ) ： point ( x ， y ) {   radius ＝ r ； } 
 　 　 void   showarea ( ) ｛ cout ＜ ＜ ″ Area   of   circle   is ： ″ ＜ ＜ 3.14 
 　 　 　 * radius * radius ＜ ＜ endl ； } 
 　 　 } ； 
 　 　 void   disparea ( const   point * p )   ／ ／ 多态 程序段 
 　 　 ｛ p － ＞ showarea ( ) ； ｝ 
 　 　 void   main ( ) 
 　 　 ｛ circle   c1 ( 1 ， 1 ， 1 ) ； disparea ( ＆ c1 ) ； 
 　 　 ｝ 
 　 　 程序 的 运行 结果 为 0.0 ( 正确 结果 应为 3.14 ) ， 出错 的 原因 是 ： 表达式 p － ＞ showarea ( ) 中 的 函数调用 在 编译 时 被 束定 到 函数 体上 ， 使得 这个 表达式 中 的 函数调用 执行 point 类 的 showarea ( ) 。 为此 ， 当 程序员 在 实现 一个 派生类 而 变动 了 基类 中 的 操作 实现 时 ， C++ 提供 的 虚 函数 机制 可 将 这种 变动 告诉 编译器 ， 即将 关键字 virtual 放在 类 point 中该 函数 的 函数 说明 之前 ( virtual   void   showarea ( ) ) ， 程序 其它 部分 保持 不变 ( circle ： ： showarea ( ) 自动 地 成为 虚 函数 ) ， 编译器 就 不会 对 函数调用 p － ＞ showarea ( ) 进行 静态 束定 ( 在 编译 ／ 连接 时 进行 的 束定 ) 而 产生 有关 的 代码 ， 使 函数调用 与 它 所应 执行 的 代码 的 束定 工作 在 程序运行 时 进行 ， 这样 上述 程序 的 运行 结果 即为 3.14 。 在 程序运行 时 进行 的 束定 被 称为 动态 束定 。 
 　 　 利用 虚 函数 ， 可 在 基类 和 派生类 中 使用 相同 的 函数 名 定义 函数 的 不同 实现 ， 从而 实现 “ 一个 接口 ， 多种 方式 ” 。 当 用 基类 指针 或 引用 对 虚 函数 进行 访问 时 ， 软件系统 将 根据 运行 时 指针 或 引用 所 指向 或 引用 的 实际 对象 来 确定 调用 对象 所在 类 的 虚 函数 版本 。 
 　 　 C++ 语言 还 增加 了 纯 的 虚 函数 机制 用来 更好 地 设计 包含 多态性 。 对于 如图 1 ( a ) 所示 结构 的 类 层次 ， 假如 每个 类中 都 有 一个 函数 “ void   display ( void ) ； ” ， 那么 ， 怎样 对 它们 按 多态性 进行 统一 处理 呢 ？ 对 这类 问题 应先 设计 一个 抽象 的 类 ， 使 它 成为 所有 类 的 祖先 类 ， 如图 1 ( b ) 所示 。 设置 类 A 的 目的 是 由 它 说明 统一 使用 该 层次 中 的 display ( ) 函数 的 方法 ( 赋值 兼容 规则 从 语法 上 保证 了 A 的 子孙 类 可 按 A 说明 的 方式 使用 display ( ) 函数 ； 多态性 则 从 语义上 保证 了 在 执行 时 ， 根据 实际 的 对象 访问 相应 对象 类中 的 display ( ) 函数 ) 。 
 
 图 1     多态性 结构 层次 
 　 　 为了 保证 在 类 A 中 设置 的 display ( ) 函数 是 抽象 动作 ， 并 能 说明 类 A 是 一个 抽象 的 类 ， 在 C++ 中 ， 可用 纯 的 虚 函数 语言 机制 在 类 A 中 声明 1 个 成员 函数 “ virtual   void   display ( void ) ＝ 0 ； ” 。 请 注意 ， 在 类 A 的 子孙 类中 要么 给出 display ( ) 的 定义 ， 要么 重新 将 该 函数 声明 为 纯 的 。 
 从 上面 的 分析 可以 看出 ， 类 A 的 设计 尽管 是 用 继承性 语法 表达 的 ， 但 它 的 主要 目的 不是 为 代码 共享 而 设计 的 ， 而是 为了 提高 多态性 而 设计 的 ， 它 是 另 一个 维度 的 抽象 。 
 2.2   类型 参数 化 多态 
 　 　 参数 化 多态 又称 非 受限 类 属 多态 ， 即将 类型 作为 函数 或类 的 参数 ， 避免 了 为 各种 不同 的 数据类型 编写 不同 的 函数 或类 ， 减轻 了 设计者 负担 ， 提高 了 程序设计 的 灵活性 。 
 　 　 模板 是 C++ 实现 参数 化 多态性 的 工具 ， 分为 函数 模板 和 类 模板 二种 。 
 　 　 类 模板 中 的 成员 函数 均 为 函数 模板 ， 因此 函数 模板 是 为 类 模板 服务 的 。 类 模板 在 表示 数组 、 表 、 矩阵 等 类 数据结构 时 ， 显得 特别 重要 ， 因为 这些 数据结构 的 表示 和 算法 的 选择 不受 其 所 包含 的 元素 的 类型 的 影响 。 下面 是 一个 通用 数组 类 模板 的 定义 。 
 　 　 template   ＜ class   T ， int   N ＞ 
 　 　 class   array 
 　 　 ｛ T   elem ［ N ］ ； 
 　 　 　 public ： 
 　 　 　 array ( ) ｛ for ( int       j ＝ 0 ； j ＜ N ； j ++ ) elem ［ j ］ ＝ 0 ； ｝ 
 　 　 　 T ＆   operator ［ ］ ( int   index ) ｛ return   elem ［ index ］ ； ｝ 
 　 　 void   modi ( int   index ， T   value ) ｛ elem ［ index ］ ＝ value ； ｝ 
 　 　 ｝ ； 
 　 　 其中 ， T 是 类型 参数 ， N 是 常量 参数 。 T 和 N 的 实际 值 是 在 生成 具体 类 实例 时 指定 的 。 类 模板 的 ＜   ＞ 可以 包括 任意 个 类型 参数 或 常量 参数 ， 但 至少 应有 一个 参数 。 在 类 模板 定义 中 ， 可 在 程序 中 通常 使用 类型 指定 的 任何 地方 使用 类型 参数 ， 可 在 通常 使用 特定 类型 常量 表达式 的 任何 地方 使用 常量 参数 。 
 　 　 成员 函数 模板 可 放在 类 模板 中 定义 ， 也 可 放在 类外 定义 ， 例如 ： 
 　 　 template   ＜ class   T ， int   N ＞ 
 　 　 T ＆   array ＜ T ， N ＞ ： ： operator ［ ］ ( int       index ) ｛ return   elem ［ index ］ ； ｝ 
 　 　 当由类 模板 生成 一个 特定 的 类时 ， 必须 指定 参数 所 代表 的 类型 ( 值 ) 。 例如 ， 1 个 元素 类型 为 int 、 长度 为 100 的 数组 类 使用 类型 表达式 array ＜ int ， 100 ＞ 来 表示 ， 这个 类型 表达式 被 用于 说明 数组 类 对象 。 例如 ： 
 　 　 array ＜ int ， 100 ＞   a ：   ／ ／ 生成 特定 类 的 对象 a 
 　 　 a . modi ( 1 ， 34 ) ； 　 　 　 ／ ／ 对象 a 访问 成员 函数 
 　 　 类 模板 一旦 生成 了 对象 和 指定 了 参数表 中 的 类型 ， 编译器 在 以后 访问 数据 成员 和 调用 成员 函数 时 完全 强制 为 这些 类型 。 
 　 　 在 C++ 中 可以 重载 定义 多个 同名 的 函数 模板 ， 也 可以 将 1 个 函数 模板 与 1 个 同名 函数 进行 重载 定义 。 例如 ： 
 　 　 template   ＜ class   T ＞   T   min ( T   a ， T   b ) ｛ return   a ＜ b ﹖ a ： b ； ｝ 
 　 　 template   ＜ class   T ＞ 
 　 　 T   min ( T   a ， T   b ， T   c ) ｛ T   x ＝ min ( a ， b ) ； return   min ( x ， c ) ； ｝ 
 　 　 int   min ( int   a ， int   b ) ［ return   a ＜ b ﹖ a ： b ； ｝ 
 　 　 调用 min ( 3 ， 7 ) ， 则 调用 第 3 个 函数 ； 调用 min ( 3.8 . 5.9 ) ， 编译器 将 根据 带 2 个 参数 的 模板 生成 新 函数 min ( double ， double ) ； 调用 min ( 4 ， 90 ， 76 ) ， 则 编译器 根据 带 3 个 参数 的 模板 生成 新 函数 min ( int ， int ， int ) ； 而 调用 min ( 56.3 ， 48 ， 71 ) ， 编译 将 给出 错误信息 ， 说明 无法 从 上面 的 模板 中 生成 函数 min ( double ， double ， double ) ， 因为 编译器 在 类型 推导 时 ， 不 存在 类型 强制 。 
 　 　 模板 描述 了 1 组 函数 或 1 组类 ， 它 主要 用于 避免 程序员 进行 重复 的 编码 工作 ， 大大简化 、 方便 了 面向对象 的 程序设计 。 
 2.3   重载 多态 
 　 　 重载 是 多态性 的 最简 形式 ， 而且 把 更 大 的 灵活性 和 扩展性 添加 到 程序设计 语言 中 ， 它 分成 操作符 重载 和 函数 重载 。 
 　 　 C++ 允许 为 类重 定义 已有 操作符 的 语义 ， 使 系统 预定 义 的 操作符 可 操作 类 对象 。 C++ 语言 的 一个 非常 有 说服力 的 例子 是 count 对象 的 插入 操作 ( ＜ ＜ ) 。 由于 其类 中 定义 了 对位 左移 操作符 “ ＜ ＜ ” 进行 重载 的 函数 ， 使 C++ 的 输出 可 按同 一种 方式 进行 ， 学习 起来 非常容易 。 并且 ， 增加 一个 使 其能 输出 复数 类 的 功能 ( 扩充 ) 也 很 简单 ， 不必 破坏 原 输出 逻辑 。 
 　 　 C++ 规定 将 操作符 重载 为 函数 的 形式 ， 既 可以 重载 为类 的 成员 函数 ， 也 可以 重载 为类 的 友员 函数 。 用友 员 重载 操作符 的 函数 也 称 操作符 函数 ， 它 与 用 成员 函数 重载 操作符 的 函数 不同 ， 后者 本身 是 类 中 成员 函数 ， 而 它 是 类 的 友员 函数 ， 是 独立 于类 的 一般 函数 。 注意 重载 操作符 时 ， 不能 改变 它们 的 优先级 ， 不能 改变 这些 操作符 所 需 操作数 的 个数 。 
 　 　 重 定义 已有 的 函数 称为 函数 重载 。 在 C++ 中 既 允许 重载 一般 函数 ， 也 允许 重载 类 的 成员 函数 。 如对 构造函数 进行 重载 定义 ， 可 使 程序 有 几种 不同 的 途径 对类 对象 进行 初始化 。 还 允许 派生类 的 成员 函数 重载 基类 的 成员 函数 ， 虚 函数 就 属于 这种 形式 的 重载 ， 但 它 是 一种 动态 的 重载 方式 ， 即 所谓 的 “ 动态 联编 ( 束定 ) ” 。 
 2.4   强制 多态 
 　 　 强制 也 称 类型转换 。 C++ 语言 定义 了 基本 数据类型 之间 的 转换规则 ， 即 ： 
 　 　 char － ＞ short － ＞ int － ＞ unsigned － ＞ long － ＞ unsigned   long － ＞ float － ＞ double － ＞ long   double 
 　 　 赋值 操作 是 个 特例 ， 上述 原则 不再 适用 。 当 赋值 操作符 的 右 操作数 的 类型 与 左 操作数 的 类型 不 同时 ， 右 操作数 的 值 被 转换 为 左 操作数 的 类型 的 值 ， 然后 将 转换 后 的 值 赋值 给 左 操作数 。 
 　 　 程序员 可以 在 表达式 中 使用 3 种 强制 类型转换 表达式 ： ① static ＿ cast ＜ T ＞ ( E ) ； ② T ( E ) ； ③ ( T ) E 。 其中 任意 一种 都 可 改变 编译器 所 使用 的 规则 ， 以便 按 自己 的 意愿 进行 所 需 的 类型 强制 。 其中 E   代表 一个 运算 表达式 ， T 代表 一个 类型 表达式 。 第三种 表达形式 是 C语言 中 所 使用 的 风格 ， 在 C++ 中 ， 建议 不要 再 使用 这种 形式 ， 应 选择 使用 第一种 形式 。 例如 ， 设 对象 f 的 类型 为 double ， 且 其值 为 3.14 。 则 表达式 static ＿ cast ＜ int ＞ ( f ) 的 值 为 3 ， 类型 为 int 。 
 　 　 通过 构造函数 进行 类 类型 与 其它 数据类型 之间 的 转换 必须 有 一个 前提 ， 那 就是 此类 一定 要 有 一个 只带 1 个 非 缺省 参数 的 构造函数 ， 通过 构造函数 进行 类 类型 的 转换 只能 从 参数 类型 向类 类型转换 ， 而 想 将 一个 类 类型 向 其它 类型转换 是 办不到 的 。 类 类型转换 函数 就是 专门 用来 将类 类型 向 其它 本 类型转换 的 ， 它 是 一种 类似 显式 类型转换 的 机制 。 转换 函数 的 设计 有 以下几点 要 特别 注意 ： ① 转换 函数 必须 是 类 的 成员 函数 ； ② 转换 函数 不 可以 指定 其 返回值 类型 ； ③ 转换 函数 其 参数 行 不 可以 有 任何 参数 。 
 　 　 强制 使 类型 检查 复杂化 ， 尤其 在 允许 重载 的 情况 下 ， 导致 无法 消解 的 二义性 ， 在 程序设计 时要 注意 避免 由于 强制 带来 的 二义性 。 
 蓝雯飞 （ 武汉 中南 民族 学院 计算机科学 系 　 430074 ） 
 参考文献 
 1 ， 蓝雯飞 ． C++ 中 的 多态性 及其 应用 ． 计算机 时代 ， 1998 ； （ 7 ） 
 2 ， 蓝雯飞 ． C++ 程序设计 中 的 模板 技术 ． 计算机 时代 ， 1999 ； （ 2 ） 
 3 ， 蓝雯飞 ． 用 C++ 中 的 子 类型 实现 软件 再用 之 探讨 ． 计算机   系统 应用 ， 1999 ； （ 6 ） 
 4 ， 肖基毅 ． 面向对象 程序设计 中 的 多态性 研究 ． 微 计算机 应   用 ， 1999 ； 20 （ 3 ） 
 5 ， 王斌 君 ， 葛玮 ， 王靖亚 ． C++ 语言 与 软件 的 多态性 ． 计算   机工程 与 应用 ， 1998 ； 34 （ 10 ） 
 收稿 日期 ： 1999 － 12 － 20 
