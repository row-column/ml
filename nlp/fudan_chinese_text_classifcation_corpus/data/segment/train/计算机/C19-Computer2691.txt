软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年 　 第 10 卷 　 第 11 期 　 Vol.10 　 No.11 　 1999 
 
 
 
 非 完全 互连 同构 系统 上 的 静态 任务调度 
 章军 　 章立生 　 韩 承德 
 　 　 摘要 　 在 分布式 内存 多处理机 DMM ( distributed   memory   multiprocessor ) 系统 中 ， 不同 处理机 上 运行 的 任务 之间 的 通信 开销 仍然 很大 ， 有时 甚至 抵消 了 多处理机 并行 所 带来 的 好处 . 为了 使 并行程序 在 DMM 系统 上能 得以 高效 的 执行 ， 必须 采用 合理 的 调度 技术 将 任务分配 给 处理机 . 文章 首先 分别 给出 了 任务调度 系统 中 的 任务模型 、 处理机 模型 以及 调度 问题 的 形式化 描述 ， 然后 在 此基础 上 研究 了 任务调度 中 3 个 最 重要 的 问题 ， 即 ( 1 )   如何 顺序 选择 参与 调度 的 任务 ， ( 2 )   如何 选择 路由 ， ( 3 )   如何 分配任务 给 处理机 . 其中 ， 路由 选择 是 按 存储转发 寻径 与 虫蚀 寻径 两种 不同 的 方式 来 讨论 的 . 最后 ， 根据上述 3 个 问题 的 解决 策略 ， 构造 了 一个 非 完全 互连 同构 系统 上 的 静态 任务调度 算法 . 
 　 　   关键词 　 静态 任务调度 ， 任务模型 ， 处理机 模型 ， 存储转发 寻径 ， 虫蚀 寻径 . 
 　 　 中图法 分类号 　 TP338 
 Static   Task   Scheduling   for   Incompletely   Interconnected   Homogeneous   Systems 
 ZHANG   Jun   ZHANG   Li - sheng   HAN   Cheng - de 
 ( High   Performance   Computing   Center   Institute   of   Computing   TechnologyThe   Chinese   Academy   of   Sciences   Beijing   100080 ) 
 　 　 Abstract 　   In   the   distributed   memory   multiprocessor   ( DMM )   systems ,   communication   overhead ,   involved   among   tasks   run   on   different   processors ,   is   still   large   which   even   offsets   the   advantages   brought   by   multiprocessor   parallelism .   In   order   to   execute   a   parallel   application   efficiently ,   it   is   necessary   to   choose   an   appropriate   scheduling   technology   to   allocate   processors   to   tasks .   In   this   paper ,   formal   description   of   general   scheduling   system   including   task   model ,   processor   model   and   schedule   problem   is   presented .   Three   most   important   problems ,   concerning   schedule   in   incompletely   interconnected   homogeneous   systems ,   are   studied ,   which   are :   ( 1 )   How   to   choose   scheduling   tasks   in   sequence ,   ( 2 )   How   to   choose   a   route ,   ( 3 )   How   to   allocate   processors   to   tasks .   In   addition ,   the   problem   on   how   to   choose   a   route   is   studied   according   to   store - and - forward   and   wormhole   routing   respectively .   In   the   end ,   a   static   scheduling   algorithm   for   incompletely   interconnected   homogeneous   systems   is   constructed   according   to   the   solutions   to   the   above   three   problems . 
 　 　 Key   words 　 Static   task   scheduling ,   task   model ,   processor   model ,   store － and － forward   routing ,   wormhole   routing . 
 　 　 在 分布式 内存 多处理机 ( distributed   memory   multiprocesor , 简称 DMM ) 系统 中 ， 所有 处理机 经 网络 互连 起来 ， 任意 两台 处理机 之间 的 通信 都 必须 经过 互连 网络 . 近 30 年来 ， 即使 通信 技术 的 发展 突飞猛进 ， 但 与 处理机 的 运算 速度 相比 ， 通信 开销 仍然 很大 ， 是 制约 消息传递 型 系统 性能 进一步提高 的 瓶颈 . 
 　 　 为了 使 并行程序 在 DMM 系统 上能 得以 高效 的 执行 ， 必须 采用 合理 的 调度 技术 将 不同 的 任务 在 适当 的 时刻 分配 给 处理机 去 执行 . 对于 静态 任务调度 而言 ， 处理机 的 任务分配 是 在 程序执行 之前 完成 的 . 有关 任务 的 计算 量 、 任务 之间 的 依赖 关系 及 通信 情况 、 每个 处理机 的 处理 能力 以及 它们 之间 的 互连 拓扑 在 编译 时 假定 是 已知 的 . 另外 ， 任务 一旦 分配 给 某个 处理机 ， 便 只能 在 该 处理机 上 执行 ， 即 任务 的 执行 是非 抢占 式 的 ( nonpreemptive ) . 一般说来 ， 静态 调度 的 目标 是 最小化 整个 应用 的 执行 时间 . 
 　 　 本文 考虑 的 问题 要求 处理机 系统 是 同构 的 ， 对 处理机 的 个数 以及 处理机 之间 是否 完全 互连 不 作 限制 . 另外 ， 在 任务调度 时 ， 不 允许 任务 复制 . 本文 第 1 节 给出 了 任务调度 系统 模型 ， 它 包含 任务模型 与 处理机 模型 . 第 2 节 给出 了 调度 问题 的 形式化 描述 . 第 3 节 讨论 了 非 完全 互连 同构 系统 上 任务调度 中 的 3 个 最 重要 问题 的 解决 策略 , 并 构造 了 相应 的 调度 算法 ， 这 3 个 问题 分别 是 ： ( 1 )   如何 顺序 选择 参与 调度 的 任务 ， ( 2 )   如何 选择 路由 ， ( 3 )   如何 将 处理机 分配 给 任务 . 其中 ， 路由 选择 是 按 存储转发 寻径 与 虫蚀 寻径 两种 不同 的 方式 来 讨论 的 . 
 1 　 调度 系统 模型 的 形式化 描述 
 　 　 调度 系统 模型 包含 任务模型 与 处理机 模型 . 下面 分别 给出 任务模型 与 处理机 模型 的 形式化 描述 . 
 　 　 通常 ， 任务 依赖图 是 经 程序 划分 后 获得 的 ， 可用 图 理论 中 的 有 向 无 环图 ( directed   acyclic   graph ， 简称 DAG ) 来 表示 ， 任一 有 向 无 环图 ( DAG ) 可用 四元组 TG = ( V , E , A , D ) 来 定义 . 其中 : 
 　 　 ( 1 )   V = ［ vi ］ 表示 任务 图中 结点 ( 任务 图中 的 结点 即 指 任务 , 故 在 本文 中 有时 结点 与 任务 混用 ) 的 集合 ， vi 表示 第 i 个 任务 , | V | 表示 图中 结点 数目 ; 
 　 　 ( 2 )   E = ［ ei , j ］ 表示 任务 图中边 ( 任务 图中 的 边 即 指 消息 , 故 在 本文 中 有时 与 消息 混用 ) 的 集合 ， ei , j 表示 由 vi 指向 vj 的 有 向 边 ， | E | 表示 图中边 的 数目 ; 
 　 　 ( 3 )   A = ［ ai ］ 表示 任务 的 计算 量 集合 ， ai 表示 任务 vi 的 计算 量 ; 
 　 　 ( 4 )   D = ［ di , j ］ 表示 任务 之间 通信 的 数据量 集合 ， di , j 表示 任务 vi 发送给 任务 vj 的 数据量 . 
 　 　 为了 表示 图 TG 中 任务 之间 的 互相 依赖 情况 ， 下面 给出 两个 优先 ( precedence ) 关系 : 及 → . 
 　 　 定义 1.1 .   在 图 TG 上 ， 如果 vi 是 vj 的 父 结点 （ 或 vj 是 vi 的 子 结点 ) ， 则 有 vivj ； 如果 vi 是 vj 的 祖先 结点 ( 或 vj 是 vi 的 子孙 结点 ) ， 则 有 vi → vj . 
 　 　 由 上面 的 定义 可知 ， 关系 → 具有 传递性 ， 而 关系 不 具有 传递性 . ei , j ∈ E 等价 于 vivj . 在 图 1 ( a ) 中 ， 有 v3v6 ， v2 → v8 等 满足 上述 两个 关系 . 
 
 ( a )   有 向 无 环图 ( DAG ) 
 
 ( b )   处理机 模型 
 
 ( c )   执行 结果 
 图 1   调度 系统 模型 
 　 　 由 任务 vi 的 父 结点 与 祖先 结点 构成 的 集合 分别 记为 PARENT ( vi ) 与 PRED ( vi ) ； 由 任务 vi 的 子 结点 与 子孙 结点 构成 的 集合 分别 记为 CHILD ( vi ) 与 SUCC ( vi ) . 在 图 1 ( a ) 中 ， PARENT ( v6 ) = ｛ v1 , v3 ｝ ， CHILD ( v3 ) = ｛ v6 , v7 ｝ , PRED ( v8 ) = ｛ v1 , v2 , v3 , v5 , v6 ｝ ， SUCC ( v5 ) = ｛ v8 , v9 , v10 ｝ . 
 　 　 定义 1.2 .   对于 任务 vi ， 若 PARENT ( vi ) = , 则 vi 称为 入 结点 ( entry   node ) ； 若 CHILD ( vi ) = , 则 vi 称为 出 结点 ( exit   node ) . 记 所有 的 入 ( 出 ) 结点 构成 的 集合 为 ENTRY ( EXIT ) . 
 　 　   这种 任务 执行 模型 又 称为 编译 时 的 宏 数据流 模型 ( compile   time   macro   data   flow   model ) ［ 1 ～ 3 ］ . 在 该 模型 中 ， 每个 任务 只有 在 它 所 需要 的 数据 到 齐 之后 ， 才 可以 开始 执行 ， 即 任务 的 开始 执行 是 以 它 所 需要 的 数据 的 到 齐来 驱动 的 ， 任务 执行 完后 ， 立即 将 其 后代 所 需要 的 数据 发送给 它们 . 通常 ， 数据 的 发送 是非 堵塞 ( nonblocking ) 方式 的 ， 而 数据 的 接收 是 堵塞 ( blocking )   方式 的 . 
 　 　 处理机 模型 可以 用 五元 组 PG = ( P , L , S , I , R ) 来 描述 . 
 　 　 ( 1 )   P = ［ pi ］ 表示 所有 处理机 的 集合 , | P | 表示 处理机 的 数目 . 
 　 　 ( 2 )   L = ［ li , j ］ 是 一个 | P | × | P | 的 处理机 互连 拓扑矩阵 . li , j 只能 取 0 或 1 , 若 li , j = 0 ， 则 表示 pi 与 pj 之间 没有 直接 连接 ( link ) , 若 li , j = 1 ， 则 表示 pi 与 pj 之间 有 直接 连接 . 
 　 　 ( 3 )   S = ［ si ］ 表示 处理机 的 运算 速度 集合 ， si 表示 处理机 pi 的 运算 速度 . 
 　 　 ( 4 )   I = ［ α i ］ 表示 通信 时 的 启动 开销 集合 ， α i 表示 处理机 pi 通信 时 相应 的 I / O 处理机 启动 开销 . 
 　 　 ( 5 )   R = ［ β i , j ］ 表示 两个 相邻 处理机 之间 通道 的 数据 传输率 集合 ， β i , j 表示 了 两个 相邻 处理机 pi 与 pj 之间 通道 的 数据 传输率 . 
 　 　 通常 ， 假定 所有 连接 都 是 全双工 的 ( full   duplex ) . 每个 处理单元 都 带有 专门 的 硬件 来 支持 并行 通信 ， 这样 的 部件 称为 I / O 处理机 ， 这种 I / O 处理机 允许 任务 的 通信 与 计算 重叠 ( overlapping ) 地 进行 . 
 　 　 在 同构 系统 ( homogeneous   system ) 上 ， 所有 处理机 的 运算 速度 相等 ( 简记 为 s ) ， 通信 的 启动 开销 相等 （ 简记 为 α ） ， 并且 所有 通道 的 数据 传输率 都 相等 ( 简记 为 β ) ， 则 处理机 模型 可用 两元 组 ( P , L ) 来 描述 . 而 任务模型 可以 改用 四元组 TG = ( V , E , T , D ) 来 描述 ， 其中 V , E 及 D 的 定义 同 前 ， 而 T = ［ Γ i ］ 表示 任务 的 计算 时间 集合 ， Γ i 表示 执行 任务 vi 所 需要 的 时间 ， 为 ais . 当 任务 vi 与 vj 被 分配 到 不同 的 处理机 pm 与 pn 上去 执行 时 ， 在 采用 某种 路由 算法 确定 了 某条 路径 , 且 路径 上 的 所有 通道 均 处于 空闲 状态 时 , 如果 采用 存储转发 寻径 技术 ， 任务 之间 的 通信 时间 为   ci , j , m , n = pl ( m , n ) × ( α + di , j / β ) , 其中 pl ( m , n ) 为 处理机 pm 与 处理机 pn 之间 路径 的 长度 ； 如果 采用 虫蚀 寻径 技术 ， 任务 之间 的 通信 时间 为 ci , j , m , n = α + di , j / β . 
 2 　 调度 问题 的 形式化 描述 
 　 　 任务调度 的 消费者 是 DAG 图中 的 所有 任务 以及 任务 之间 通信 的 消息 ， 资源 是 经 某种 拓扑 互连 的 处理机 及 处理机 之间 的 连接 . 调度 算法 考虑 的 是 如何 将 处理机 分配 给 任务 及 连接 分配 给 消息 . 
 　 　 在 非 完全 互连 系统 上 ， 形式 地 ( 文献 ［ 4 ］ 也 曾 给出 了 调度 问题 的 形式化 描述 , 但 却 没有 考率 任务 之间 通信 的 消息 ) , 某个 调度 可用 函数 f 来 表示 ， 该 函数 的 定义域 为 V ∪ E × L ， 值域 为 P × ［ 0 , ∞ ) ∪ ［ 0 , ∞ ) . 对于 某个 任务 v ∈ V ， 如果 f ( vi ) = ( pj , t ) ， 我们 称 任务 vi 被 调度 到 处理机 pj 上 ， 并 在 t 时刻 开始 执行 ； 对于 某个 消息 ei , j , 如果 f ( ei , j , lm , n ) = t ， 则 表示 消息 ei , j 在 采用 某种 寻径 策略 时 需要 使用 连接 lm , n ， 在 t 时刻 , 该 连接 可以 分配 给 该 消息 使用 , 如果 消息 ei , j 不 需要 使用 连接 lm , n ， 令 t = ∞ . 
 　 　 衡量 调度 性能 的 最 主要 的 指标 是 调度 长度 ( schedule   length ， 许多 文献 ［ 1 , 3 ］ 中 又 称为 parallel   time , 简记 为 PT ) . 调度 f 的 调度 长度 PT ( f ) = max ｛ t + Γ i , j ｝ ， 其中 f ( vi ) = ( pj , t ) ， 且 Γ i , j = ai / sj . 
 　 　 定义 2.1 .   假定 任务 在 被 调度 之前 都 映射 到 不同 的 处理机 上 ， 且 这些 处理机 之间 以 完全 互连 的 方式 连接 ， 这个 假定 的 处理机 系统 又 称为 虚拟 处理机 系统 . 任务 图 TG 中 的 静态 关键 路径 ( static   critical   path , 简称 SCP ) 定义 为 从入 结点 到 出 结点 中 最长 的 路径 ( 包含 任务 之间 的 通信 时间 ) . 
 　 　 对于 图 1 ( a ) ， 当 α = 0 , β = 1 , s = 1 时 , 该 任务 图中 的 静态 关键 路径 为 v3v6v8v10 . 
 　 　 定义 2.2 .   在 同构 系统 上 ， 在 部分 调度 的 任务 图 TG ′ 中 ， 任务 图 的 动态 关键 路径 ( dynamic   critical   path , 简称 DCP ) 定义 为 TG ′ 中 的 从入 结点 到 出 结点 中 最长 的 路径 ( 包含 任务 之间 的 通信 时间 ) . 
 　 　 定义 2.3 .   在 同构 系统 上 ， 在 部分 调度 的 任务 图 TG ′ 中 ， 任一 结点 vx 的 top   level ( 简记 为 tlevel ) 定义 为 从入 结点 到 该 结点 ( 不 包含 该 结点 的 权 ) 的 最长 路径 ( 记为 tlevel ( vx ) ) . 任一 结点 的 bottom   level ( 简记 为 blevel ) 定义 为 从 该 结点 到 出 结点 ( 包含 该 结点 的 权 ) 的 最长 路径 ( 记为 blevel ( vx ) ) . 
 　 　 在 同构 系统 上 ， 在 未 调度 的 任务 图 TG 中 ， SCP 的 长度 为 maxvx ∈ V ｛ tlevel ( vx ) + blevel ( vx ) ｝ ， 对于 部分 调度 的 任务 图 TG ′ ， 该式 同样 可 用于 计算 DCP 的 长度 . 对于 未 调度 的 任务 图 TG ， 任意 结点 vi 的 tlevel 与 blevel 的 计算方法 如下 : 
 
 在 同构 系统 上 ， 若 任务调度 遵从 拓扑 顺序 ， 已 被 调度 结点 的 tlevel 为 该 结点 的 开始 执行 时间 ( 给出 已 被 调度 结点 的 tlevel 值 的 计算 , 是因为 计算 未 被 调度 结点 的 tlevel 值时 要 用到 已 被 调度 结点 的 tlevel 值 ) ， 未 被 调度 结点 的 tlevel 及 blevel 值 的 计算 也 采用 以上 两式 . 
 3 　 几个 关键问题 的 解决 策略 及 调度 算法 
 　 　 本节 先 给出 非 完全 互连 同构 系统 上 静态 调度 中 的 几个 关键问题 的 解决 策略 ， 然后 给出 调度 算法 . 
 　 　 已经 发表 的 非 完全 互连 同构 系统 上 任务调度 的 文章 极少 . 其中 ， El － Rewini 在 文献 ［ 5 ］ 中 首先 提出 了 非 完全 互连 系统 上 任务调度 的 算法 ， 但 他 的 算法 仅 适用 于 存储转发 寻径 通信 ， 而且 也 没有 讨论 如何 去 利用 连接 的 最早 的 ( 这里 的 最早 以及 下面 的 较 早 都 是 针对 处理机 或 连接 上 被 占用 的 最后 一段 或 下文 中 的 第 δ 段时间 空隙 而言 ) 空闲 时间 空隙 ( idle   time   slot ) . Kwok 在 文献 ［ 6 ］ 中 提出 了 如何 利用 连接 的 最早 空闲 时间 空隙 的 方法 ， 但 经过 仔细分析 ， 他 的 工作 忽略 了 “ 不同 连接 上 的 空闲 时间 空隙 分布 是 不 一致 的 ” 这一 实际 情况 . 
 　 　 非 完全 互连 同构 系统 上 并行任务 的 静态 调度 中要 解决 的 问题 有 3 个 ： ( 1 )   如何 顺序 选择 参与 调度 的 任务 ， ( 2 )   如何 选择 路由 ， ( 3 )   如何 将 处理机 分配 给 任务 . 
 　 　 如何 顺序 选择 参与 调度 的 任务 　 一般 认为 , 应 优先 调度 关键 路径 上 的 任务 . 在 确定 关键 路径 时 ， 有些 算法 采用 静态 关键 路径 ， 而 有些 算法 采用 动态 关键 路径 . 对于 调度 算法 的 性能 ， 采用 动态 关键 路径 的 算法 一般 优于 采用 静态 关键 路径 的 算法 ； 对于 调度 算法 的 复杂度 ， 采用 动态 关键 路径 的 算法 通常 高于 采用 静态 关键 路径 的 算法 . 
 　 　 如何 选择 路由 　 对于 非 完全 互连 系统 ， 处理机 之间 的 连接 是 有限 的 资源 ， 在 并行程序 执行 过程 中 ， 很 有 可能 出现 不同 的 消息 争用 同一 连接 的 情况 . 因此 ， 如果 将 连接 也 作为 资源 来 静态 地 加以 分配 ， 在 程序运行 时 ， 便 不再 需要 考虑 网络 的 链路 堵塞 以及 死锁 等 问题 的 出现 . 
 　 　 对于 非 完全 互连 同构 系统 ， 从源 到 目的 的 路径 可能 很多 ， 问题 是 如何 确定 某个 路由 ， 从源 发出 的 消息 经过 该 路由 时能 尽量 早地 到达 目的地 . 对于 某个 确定 路由 ， 如果 采用 某种 方法 能 计算 出 消息 经过 该 路由 到达 目的 处理机 的 最早 时刻 ， 则 先算出 所有 的 路由 所 对应 的 最早 时刻 ， 便 可以 求 出 消息 到达 目的 处理机 的 最早 时刻 并 选择 相应 的 路由 . 对于 存储转发 寻径 技术 ， 本文 给出 了 消息 经过 某个 路径 到达 目的 处理机 的 最早 时刻 的 计算方法 ； 对于 虫蚀 寻径 技术 ， 尚 没有 人 给出 消息 经过 某个 路径 到达 目的 处理机 的 最早 时刻 的 计算方法 ， 本文 给出 了 消息 经过 某个 路径 到达 目的 处理机 的 一个 较 早 时刻 的 计算方法 . 
 　 　 先 定义 两个 将 在下文 中 用到 的 对 二元 矢取 分量 的 操作 fst 与 scnd ： 
 　 　 定义 3.1 .   若 将 操作 fst 与 scnd 作用 于 二元 矢 ( x1 , x2 ) ， 则 fst ( ( x1 , x2 ) ) = x1 ， scnd ( ( x1 , x2 ) ) = x2 . 
 　 　 对于 任务调度 f ， 假定 任务 vi 已 被 调度 ， vi 要 向 其子 任务 vj 发送 消息 ei , j ， 如果 在 选择 某条 路径 时 需要 使用 连接 lm , n . 下面 分 两种 不同 的 寻径 方式 ， 即 存储转发 寻径 与 虫蚀 寻径 来 讨论 如何 选择 路由 . 
 　 　 ( a )   在 采用 存储转发 寻径 技术 时 
 　 　 假定 在此之前 已有 δ 个 消息 要求 顺序 使用 连接 lm , n . 
 　 　 ( 1 )   若 fst ( f ( vi ) ) = pm ， 即 消息 刚 从源 处理机 出发 经过 第 1 个 连接 时 ， 则 存在 一些 k 满足 下 式 ： 
 
 ( 1 ) 
 其中 为 消息 的 大小 ， 且 . 
 　 　 对于 式 ( 1 ) ， 至少 k = δ 时 是 成立 的 . 如果 ι 为 所有 k 中 的 最小值 ， 则 消息 ei , j 可以 使用 连接 lm , n 的 最早 时刻 为 
 
 ( 2 ) 
 　 　 ( 2 )   若 fst ( f ( vi ) ) ≠ pm , 假定 消息 ei , j 在 使用 连接 lm , n 时 刚刚 经过 了 连接 ll , m ， 则 如果 存在 一些 k 满足 下 式 : 
 
 ( 3 ) 
 对于 式 ( 3 ) ， 至少 当 k = δ 时 是 成立 的 . 如果 ι 为 所有 k 中 的 最小值 ， 则 消息 ei , j 可以 使用 连接 lm , n 的 最早 时刻 为 
 
 ( 4 ) 
 根据 该 路径 上 的 最后 一段 连接 ， 不难 求 出 消息 经过 该 路径 到达 目的 处理机 的 最早 时刻 . 
 　 　 定理 3.1 .   在 采用 存储转发 寻径 技术 , 按式 ( 1 ) ～ ( 4 ) 选择 连接 的 空闲 时间 空隙 时 ， 针对 某个 确定 的 路由 ， 消息 可以 最早 地 到达 目的 处理机 . 
 　 　 证明 : 在 采用 存储转发 技术 通信 时 ， 消息 在 经过 中间 结点 时 都 必须 先 存储 ， 然后 再 转发 . 按式 ( 1 ) ～ ( 4 ) 选择 连接 的 空闲 时间 空隙 时 ， 消息 都 是 最早 地 经过 中间 结点 . 因此 ， 针对 某个 确定 的 路由 ， 消息 必定 最早 地 到达 目的 处理机 . 
 　 　 ( b )   在 采用 虫蚀 寻径 技术 时 
 　 　 假定 消息 ei , j 要 经过 的 连接 顺序 为 la , b , lb , c , ... , ly , z ， 很 显然 , fst ( f ( vi ) ) = pa , fst ( f ( vj ) ) = pz . 对于 任一 连接 ， 如 lm , n ， 若 已有 δ m , n 个 消息 要求 顺序 使用 该 连接 ， 令则 在 连接 lm , n 上 已 被 分配 的 时间 空隙 TSm , n 为 
 
 令 　 　 　 　 　 　 　 　 　 　 　 　 TS = TSa , b ∪ TSb , c ∪ ... ∪ TSy , z . 
 　 　 令 TS 对应 着 时间轴 上 被 占用 的 时间 空隙 数为 δ , 为了 便于 问题 的 讨论 , 令 
 TS = ［ η 1 , ζ 1 ］ ∪ ［ η 2 , ζ 2 ］ ∪ ... ∪ ［ η ζ , ζ δ ］ , 
 其中 ［ η i , ζ i ］ 表示 在 该 时间段 至少 有 一个 或 多个 消息 在 使用 连接 la , b , lb , c , ... , ly , z 中 的 一个 或 多个 , 则 存在 一些 k 满足 下 式 , 
 
 ( 5 ) 
 其中 k ∈ { 0 , ... , δ } ， ζ 0 = 0 ， η δ + 1 = ∞ . 
 　 　 可知 , 至少 k = δ 是 满足 不等式 ( 5 ) 的 ， 假定 ι 为 所有 k 中 的 最小值 ， 则 消息 ei , j 到达 目的 处理机 的 较 早 时刻 为 
 
 ( 6 ) 
 　 　 根据 式 ( 5 ) 和 式 ( 6 ) , 不难 在 所有 的 路由 中 确定 一个 能 使 消息 较 早 地 到达 目的 处理机 的 路由 . 
 　 　 在 采用 虫蚀 寻径 技术 时 ， 消息 是 以 异步 流水 方式 到达 目的 处理机 的 ， 不同 的 连接 上 对应 的 时间 空隙 是 不 一致 的 ， 因此 很 难用 统一 的 式子 来 选择 不同 连接 上 的 空闲 时间 空隙 以 使 消息 最早 地 到达 目的 处理机 . 
 　 　 本文 约定 ， 如 有 多个 路由 都 能 使 消息 最早 ( 较 早 ) 地 到达 目的地 ， 则 选择 最 短路 由 中 的 任意 一条 . 
 　 　 如何 将 处理机 分配 给 任务 　 一般 认为 , 应 选择 使 任务 最早 开始 执行 的 处理机 . 下面 给出 某个 任务 在 某个 处理机 上 的 最早 开始 执行 时间 的 计算方法 . 
 　 　 先 定义 DAT ( vx , py ) 为 任务 vx 从 其父 结点 所 接收 的 消息 中 最晚 到达 处理机 py 的 消息 到达 的 时间 , 又 假定 在 任务 vi 分配 给 处理机 pj 时 已有 δ 个 任务 ｛ vj1 , vj2 , ... , vj δ ｝ 要求 顺序 使用 处理机 pj ， 则 如果 存在 一些 k 满足 下 式 ： 
 scnd ( f ( vjk + 1 ) ) - max { scnd ( f ( vjk ) ) + Γ jk , DAT ( vi , pj ) ｝ ≥ Γ i 
 ( 7 ) 
 其中 k ∈ ｛ 0 , ... , δ ｝ ， scnd ( f ( vj0 ) ) = 0 ， scnd ( f ( vj δ + 1 ) ) = ∞ , 可知 , 至少 k = δ 是 满足 不等式 ( 7 ) 的 . 假定 ι 是 所有 k 中 满足 上述 不等式 的 最小值 ， 则 任务 vi 在 处理机 pj 上 的 最早 开始 执行 时间 为 
 max ｛ scnd ( f ( vj ι ) ) + Γ j ζ , DAT ( vi , pj ) ｝ . 
 ( 8 ) 
 　 　 根据 式 ( 7 ) 和 式 ( 8 ) ， 便 可 从 所有 的 处理机 中 选择 使该 任务 能 最早 开始 执行 的 处理机 . 
 　 　 下面 ， 根据 上文 提供 的 策略 ， 构造 一个 非 完全 互连 同构 系统 上 的 静态 任务调度 算法 . 本 算法 在 选择 参与 调度 的 任务 时 ， 采用 的 是 静态 关键 路径 . 
 　 　 算法 1 .   调度 算法 
 　 　 ①   根据 静态 关键 路径 ， 创建 任务 优先级 表 . 
 　 　 ( a )   vi ， 计算 tlevel ( vi ) 与 blevel ( vi ) ， 并 确定 一条 静态 关键 路径 . 
 　 　 ( b )   置 任务 优先级 表为 空 ， 取 静态 关键 路径 上 的 第 1 个 结点 作为 当前 结点 vi . 
 　 　 ( c )   如果 vi 的 入度 为 0 ， 则 将 该 结点 作为 任务 优先级 表中 最后 一个 结点 插入 表中 ， 并 把 该 结点 的 子 结点 的 入度 减 1 ， 转 ( d ) . 如果 vi 入度 不为 0 ， 则 先 对 其 所有 的 尚未 进入 任务 优先级 表 的 父 结点 vj 按 tlevel ( vj ) + Γ j + ci , j 的 大小 由大到 小 排序 . 以 第 1 个父 结点 及其 尚未 进入 任务 优先级 表 的 祖先 结点 为子 图 构成 一个 有 向 无 环图 ， 递归 地 创建 该子 图 的 任务 优先级 表 ， 并 将 该子 图 的 任务 优先级 表 添加 到 要 创建 的 任务 优先级 表 的 末尾 . 用 类似 的 方法 处理 其余 父 结点 构成 的 子 图 . 最后 再 将 结点 vi 加到 任务 优先级 表 的 末尾 ， 并 把 该 结点 的 子 结点 的 入度 减 1 . 
 　 　 ( d )   如果 当前 结点 为 最后 一个 结点 ， 则 任务 优先级 表 创建 完成 ， 否则 取 静态 关键 路径 上 的 下 一个 结点 作为 当前 结点 ， 执行 ( c ) . 
 　 　 ②   根据 每个 处理机 连接数 目的 高低 ， 创建 处理机 优先级 表 . 
 　 　 ③   取 任务 优先级 表中 的 第 1 个 任务 作为 当前任务 ， 执行 ④ ～ ⑥ 步 ， 为 该 任务 选择 最早 开始 执行 的 处理机 . 
 　 　 ④   将 处理机 优先级 表中 的 第 1 个 处理机 作为 当前 处理机 . 
 　 　 ⑤   如果 当前任务 在 任务 图中 不是 入 结点 ， 则 按 其父 结点 完成 的 先后顺序 计算 每个 父 结点 发送给 当前 结点 的 消息 到达 当前 处理机 的 最早 时间 . 具体 计算 分成 两种 情况 ， 若父 结点 也 在 当前 处理机 上 执行 ， 则 消息 的 最早 到达 时间 为父 结点 的 完成 时间 ； 若父 结点 不 在 当前 处理机 上 执行 ， 则 应 按照 式 ( 1 ) ～ ( 4 ) 或 ( 5 ) 与 ( 6 ) 计算 消息 的 最早 到达 时间 . 根据 所有 消息 到达 的 时间 ， 求出 最晚 消息 到达 时间 . 如果 当前任务 在 任务 图中 是 入 结点 ， 则 设其 最晚 消息 到达 时间 为 0 . 
 　 　 ⑥   根据 式 ( 7 ) 和 式 ( 8 ) 计算 当前任务 在 当前 处理机 上 的 最早 开始 时间 . 如果 当前 处理机 为 处理机 优先级 表中 的 最后 一个 处理机 ， 则 转 ⑦ ; 否则 从 处理机 优先级 表中取 下 一个 处理机 作为 当前 处理机 ， 转 ⑤ . 
 　 　 ⑦   如果 当前任务 为 任务 优先级 表中 的 最后 一个 任务 ， 则 结束 ; 否则 ， 取 下 一个 任务 作为 当前任务 ， 执行 ④ ～ ⑥ 步 ， 为 该 任务 选择 最早 开始 执行 的 处理机 . 
 　 　 这里 ， 假定 不同 处理机 之间 的 通信 采用 虫蚀 寻径 技术 ， 根据 以上 调度 算法 分析 一下 如何 将 图 1 ( a ) 中 的 DAG 图 调度 到 图 1 ( b ) 中 的 多处理机系统 上去 . 图 1 ( a ) 中 的 静态 关键 路径 为 v3v6v8v10 ， 根据 算法 第 1 步 创建 的 任务 优先级 表为 v3v1v6v2v5v8v4v7v9v10 . 根据 算法 第 2 步 创建 的 处理机 优先级 表为 p0p1p2p3 . 先 调度 v3 ， 因为 它 是 入 结点 ， 故 将 v3 调度 到 p0 上时 便 能 最早 地 执行 . 类似 地 ， v1 被 调度 到 p1 上 执行 . 在 调度 v6 时 ， 因为 要 从父 结点 v1 接收 消息 e1 , 6 ， v6 在 p0 上 的 最早 开始 时间 为 4.0 . 而 v6 在 p1 , p2 , p3 上 的 最早 开始 时间 均 为 5.5 ， 故 v6 被 调度 到 处理机 p0 上 执行 . 类似 地 ， v2 , v5 , v8 , v4 被 分别 调度 到 处理机 p2 , p2 , p0 , p3 上 . 在 调度 v7 时 ， 它 可以 被 调度 到 处理机 p0 上 ， 插 到 任务 v3 与 v6 之间 执行 ， 而 消息 e4 , 7 可以 插 在 e1 , 6 之前 占用 连接 l1 , 0 . 类似 地 ， v9 , v10 被 分别 调度 到 处理机 p2 , p0 上 . 最后 ， 获得 整个 DAG 图 的 调度 长度 为 12.5 ， 而 整个 DAG 图 的 串行 执行 时间 为 24.0 , 调度 结果 如图 1 ( c ) 所示 . 
 　 　 现在 ， 分析 一下 以上 算法 的 复杂度 . 本 算法 的 复杂度 主要 体现 在 ③ ～ ⑦ 步 ， 对于 每个 消息 ， 都 要 计算 从源 到达 | P | - 1 个 目的 处理机 的 最早 时间 ； 对于 每个 任务 ， 都 要 计算 该 任务 在 每个 处理机 上 的 最早 开始 执行 时间 . 在 采用 存储转发 技术 时 ， 要 计算 消息 在 经过 每个 中间 连接 时 的 最早 时间 ； 在 采用 虫蚀 寻径 技术 时 ， 对于 某个 确定 的 路由 ， 要 先 找出 已经 占用 该 路由 中 任一 连接 的 所有 消息 ， 因为 不同 连接 上 已 占用 的 消息 可能 部分 相同 ， 故可 创建 一棵 AVL 树 , 将 不同 连接 上 的 消息 按 占用 时间 空隙 的 起止 时间 为 关键字 插入 到 该 树 中 ， 然后 再 为 要 经过 该 路由 的 消息 分配 时间 空隙 . 故 在 采用 存储转发 技术 时 ， 算法 的 复杂度 为 O ( | P | | V | 2 + | P | | D | | R | | E | 2 ) ； 在 采用 虫蚀 寻径 技术 时 ， 算法 的 复杂度 为 O ( | P | | V | 2 + | P | | D | | R | | E | 2log ( | E | ) ) , 其中 | D | 为 网络 直径 ， | R | 为 网络 中 任意 两个 处理机 之间 的 路由 总数 的 最大值 . 
 4 　 结束语 
 　 　 在 一般 情况 下 ， 任务调度 是 NP - 完全 问题 . 目前 , 仅仅 在 某些 条件 非常 苛刻 的 情况 下 获得 了 最优 解 ［ 4 ］ . 完全 按照 本文 提供 的 策略 去 设计 非 完全 互连 同构 系统 上 的 静态 任务调度 算法 是 不难 的 ， 但是 算法 的 复杂度 可能 会 令人 难以 接受 . 对于 如何 设计 一个 较 低 复杂度 ， 同时 又 能 提供 满意 调度 性能 的 算法 ， 我们 已 在 这些 领域 取得 了 一些 进展 ， 对此 , 我们 将 在 以后 的 文章 中 加以 介绍 . 
 基金项目 ： 本文 研究 得到 国家自然科学基金 和 国家 攀登 计划 项目 基金 资助 . 
 作者简介 ： 章军 ， 1971 年生 ， 博士 , 主要 研究 领域 为 并行计算 ， 并行 任务调度 ， 计算机 体系结构 . 
 　 　 　 　 　 章立生 ， 1962 年生 ， 副研究员 , 主要 研究 领域 为 计算机 体系结构 ， 计算机网络 ， 并行处理 . 
 　 　 　 　 　 韩 承德 , 1940 年生 ， 研究员 , 博士生 导师 , 主要 研究 领域 为 计算机 体系结构 ， 并行处理 . 
 作者 单位 ： 中国科学院计算技术研究所 高性能 计算机 研究 中心 　 北京 　 100080 
 本文 通讯联系 人 : 韩 承德 ， 北京 100080 , 北京 2704 信箱 25 分箱 
 参考文献 
 　 1 　 Hwang   Jing - jang   et   al .   Scheduling   precedence   graphs   in   systems   with   interprocessor   communication   times .   SIAM   Journal   of   Computing ,   1989 , 18 ( 2 ) : 244 ～ 257 
 　 2 　 Wu   Min - you   et   al .   Hypertool :   a   programming   aid   for   message － passing   systems .   IEEE   Transactions   on   Parallel   and   Distributed   Systems ,   1990 , 1 ( 3 ) : 330 ～ 343 
 　 3 　 Yang   T   et   al .   PYRROS :   static   scheduling   and   code   generation   for   message   passing   multiprocessors .   In :   Proceedings   of   the   6th   ACM   International   Conference   of   Supercomputing .   1992 .   428 ～ 437 
 　 4 　 Hesham   El － Rewini .   Partitioning   and   scheduling .   In :   Albert   Y   H   Zomaya   ed .   Parallel   Distributed   Computing   Handbook .   McGraw   Hill ,   Inc . ,   1996 .   239 ～ 302 
 　 5 　 Hesham   El － Rewini   et   al .   Scheduling   parallel   program   tasks   onto   arbitrary   target   machines .   Journal   of   Parallel   and   Distributed   Computing ,   1990 , 9 ( 2 ) : 138 ～ 153 
 　 6 　 Kwok   Yu － Kwong   et   al .   Bubble   scheduling :   a   quasi   dynamic   algorithm   for   static   allocation   of   tasks   to   parallel   architectures .   In :   Proceedings   of   the   SPDP ' 95 .   Available   from :   http : / / www . cs . ust . hk 
 本文 1998 - 08 - 28 收到 原稿 , 1998 - 11 - 30 收到 修改稿 
