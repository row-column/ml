微型机 与 应用 
 MICROCOMPUTER   &   ITS   APPLICATIONS 
 1999 年   第 18 卷   第 4 期   Vol.18   No.4   1999 
 
 
 
 在 Windows95 下 实现 PC机 与 单片机 AT89C51 的 串行 通信 
 黄海 容 　 黄 继武 　 袁兰英 　 王来 运 　 余 　 进 
 　 　 摘 　 要 ： 在 Windows95 下 使用 串口 API 函数 实现 PC机 与 单片机 AT89C51 的 串口 通信 ， 重点 介绍 计算机 采用 事件驱动 I / O 方式 的 函数 编程 及 单片机 串口 中断 发送 、 接收 程序 的 实现 。 
 　 　 关键词 ： Windows95 　 单片机 AT89C51 　 RS - 232 接口 　 RS - 485 接口 　 串行 通信 
 　 　 在 以 单片机 为 基础 的 数据 采集 和 实时 控制系统 中 ， 通过 计算机 中 的 RS - 232 接口 进行 计算机 与 单片机 之间 的 命令 和 数据 传送 ， 就 可以 利用计算机 对 生产 现场 进行 监测 和 控制 。 由于 计算机 上 的 RS - 232 所 传送 的 距离 不 超过 30m ， 所以 ， 在 远距离 的 数据 传送 和 控制 时 ， 可以 用 MAX485 的 接口 转换 芯片 将 RS - 232 转换成 RS - 485 协议 进行 远距离 传送 。 在 发送 和 接收端 都 进行 协议 转换 后 ， RS - 485 协议 对 数据 传送 来说 是 相对 透明 的 ， 所以 依然 可以 使用 计算机 中 的 RS - 232 进行 远距离 的 数据 传送 和 控制 。 在 最 简单 的 RS - 232 直接 传送 通信 系统 中 ， 只要 发送 和 接收 双方 同时 准备 好 ， 仅用 信号 发送 端 ( TXD ) ， 信号 接收端 ( RXD ) 和 信号 地 ( GND ) 3 根线 即可 进行 通信 ； 若 以 应答 方式 进行 数据通信 ， 可 使用 请求 发送 ( RTS ) 、 清除 发送 ( CTS ) 或 数据终端 准备 ( DTR ) 、 数据 装置 准备 ( DSR ) 进行 硬件 握手 。 在 Windows95 下 ， 可以 很 方便 地 使用 Win32 通信 API 函数 来 实现 这些 硬件 的 握手 以及 数据 的 传送 。 在 89C51 单片机 系统 中 ， 分别 从 P3.0 和 P3.1 引出 串口线 RXD 和 TXD 通过 专用 的 电平 转换 芯片 转换成 RS - 232 接口标准 的 电平 ， 这样 ， 二者之间 就 可以 通过 RS - 232 接口 进行 数字信号 的 传送 。 单片机 也 可以 以 直接 传送 或 应答 握手 的 方式 进行 数据通信 ， 但 由于 握手 方式 占用 其他 的 端口 ， 而 单片机 的 端口 数量 有限 ， 所以 ， 计算机 与 单片机 的 通信 常 采用 直接 传送 的 方式 ， 本文 将 重点 介绍 。 
 1 　 Windows95 下 的 通信 编程 
 　 　 Windows95 通信 体系 提供 了 1 个 改进 的 串行 应用 程序接口 SAPI 用来 进行 交互式 串行 通信 。 其中 ， 串口 和 其他 通信 设备 是 作为 文件 进行 处理 的 ， 串口 的 打开 、 关闭 、 读取 和 写入 所用 的 函数 和 操作 文件 的 函数 相同 。 
 　 　 通信 会话 以 调用 CreateFile 函数 开始 ， CreateFile 函数 为读 访问 或 写访问 打开 串口 ， 打开 成功 后 返回 该 串口 句柄 ， 供 读写 串口 时 使用 。 CreateFile 函数 的 使用 如下 ： 
 CreateFile ( szDevice , fdwAccess , fdwShareMode , lpsa , fdwCreate , fdwAttrsAndFlags , hTemplateFile ) 
 　 　 其中 ， 第 1 个 参数 szDevice 是 要 打开 的 串口 逻辑 名 ， 如 COM1 或 COM2 ； 第 2 个 参数 fdwAccess 指定 串口 的 访问 类型 ， 如读 、 写 或 两者 兼而有之 ， 大部分 通信 是 双向 的 ， 因而 通常 设置 为 ： GENERICREAD ｜ GENERICWRITE ； 第 3 个 参数 fdwShareMode 指定 串口 的 共享 属性 ， 串口 不能 共享 ， 所以 它 必须 为 0 ； 第 4 个 参数 lpsa 引用 安全性 属性 结构 ； 第 5 个 参数 fdwCreate 指定 如果 CreateFile 正 被 已有 的 文件 调用 时应 做些 什么 ， 既然 串口 总是 存在 ， 此参数 就 必须 被 设置 为 OPENEXISTING 。 第 6 个 参数 fdwAttrsAndFlags 描述 了 该 端口 的 各种 属性 ， 对 串口 而言 ， 唯一 有 意义 的 设置 是 FILEFLAGOVERLAPPED ， 指定 该 设置 时 ， 端口 I / O 可以 在 后台 进行 ； 最后 1 个 参数 hTemplateFile 是 指向 模板 文件 的 句柄 ， 当 端口 打开 时 ， 该 参数 为 NULL 。 
 　 　 打开 串口 后 ， 在 Windows95 下 可以 对 串口 进行 合适 的 配置 。 Windows95 提供 了 COMMPROP 结构 ， COMMPROP 结构 中 包含 了 对 串口 允许 的 设置 ， 如 波特率 、 数据 位数 、 停止 位 的 个数 以及 奇偶校验 方法 等 ， 如果 串口 连接 到 调制解调器 ， COMMPROP 结构 中 还 包含 调制解调器 支持 的 设置 。 但 COMMPROP 结构 给出 的 只是 单纯 的 信息 ， 它 不能 用来 改变 串口 的 设置 。 Windows95 下 串口 设置 的 改变 是 通过 改变 它 的 DCB 结构 来 实现 的 ， DCB 结构 中 包含 了 所有 串口 的 设置 ， 其中 包括 硬件 的 握手 、 流控制 等 。 
 　 　 Windows95 提供 GetCommState 函数 来 得到 当前 串口 的 设置 情况 ， 该 函数 接收 1 个 打开 的 端口 句柄 和 1 个 指向 DCB 结构 的 指针 ， 在 DCB 结构 中 返回 信息 ， GetCommState 函数 的 补充 函数 是 SetCommState 函数 ， SetCommState 函数 将 DCB 结构 中 的 内容 写 向 串口 设置 ， 这 2 个 函数 的 调用 如下 ： 
 　 　 BOOLGetCommState ( hComm , & dcb ) 
 　 　 BOOLSetCommState ( hComm , & dcb ) 
 　 　 其中 ， hComm 为 打开 串口 的 句柄 ， dcb 为 1 个 指向 DCB 的 结构 。 
 　 　 Windows95 中 实现 串口 的 读写 函数 与 文件 的 读写 函数 相同 ， 读写 函数 的 使用 格式 如下 ： 
 　 　 ReadFile ( hComm , inbuff , nBytes , & nBytesRead , & overlapped ) 
 　 　 WriteFile ( hComm , outbuff , nBytes , & nBytesWrite , & overlapped ) 
 　 　 其中 ， 第 1 个 参数 是 打开 串口 的 句柄 ， 第 2 个 参数 是 数据 所 使用 的 缓冲区 ， 第 3 个 参数 是 要 读取 的 字节数 ， 第 4 个 参数 是 实际 读取 的 字节数 ， 实际 读取 的 字节数 可能 小于 要 读取 的 字节数 ， 最后 1 个 参数 指向 1 个 覆盖 似的 结构 ， 当 CreateFile 中 dwAttrsAndFlags 参数设置 为 FILEFLAGOVERLAPPED 时 ， 此参数 可以 指定 1 个 OVERLAPPED 结构 ， 使 数据 的 读写操作 在 后台 进行 。 
 　 　 读写 端口 可以 通过 4 种 技术 来 实现 ： 查询 、 同步 I / O 、 异步 I / O ( 后台 I / O ) 和 事件驱动 I / O 。 查询 方式 直接 、 易于 理解 ， 但 占用 大量 CPU 时间 ； 同步 I / O 直到 读取 所 指定 字节数 或 超时 时才 返回 ， 这样 很 容易 长时间 地 阻塞 线程 ； 异步 I / O 可以 在 后台 读写 数据 ， 而 在 前台 做 其他 的 事情 ； 事件驱动 I / O 是 由 Windows95 通知 应用程序 某些 事件 什么 时候 发生 ， 然后 根据 所 发生 的 事情 来 对 串口 进行 操作 。 
 　 　 这 4 种 不同 的 技术 ， 各有利弊 和 自己 适用 的 领域 ， 所以 ， 在 不同 的 通信 系统 中 ， 可以 根据 不同 的 要求 采用 不同 的 技术 。 在 监测 系统 中 ， 由于 事件 的 偶然性 和 要求 传送 的 实时性 ， 计算机 常 采用 事件驱动 I / O 方式 来 进行 现场 监测 。 
 　 　 在 事件驱动 I / O 方式 下 ， Windows95 报告 给 应用程序 的 事件 由 函数 GetCommMask 返回 ， 改变 返回 的 事件 时 ， 可以 使用 SetCommMask 函数 设置 ， 这 2 个 函数 的 调用 如下 ： 
 　 　 GetCommMask ( hComm , & dwMask ) 
 　 　 SetCommMask ( hComm , dwMask ) 
 　 　 第 1 个 参数 是 打开 串口 的 句柄 ， 第 2 个 参数 是 要 等待 的 1 个 或 多个 事件 的 掩码 。 在 用 SetCommMask 设置 了 有用 的 事件 后 ， 应用程序 调用 WaitCommEvent 函数 来 等待 事件 的 发生 ， 直到 事件 发生 ， WaitCommEvent 函数 返回 。 WaitCommEvent 函数 使用 格式 如下 ： 
 　 　 WaitCommEvent ( hComm , & dwEvent , & overlapped ) 
 　 　 第 1 个 参数 是 打开 串口 的 句柄 ， 第 2 个 参数 是 返回 的 事件 ， 第 3 个 参数 是 指定 同步 或者 异步 操作 。 当 函数 返回 后 ， 可 根据 返回 的 事件 掩码 进行 相应 的 串口 操作 。 
 　 　 完成 通信 后 ， 串口 应该 关闭 ， 否则 ， 它 始终 处于 打开 状态 ， 其他 应用程序 就 不能 打开 或 使用 它 。 关闭 串口 的 函数 为 ： CloseHandle ( hComm ) ， 其中 ， hComm 为 打开 的 串口 句柄 。 
 2 　 单片机 下 的 通信 编程 
 　 　 单片机 89C51 的 串行 端口 有 4 种 工作 方式 ， 通过 编程设计 ， 可以 使 其 工作 在 任一 方式 ， 以 满足 不同 场合 的 需要 。 其中 ， 方式 0 主要 用于 外接 移位 寄存器 ， 以 扩展 单片机 的 I / O 电路 ； 方式 1 主要 用于 双机 之间 或 外设 电路 的 通信 ； 方式 2 、 3 除有 方式 1 的 功能 外 ， 还 可 用作 多机 通信 ， 以 构成 多 微机 系统 ， 方式 2 、 3 的 区别 在于 波特率 的 不同 。 
 　 　 单片机 的 串行 通信 的 波特率 可以 程控 设定 ， 在 不同 的 工作 方式 下 ， 由 时钟 振荡 频率 的 分频 值 或 由 定时器 T1 的 定时 溢出 时间 确定 。 
 　 　 单片机 的 串行 端口 有 2 个 控制 寄存器 ， 用来 设置 工作 方式 、 发送 或 接收 的 状态 、 特征 位 、 数据 传送 的 波特率 以及 中断 标志 TI 和 RI 。 
 　 　 单片机 的 串行 端口 有 1 个 数据 寄存器 SBUF ， 该 寄存器 为 发送 和 接收 所 共有 ， 在 一定 条件 下 ， 向 SBUF 写入 数据 就 启动 了 发送 过程 ， 读 SBUF 就 启动 了 接收 过程 。 
 　 　 单片机 可以 采用 循环 方式 或 中断 方式 实现 串行 数据 的 传送 。 在 循环 方式 下 ， 单片机 循环 对 数据 寄存器 SBUF 进行 读写 来 实现 数据 的 接收 和 发送 ； 在 中断 方式 下 ， 对 方式 1 、 2 来说 ， 1 帧 数据 发送 或 接收 完后 ， TI / RI 自动 置 1 ， 请求 串行 中断 ， 若 CPU 响应 中断 ， 则 执行 串行 中断 服务程序 ， 并 把 TI / RI 清 0 以 再次 响应 中断 。 对 在 方式 2 、 3 下 的 接收 ， 还要 视 串口 控制 寄存器 SCON 的 设置 才 可 确定 RI 是否 被 置位 以及 串口 中断 是否 开放 。 
 　 　 实时控制 中 ， 由于 事件 的 突发性 ， 常 采用 中断 的 方式 进行 数据 传送 ， 中断 方式 能 更 大限度 地 提高 资源 的 利用率 ， 使 CPU 在 不 进行 数据通信 时 做 其他 的 工作 。 下面 重点 介绍 单片机 在 方式 1 下 的 中断 方式 编程 。 
 　 　 方式 1 是 10 位 异步 通信 方式 ， 其中 包括 1 个 起始 位 ， 8 个 数据位 和 1 个 停止 位 。 波特率 由 定时器 T1 的 溢出 率 和 串口 控制 寄存器 SMOD 的 状态 确定 ， 在 CPU 的 晶振为 11.0592 MHz 时 ， 波特率 常 采用 9600b / s 。 
 　 　 对 SBUF 进行 写 操作 就 可 启动 发送 ， 在 发送 移位 时钟 的 同步 下 ， 从 TXD 先送 出 起始 位 ， 然后 是 8 位 数据位 ， 最后 是 停止 位 ， 这样 ， 1 帧 数据 发送 完 ， 中断 标志 TI 置位 。 
 　 　 在 允许 接收 的 条件 下 ( REN ＝ 1 ) ， 当 RXD 出现 由 1 到 0 的 负 跳变 时 ， 即 被 当成 是 串行 发送 来 的 1 帧 数据 的 起始 位 ， 从而 启动 1 次 接收 过程 。 当 8 位 数据 接收 完 ， 并 检测 到 高电平 停止 位后 ， 即 把 收到 的 8 位 数据 装入 SBUF ， 置位 RI ， 1 帧 数据 的 接收 过程 就 完成 了 。 
 　 　 下面 是 单片机 以 方式 1 在 直接 传送 下 的 中断 接收 和 发送 程序 。 由于 没有 使用 通信 握手 ， 所以 通信 双方 都 应 做好 通信 准备 。 在 计算机 接收 、 单片机 发送 时 ， 由 计算机 先 发送 字母 “ R ” ， 通知 单片机 计算机 已 准备 好 ， 然后 计算机 在 事件驱动 I / O 方式 下 等待 接收 到 字符 “ Y ” ； 当 单片机 接收 到 “ R ” 时 ， 向 计算机 发送 “ Y ” ， 表示 单片机 也 已 准备 好 ， 这样 ， 一旦 计算机 接收 到 “ Y ” 就 表示 双方 都 已 准备 好 ， 二者之间 就 可以 进行 数据交换 了 。 在 计算机 发送 、 单片机 接收 时 ， 计算机 发送 1 帧 数据 ， 单片机 响应 中断 ， 接收数据 。 单片机 程序 的 具体 实现 过程 如下 ： 
 　 　 org 　 0000h 
 　 　 ajmpstart 
 　 　 org0023h 　 　 ； 串行 中断 入口 
 　 　 ljmps & r 
 　 　 org0100h 
 start : mov 　 tmod , # 20h 　 ； 设置 定时器 T1 方式 2 
 　 　 movpcon , # 00h ； 使 SMOD 为 0 
 　 　 movtll , # 0fdh ； 波特率 为 9600b / s 
 　 　 movthl , # 0fdh 
 　 　 setbea ； 开 全局 中断 
 　 　 clret1 ； 关 T1 中断 
 　 　 setbes ； 开 串行 中断 
 　 　 setbtrl ； 开 T1 定时 
 　 　 movscon , # 50h ； 串行 方式 1 ， 允许 接收 
 　 　 sjmp $ 
 S & r : movc , ri 
 　 　 jcrecive ; RI 为 1 ， 执行 接收 子程序 
 　 　 sjmpsend ； 否则 ， 执行 发送 子程序 
 recive : mova , sbuf ； 接收数据 
 　 　 clrri 
 　 　 cjnea , # 52h , re ； 是否 接收 到 “ R ” 
 　 　 mova , # 59h ； 是 ， 发送 “ Y ” 
 　 　 movsbuf , a 
 　 　 sjmpendtr 
 re : mov 　 @ rl , a 　 　 ； r1 为 接收数据 存放 地址 
 　 　 incr1 
 　 　 sjmpendtr 
 send : mova , @ r0 ； 发送数据 ， r0 为 存放数据 的 地址 
 　 　 movsbuf , a 
 　 　 jnbti , $ 
 　 　 clrti 
 　 　 incr0 
 endtr : reti ； 中断 返回 
 3 　 结束语 
 　 　 串口 通信 是 一种 广泛应用 于 各个领域 的 通信 方式 ， 由于 目前 大部分 计算机 都 安装 了 Windows95 操作系统 ， 所以 本文 具体 实现 了 在 Windows95 下 利用 它 的 SDK 函数 来 与 单片机 进行 串口 通信 。 本文 所 提出 的 实现 函数 在 所有 当前 流行 软件 如 V C++ 、 Delphi 等 中 都 可 实现 。 它 不仅 可以 用于 近距离 的 RS - 232 通信 ， 而且 ， 还 可以 实现 中 远距离 RS - 485 通信 。 在 使用 该 程序 的 通信 系统 中 ， 近 远距离 的 通信 都 取得 良好 的 效果 。 
 作者 单位 ： 武汉大学 电子信息 学院 ( 430072 ) 
 参考文献 
 　 1 　 MirhoCA , TerrisseA 著 ， 贺军 ， 高胜友 译 . WINDOWS95 通信 编程 . 北京 ： 清华大学出版社 ， 1997 
 　 2 　 陈光东 ， 赵性 初 . 单片微 型 计算机 原理 与 接口技术 . 武汉 ： 华中理工大学 出版社 ， 1993 
 收稿 日期 ： 1998 - 10 - 10 
