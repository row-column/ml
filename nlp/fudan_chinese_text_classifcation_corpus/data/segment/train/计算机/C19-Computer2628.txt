软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年   第 10 卷   第 7 期 　 No.7   Vol.10   1999 
 
 
 
 事务 标识 的 研究 与 实现 
 王意洁 　 王勇军 　 胡守仁 
 　 　 摘要 　 事务 标识 的 分配 是 影响 嵌套 事务 执行 效率 的 重要 因素 之一 . 文章 深入分析 了 在 嵌套 事务 模型 下 ， 事务处理 对 事务 标识 的 需求 . 以此 为 基础 , 提出 了 一系列 实用 有效 的 分配 策略 . 其中 , 基于 位 的 事务 标识 分配 策略 实际 应用 于 自行 研制 的 面向对象 数据库系统 KDOODB ( KeDa   object   oriented   database ) 中 . 最后 给出 了 性能 测试 的 结果 . 
 　 　 关键词 　 数据库 , 事务处理 , 嵌套 事务 , 事务 标识 , 分配 . 
 　 　 中图法 分类号 　 TP311 
 Research   and   Implementation   of   Transaction   Identifier 
 WANG   Yi - jie   WANG   Yong - jun   HU   Shou - ren 
 （ National   Laboratory   of   Parallel   and   Distributed   Processing   Changsha   Institute   of   Technology   Changsha   410073 ） 
 　 　 Abstract 　 The   assignment   of   transaction   identifiers   is   one   of   the   important   factors   influencing   the   per - formance   of   nested   transactions .   In   this   paper ,   the   requirements   which   the   transaction   process   poses   on   the   transaction   identifiers   under   the   nested   transaction   model   are   analysed .   Based   on   this ,   a   series   of   efficient   and   practical   assignment   strategies   are   proposed ,   and   the   bit - based   transaction   identifier   strategy   is   implemented   in   the   object - oriented   database   system — — KDOODB   ( KeDa   object   oriented   database ) .   At   last ,   the   performance   evaluation   results   are   given . 
 　 　 Key   words 　 Database ,   transaction   process ,   nested   transaction ,   transaction   identifier ,   assignment . 
 　 　 事务 标识 （ transaction   identifier ） 的 分配 是 影响 嵌套 事务 ［ 1 ～ 3 ］ 执行 效率 的 一个 重要 因素 , 同时 也 是 一个 极容易 被忽视 的 因素 , 事务 标识 的 分配 不当 将 导致 占用 过多 的 存储空间 和 处理机 时间 . 目前 , 已有 越来越 多 的 系统 开始 提供 对 嵌套 事务 的 支持 , 但是 它们 还 没有 充分考虑 事务 标识 的 分配 问题 . 
 　 　 我们 从 事务处理 对 事务 标识 的 需求 入手 , 结合 嵌套 事务 模型 的 具体 特点 , 提出 了 一系列 实用 、 有效 的 事务 标识 分配 策略 ： 基于 位 的 事务 标识 分配 策略 、 改进 的 事务 标识 分配 策略 和 优化 的 事务 标识 分配 策略 . 它们 将 事务 层次结构 的 有关 信息 有效 地 记录 于 事务 标识 中 . 与 传统 的 基于 树 和 哈希 表 的 策略 相比 , 它们 兼顾 了 对 存储空间 和 处理机 时间 的 有效 利用 , 提高 了 嵌套 事务 的 运行 效率 . 我们 通过 编制 模拟 测试程序 , 对 它们 进行 了 比较 全面 的 性能 评价 . 基于 位 的 事务 标识 分配 策略 具体 在 自行 研制 的 面向对象 数据库系统 KDOODB ( KeDa   object   oriented   database ) 中 实现 , 为 KDOODB 系统 的 有效 事务管理 奠定 了 坚实 的 基础 . 
 1   事务处理 对 事务 标识 的 需求 
 　 　 通常 , 事务处理 系统 由 事务 管理器 、 恢复 管理器 、 锁 管理器 、 死锁 管理器 和 缓存 管理器 构成 . 它们 对 事务 标识 的 需求 可以 归纳 为 ： 
 　 　 （ 1 ） 可以 直接 从子 事务 的 标识 得到 其父 事务 的 标识 ； 
 　 　 （ 2 ） 事务 标识 对 事务 层次结构 的 宽度 和 广度 提供 良好 的 支持 （ 即 对 宽度 和 广度 没有 限制 ） ； 
 　 　 （ 3 ） 事务 标识 存储 结构 能够 提供 足够 多 的 事务 标识 （ 即 对 事务 标识 的 数目 没有 限制 ） ； 
 　 　 （ 4 ） 根据 事务 标识 可以 判断 两个 事务 是否 具有 祖先 - 后代 关系 ； 
 　 　 （ 5 ） 根据 事务 标识 可以 找出 两个 事务 的 最高层 的 非 共同 祖先 ； 
 　 　 （ 6 ） 事务 标识 存储 结构 应该 灵活 , 长度 可变 , 能够 充分利用 存储空间 , 有效 地 存储 长 标识 和 短 标识 . 
 2   事务 标识 分配 策略 
 2.1   基本 策略 
 　 　 我们 对 事务 标识 分配 策略 的 研究 是 以 一种 传统 的 基本 策略 为 基础 的 . 在 这种 基本 策略 中 , 事务 标识 由 一个 可变 长度 的 整型 数组 来 表示 . 对于 顶层 事务 而言 , 表示 事务 标识 的 整型 数组 由 一个 元素 构成 , 随着 事务 层次 的 逐渐 降低 , 表示 事务 标识 的 整型 数组 的 元素 个数 逐渐 增加 . 每当 一个 新 的 子 事务 产生 , 它 的 事务 标识 由 其父 事务 标识 和 一个 用于 与 兄弟 事务 区分 的 新元素 构成 . 这个 基本 策略 比较简单 , 并且 也 基本 满足 了 对 事务 的 某些 需求 （ 即 需求 1 、 需求 4 和 需求 5 ） . 但是 , 它 的 存储空间 开销 很大 . 假设 采用 4 字节 的 长 整数 , 不管 位于 第 N 层 的 事务 有 多少 个 , 每个 N 层 事务 的 标识 都 需要 4 × N 字节 表示 , 这 将 造成 极大 的 空间 浪费 . 
 2.2   基于 位 的 事务 标识 分配 策略 
 　 　 基本 策略 满足 了 对 事务 的 某些 需求 , 可以 说 , 它 具有 一些 比较 好 的 特性 . 但是 , 它 也 有 一个 致命 的 缺点 — — 大量 的 存储空间 浪费 . 在 “ 扬长避短 ” 的 原则 指导 下 , 我们 提出 了 基于 位 的 事务 标识 分配 策略 . 它 对 存储空间 的 使用 是 以位 为 单位 来 考虑 , 而 不是 以长 整数 （ 4 字节 ） 为 单位 来 考虑 的 , 从而 有效 地 避免 了 存储空间 的 浪费 . 
 　 　 在 基于 位 的 事务 标识 分配 策略 中 , 子 事务 的 标识 包含 了 其父 事务 的 标识 , 一个 事务 标识 由 若干个 元素 构成 , 每个 元素 与 事务 层次结构 中 的 一个 层次 相对 应 . 每个 元素 由 一个 基于 位 的 编码序列 表示 , 编码序列 由 编码 单元 组成 , 各 编码 单元 的 值 的 总和 即 为 元素 的 值 . 编码 单元 的 基于 位 的 长度 是 预先 定义 的 , 所以 一个 编码 单元 能够 表示 的 数值 范围 也 是 预先 定义 的 . 当 元素 的 值 超过 一个 编码 单元 的 表示 上限 （ 设 n 是 编码 单元 的 长度 , 即 2n － 1 ） 时 , 将 该 编码 单元 置 为 全满 标志 （ 即 全零 ） , 并 分配 一个 新 的 编码 单元 . 如果 元素 的 值 又 超过 了 两个 编码 单元 的 共同 表示 上限 （ 即 2 × （ 2n － 1 ） ） , 则 再 分配 一个 新 的 编码 单元 . 依此类推 , 直到 满足要求 为止 . 事务 标识 的 第 1 个 编码序列 用于 表示 与 元素 相对 应 的 编码 单元 的 数目 . 
 　 　 实际上 , 在 基于 位 的 事务 标识 分配 策略 （ 如图 1 所示 ） 下 , 事务 标识 由 一系列 编码 单元 构成 , 它们 在 逻辑 上 组成 了 若干个 编码序列 , 每个 编码序列 表示 一个 元素 . 通过 判断 编码 单元 的 具体内容 （ 即 是否 设置 了 全满 标志 ） 来 确定 编码序列 的 开始 与 结束 ： 从 事务 标识 的 第 1 个 编码 单元 开始 , 依次 判断 每 一个 编码 单元 , 直到 找到 第 1 个 未置 全满 标志 的 编码 单元 , 到此为止 便是 第 1 个 编码序列 ； 下 一个 编码 单元 标志 着 第 2 个 编码序列 的 开始 , 依此类推 . 将 编码序列 中 每个 编码 单元 的 值 相加 就 得到 了 相应 的 值 . 编码序列 可以 表示 的 不同 的 值 的 数目 为 N × （ 2n － 1 ） （ 设 N 为 编码 单元 的 数目 ） . 
 
 图 1 　 基于 位 的 事务 标识 分配 策略 的 事务 标识 结构 
 　 　 基于 位 的 事务 标识 分配 策略 满足 了 对 事务 标识 的 各种 需求 . 
 　 　 需求 1 — — 首先 , 读出 事务 标识 的 第 1 个 编码序列 , 得到 与 元素 相对 应 的 编码 单元 的 数目 Sum ； 然后 , 读出 下面 的 第 （ Sum - 1 ） 个 （ 即 倒数第 2 个 ） 编码 单元 , 判断 它 是否 设置 了 全满 标志 ： 若否 , 则 前 （ Sum - 1 ） 个 编码 单元 就 表示 其父 事务 的 标识 ； 若 是 , 则 继续 读出 第 （ Sum - 2 ） 个 （ 即 倒数第 3 个 ） 编码 单元 并 判断 它 是否 设置 了 全满 标志 , 直到 找到 未置 全满 标志 的 编码 单元 （ 设其为 第 （ Sum - k   ） 个 编码 单元 ） , 那么 前 （ Sum - k ） 个 编码 单元 表示 其父 事务 的 标识 （ 如图 1 所示 ） ； 
 　 　 需求 2 — — 由于 对 编码序列 的 长度 和 个数 没有 任何 限制 , 所以 可 支持 任意 宽度 和 广度 的 事务 层次结构 ； 
 　 　 需求 3 — — 由于 对 编码序列 的 长度 和 个数 没有 任何 限制 , 所以 它 提供 的 事务 标识 无 范围 限制 ； 
 　 　 需求 4 — — 通过 判断 长 事务 标识 是否 包含 短 事务 标识 即可 确定 两 事务 是否 有 祖先 - 后代 关系 ； 
 　 　 需求 5 — — 从 第 2 个 编码序列 开始 , 依次 比较 两个 事务 标识 的 编码序列 , 直到 发现 第 1 个 不同 的 编码序列 为止 , 即 找到 了 两个 事务 的 最高层 非 共同 祖先 ； 
 　 　 需求 6 — — 事务 标识 的 存储 结构 长度 可变 , 以位 为 单位 进行 动态 空间 分配 , 而且 无需 编码 单元 计数器 , 因此 能够 更加 充分 地 利用 存储空间 , 有效 地 存储 长 标识 和 短 标识 . 
 2.3   改进 的 事务 标识 分配 策略 
 　 　 基于 位 的 事务 标识 分配 策略 满足 了 对 事务 的 各种 需求 , 它 以位 为 单位 来 使用 存储空间 , 比较 有效 地 避免 了 存储空间 的 浪费 . 通过观察 我们 发现 , 事务 标识 的 元素 值越 大 , 编码序列 中 全满 编码 单元 的 数目 越大 . 实际上 , 在 表示 事务 标识 的 元素 值时 , 只 需 记录 编码序列 中 全满 编码 单元 的 数目 即可 , 而 不必 将 全满 编码 单元 一一 列出 . 为此 , 我们 在 基于 位 的 事务 标识 分配 策略 的 基础 上 , 提出 了 改进 的 事务 标识 分配 策略 . 
 　 　 与 基于 位 的 事务 标识 分配 策略 相比 , 在 改进 的 事务 标识 分配 策略 中 , 对应 于 每个 元素 的 编码序列 由 编码 单元 和 编码 单元 计数器 组成 . 若 元素 的 值 超过 一个 编码 单元 的 表示 上限 （ 设 n 是 编码 单元 的 长度 , 即 2n - 1 ） 时 , 则 将 编码 单元 计数器 的 值加 1 , 并 将 元素 的 值 减去 表示 上限 （ 2n - 1 ） ； 如果 修改 后 的 元素 值 又 超过 了 编码 单元 的 表示 上限 , 则 再 将 编码 单元 计数器 的 值加 1 , 并 将 元素 的 值 减去 表示 上限 （ 2n - 1 ） . 依此类推 , 直到 满足要求 为止 . 我们 利用 编码 单元 计数器 来 记录 一个 编码序列 中 的 编码 单元 （ 包括 全满 编码 单元 ） 的 个数 , 它 位于 编码 单元 的 前面 （ 如图 2 所示 ） . 编码 单元 计数器 由 计数器 单元 构成 , 各 计数器 单元 的 值 的 总和 即 为 元素 的 值 , 计数器 单元 的 长度 也 是 预先 定义 的 . 当 计数器 的 值 超过 一个 计数器 单元 的 表示 上限 （ 设 m 是 计数器 单元 的 长度 , 即 2m - 1 ） 时 , 则 将 该 计数器 单元 置 为 全满 标志 （ 即 全零 ） , 并 分配 一个 新 的 计数器 单元 . 如果 计数器 的 值 又 超过 了 两个 计数器 单元 的 共同 表示 上限 （ 即 2 × （ 2m - 1 ） ） , 则 再 分配 一个 新 的 计数器 单元 . 依此类推 , 直到 满足要求 为止 . 事务 标识 的 第 1 个 编码序列 用于 表示 事务 的 层次 （ 即 事务 标识 的 元素 个数 ） . 
 
 图 2 　 改进 的 事务 标识 分配 策略 的 编码序列 
 　 　 为了 确定 事务 标识 中 某个 元素 的 值 , 首先 , 读出 元素 的 前 m 位 （ m 是 计数器 单元 的 长度 ） , 如果 计数器 单元 被 设置 了 全满 标志 , 则 继续 读出 下面 的 m 位 , 直到 找到 一个 未置 全满 标志 的 计数器 单元 , 将 已 读出 的 计数器 单元 的 值 相加 就 得到 了 计数器 的 值 Num ； 然后 , 读出 下面 的 n 位 （ n 是 编码 单元 的 长度 ） , 得到 编码 单元 的 值 NU ； 那么 , 元素 的 值 为 （ 2n - 1 ） × ( Num － 1 ) ＋ NU . 编码序列 可以 表示 的 不同 的 元素 值 的 数目 为 k × （ 2m - 1 ） × （ 2n - 1 ） （ k 是 计数器 单元 的 个数 ） . 
 　 　 改进 的 事务 标识 分配 策略 较 好 地 满足 了 对 事务 标识 的 各种 需求 . 
 　 　 需求 1 — — 首先 , 读出 事务 标识 的 第 1 个 编码序列 , 得到 事务 的 层次 L ； 然后 , 读出 下面 的 （ L － 1 ） 个 编码序列 , 就 得到 了 其父 事务 的 标识 ； 
 　 　 需求 2 — — 通过 扩展 编码 单元 计数器 的 长度 （ 即 增加 计数器 单元 的 数目 ） , 可以 支持 任意 宽度 和 广度 的 事务 层次结构 ； 
 　 　 需求 3 — — 通过 扩展 编码 单元 计数器 的 长度 , 可以 提供 足够 多 的 事务 标识 ； 
 　 　 需求 4 — — 通过 判断 长 事务 标识 是否 包含 短 事务 标识 , 即可 确定 两个 事务 是否 有 祖先 - 后代 关系 ； 
 　 　 需求 5 — — 从 第 2 个 编码序列 开始 , 依次 比较 两个 事务 标识 的 编码序列 , 直到 发现 第 1 个 不同 的 编码序列 为止 , 即 找到 了 两个 事务 的 最高层 非 共同 祖先 ； 
 　 　 需求 6 — — 事务 标识 的 存储 结构 长度 可变 , 以位 为 单位 进行 动态 空间 分配 , 因此 充分 地 利用 了 存储空间 , 而且 能够 有效 地 存储 长 标识 和 短 标识 . 
 2.4   优化 的 事务 标识 分配 策略 
 　 　 改进 的 事务 标识 分配 策略 较 好 地 满足 了 对 事务 的 各种 需求 , 尤其 是 它 具有 良好 的 可扩展性 . 另外 , 它 通过 省略 全满 编码 单元 来 节省 存储空间 , 但是 , 它 对 编码 单元 计数器 中 的 许多 全满 计数器 单元 并 没有 进行 有效 的 处理 , 所以 , 它 还是 没有 充分利用 存储空间 . 针对 改进 的 事务 标识 分配 策略 的 不足 , 我们 提出 了 优化 的 事务 标识 分配 策略 , 有效 地 处理 了 全满 计数器 单元 , 实现 了 充分利用 存储空间 的 目的 . 
 
 图 3 　 优化 的 事务 标识 分配 策略 的 编码序列 
 　 　 优化 的 事务 标识 分配 策略 的 主要 思想 （ 如图 3 所示 ） 是 ： 元素 仍然 由 基于 位 的 编码序列 表示 , 编码序列 由 编码 单元 和 编码 单元 计数器 组成 ； 编码 单元 的 取值 和 表示 方式 与 基于 位 的 事务 标识 分配 策略 相同 ； 编码 单元 计数器 由 计数器 单元 和 特殊 计数器 构成 , 计数器 单元 的 基于 位 的 长度 是 预先 定义 的 , 所以 一个 计数器 单元 能够 表示 的 数值 范围 也 是 预先 定义 的 . 若 编码 单元 计数器 的 值 超过 一个 计数器 单元 的 表示 上限 （ 设 m 是 编码 单元 的 长度 , 即 2m - 1 ） , 则 将 特殊 计数器 的 值加 1 , 并 将 编码 单元 计数器 的 值 减去 表示 上限 （ 2m - 1 ） ； 如果 修改 后 的 编码 单元 计数器 值 又 超过 了 计数器 单元 的 表示 上限 , 则 再 将 特殊 计数器 的 值加 1 , 并 将 编码 单元 计数器 的 值 减去 表示 上限 （ 2m - 1 ） . 依此类推 , 直到 满足要求 为止 . 我们 利用 特殊 计数器 来 记录 一个 编码序列 中 的 计数器 单元 （ 包括 全满 编码 单元 ） 的 个数 , 它 位于 计数器 单元 的 前面 , 如图 3 所示 . 
 　 　 各 特殊 计数器 单元 的 值 的 总和 即 为 特殊 计数器 的 值 , 特殊 计数器 单元 的 长度 也 是 预先 定义 的 . 当 特殊 计数器 的 值 超过 一个 特殊 计数器 单元 的 表示 上限 （ 设 r 是 特殊 计数器 单元 的 长度 , 即 2r - 1 ） 时 , 则 将 该 特殊 计数器 单元 置 为 全满 标志 （ 即 全零 ） , 并 分配 一个 新 的 特殊 计数器 单元 . 如果 特殊 计数器 的 值 又 超过 了 两个 特殊 计数器 单元 的 共同 表示 上限 （ 即 2 × （ 2r - 1 ） ） , 则 再 分配 一个 新 的 特殊 计数器 单元 . 依此类推 , 直到 满足要求 为止 . 事务 标识 的 第 1 个 编码序列 用于 表示 事务 的 层次 （ 即 事务 标识 的 元素 个数 ） . 
 　 　 为了 确定 事务 标识 中 的 某个 元素 的 值 , 首先 , 读出 元素 的 前 r 位 （ r 是 特殊 计数器 单元 的 长度 ） , 如果 特殊 计数器 单元 被 设置 了 全满 标志 , 则 继续 读出 下面 的 r 位 , 直到 找到 一个 未置 全满 标志 的 特殊 计数器 单元 为止 , 将 已 读出 的 特殊 计数器 单元 的 值 相加 就 得到 了 特殊 计数器 的 值 Num ； 然后 , 读出 下面 的 m 位 （ m 是 计数器 单元 的 长度 ） , 得到 计数器 单元 的 值 NC ； 最后 , 读出 下面 的 n 位 （ n 是 编码 单元 的 长度 ） , 得到 编码 单元 的 值 NU ； 那么 , 元素 的 值 为 （ 2n - 1 ） × ( （ 2m - 1 ） × ( Num － 1 ) ＋ NC － 1 ) ＋ NU . 编码序列 可以 表示 的 不同 的 元素 值 的 数目 为 k × （ 2r - 1 ） × （ 2m - 1 ） × （ 2n - 1 ） （ k 是 特殊 计数器 单元 的 个数 ） . 优化 的 事务 标识 分配 策略 也 能 较 好 地 满足 对 事务 标识 的 各种 需求 . 
 3   性能 评价 
 　 　 为了 合理 评价 基于 位 的 事务 标识 分配 策略 、 改进 的 事务 标识 分配 策略 和 优化 的 事务 标识 分配 策略 的 性能 , 我们 选择 传统 的 事务 标识 分配 策略 作为 对比 测试 对象 , 通过 编制 模拟程序 而 进行 了 大量 的 性能 测试 . 在 分析测试 结果 时 , 我们 发现 , 基于 位 的 事务 标识 分配 策略 、 改进 的 事务 标识 分配 策略 和 优化 的 事务 标识 分配 策略 的 性能 存在 如下 规律 ： 
 　 　 ( 1 )   三者 的 空间 开销 呈 递减 趋势 , 当 事务 层次结构 较 简单 时 , 这种 递减 趋势 不 明显 ； 
 　 　 ( 2 )   三者 的 时间 开销 呈 递增 趋势 , 递增 幅度 较 小 . 
 　 　 鉴于 此 , 这里 主要 介绍 对比 测试 对象 、 环境 以及 基于 位 的 事务 标识 分配 策略 的 对比 测试 结果 . 
 3.1   对比 测试 对象 及 环境 
 　 　 我们 选择 一种 基于 树 的 传统 策略 作为 对比 测试 对象 , 这种 基于 树 的 传统 策略 在 PRIMA 系统 ［ 4 ］ 中 实现 . 它 的 基本 思想 是 ： 事务 由 事务 控制 块 表示 , 事务 控制 块 包括 事务 标识 、 指向 父 事务 控制 块 的 指针 、 指向 第 1 个子 事务 控制 块 的 指针 、 指向 前 一个 兄弟 事务 控制 块 的 指针 、 指向 后 一个 兄弟 事务 控制 块 的 指针 等 信息 ； 每个 事务 的 标识 是 通过 一个 计数器 依次 分配 的 ； 树 的 根 对应 于 顶层 事务 . 
 　 　 我们 利用 C ＋ ＋ 语言 实现 了 传统 策略 和 基于 位 的 事务 标识 分配 策略 , 运行 环境 是 586 微机 （ 166Mhz , 32MB 内存 ） . 用于 测试 的 事务 层次结构 的 深度 取为 30 . 在 基于 位 的 事务 标识 分配 策略 中 , 编码 单元 的 长度 均取 8 位 . 取 100   000 次 运行 结果 的 平均值 作为 测试 结果 . 
 3.2   测试 结果 
 　 　 测试 内容 包括 ： ① 存储空间 利用 情况 ; ② 获得 父 事务 标识 的 时间 开销 ; ③ 判定 祖先 - 后代 关系 的 时间 开销 , 找出 最高层 的 非 共同 祖先 的 时间 开销 . 测试 结果 如下 ： 
 　 　 .   存储空间 利用 情况 
 　 　 为了 便于 比较 , 假定 每个 事务 至多 有 （ 28 - 1 ） 个子 事务 . 在 传统 策略 中 , 用于 标识 事务 和 维护 事务 之间 关系 的 存储空间 大小 是 固定 的 , 与 事务 的 层次 无关 , 每个 事务 需 20 字节 . 在 基于 位 的 事务 标识 分配 策略 中 , 顶层 事务 的 标识 长度 是 2 字节 , 事务 层次 每 增加 一层 , 事务 标识 就 增加 一个 编码序列 （ 1 字节 ） . 如图 4 所示 , 当 事务 层次 小于 19 时 , 基于 位 的 事务 标识 分配 策略 的 事务 标识 所 占用 的 存储空间 少于 传统 策略 的 事务 控制 块 所 占用 的 存储空间 ； 当 事务 层次 大于 19 时 , 基于 位 的 事务 标识 分配 策略 的 事务 标识 所 占用 的 存储空间 多于 传统 策略 的 事务 控制 块 所 占用 的 存储空间 . 
 
 图 4 　 存储空间 利用 情况 
 　 　 .   获得 父 事务 标识 的 时间 开销 
 　 　 在 传统 策略 中 , 为了 得到 某 事务 （ 设其 标识 为 tid ） 的 父 事务 标识 , 首先 , 找到 与 tid 对应 的 事务 控制 块 ； 然后 , 通过 其上 的 指针 找到 父 事务 控制 块 , 得到 父 事务 标识 . 在 基于 位 的 事务 标识 分配 策略 中 , 首先 , 读出 第 1 个 编码序列 , 得到 事务 层次 L ； 然后 依次 读出 下面 的 （ L － 1 ） 个 编码序列 , 就 得到 了 父 事务 标识 . 对于 上述 两种 策略 而言 , 获得 父 事务 标识 的 时间 开销 （ 如图 5 所示 ） 基本 与 事务 层次 无关 . 
 
 图 5 　 获得 父 事务 标识 的 时间 开销 
 　 　 .   判定 祖先 - 后代 关系 的 时间 开销 
 　 　 在 传统 策略 中 , 利用 自 底向上 的 方法 来 判定 事务 之间 的 祖先 - 后代 关系 , 它 的 时间 开销 与 两个 事务 之间 的 层次 差额 有关 . 在 基于 位 的 事务 标识 分配 策略 中 , 从 两个 事务 标识 的 第 2 个 编码序列 开始 , 依次 读取 每个 字节 并 进行 比较 , 从而 判定 事务 之间 的 祖先 - 后代 关系 . 它 的 时间 开销 与 两个 事务 之间 的 层次 差额 无关 , 而 与 短 标识 的 事务 层次 有关 . 为了 便于 比较 , 我们 取子 事务 的 层次 均 为 21 , 通过 改变 父 事务 的 层次 来 观察 时间 开销 的 变化 （ 如图 6 所示 ） . 随着 父 事务 的 层次 增加 , 在 传统 策略 中 , 向上 搜索 的 路径 逐渐 缩短 , 因而 时间 开销 减少 ； 在 基于 位 的 事务 标识 分配 策略 中 , 比较 的 字节数 增加 , 因而 时间 开销 增加 . 
 
 图 6 　 判定 祖先 - 后代 关系 的 时间 开销 
 　 　 .   找出 最高层 的 非 共同 祖先 的 时间 开销 
 　 　 在 传统 策略 中 （ 设 两个 事务 T1 和 T2 的 层次 分别 为 L1 和 L2 , 且 L1 > L2 ） , 首先 , 通过 事务 控制 块 中 的 指针 , 找到 事务 T1 的 位于 层次 L2 上 的 祖先 A1 ； 然后 , 事务 T2 和 事务 A1 同时 利用 指针 自 底向上 搜索 , 并 记录 每次 搜索 到 的 事务 , 直到 找到 第 1 个 相同 的 祖先 , 那么 , 上次 搜索 到 的 事务 便是 最高层 的 非 共同 祖先 , 它 的 时间 开销 和 两个 事务 与非 共同 祖先 之间 的 层次 差额 有关 . 在 基于 位 的 事务 标识 分配 策略 中 , 从 两个 事务 标识 的 第 2 个 编码序列 开始 , 依次 读取 每个 字节 并 进行 比较 , 直到 找到 第 1 个 不同 的 字节 , 从而 找出 最高层 的 非 共同 祖先 , 它 的 时间 开销 与非 共同 祖先 的 层次 有关 . 为了 便于 比较 , 我们 取 两个 事务 的 层次 均 为 21 , 通过 改变 最高层 的 非 共同 祖先 的 层次 来 观察 时间 开销 的 变化 （ 如图 7 所示 ） . 随着 最高层 的 非 共同 祖先 的 层次 增加 , 在 传统 策略 中 , 向上 搜索 的 路径 逐渐 缩短 , 因而 时间 开销 减少 ； 在 基于 位 的 事务 标识 分配 策略 中 , 比较 的 字节数 增加 , 因而 时间 开销 增加 . 
 
 图 7 　 找出 最高层 的 非 共同 祖先 的 时间 开销 
 4   小   结 
 　 　 本文 针对 嵌套 事务 模型 的 执行 效率 , 首先 研究 了 事务处理 对 事务 标识 的 需求 , 在 深入研究 现有 事务 标识 分配 策略 的 基础 上 , 提出 了 一系列 实用 有效 的 事务 标识 分配 策略 ： 基于 位 的 事务 标识 分配 策略 、 改进 的 事务 标识 分配 策略 和 优化 的 事务 标识 分配 策略 . 它们 将 事务 层次结构 的 有关 信息 有效 地 记录 于 事务 标识 中 , 与 传统 策略 的 对比 测试 结果表明 , 它们 兼顾 了 存储空间 和 处理机 时间 的 有效 利用 , 能够 更好 地 满足 事务处理 对 事务 标识 的 各种 需求 , 提高 了 嵌套 事务 的 运行 效率 . 与 基于 位 的 事务 标识 分配 策略 相比 , 改进 的 事务 标识 分配 策略 和 优化 的 事务 标识 分配 策略 能够 更加 有效 地 利用 存储空间 , 但 它们 的 时间 开销 略有 增加 , 这 符合 “ 以 时间 换取 空间 ” 的 规律 . 
 　 　 基于 位 的 事务 标识 分配 策略 具体 实现 于 我们 自行 研制 的 客户 / 服务器 面向对象 数据库系统 KDOODB 中 , 它 为 KDOODB 系统 的 有效 事务管理 奠定 了 坚实 的 基础 . 
 　 　 作者 王意洁 , 女 , 1971 年生 , 博士 , 主要 研究 领域 为 数据库 , 网络 计算 ， 并行 分布 处理 技术 , 神经网络 . 王勇军 , 1971 年生 , 博士 , 主要 研究 领域 为 数据库 , 并行 分布 处理 技术 , 虚拟现实 技术 . 胡守仁 , 1926 年生 , 教授 , 博士生 导师 , 主要 研究 领域 为 面向对象 数据库 , 虚拟现实 , 高性能 机 体系结构 , 并行 分布 处理 技术 . 
 　 　 本文 通讯联系 人 : 王意洁 , 长沙 410073 , 长沙 工学院 计算机系 并行 与 分布 处理 国家 重点 实验室 
 　 　 作者 单位 ： （ 长沙 工学院 并行 与 分布 处理 国家 重点 实验室 　 长沙 　 410073 ） 
 参考文献 
 　 1 　 Harder   T ,   Rothermel   K .   Concurrency   control   issues   in   nested   transactions .   Journal   of   Very   Large   Databases ,   1993 , 2 ( 1 ) : 33 ～ 42 
 　 2 　 Catriel   Beeri ,   Bernstein   P   A ,   Goodman   N .   A   model   for   concurrency   in   nested   transaction   systems .   Journal   of   the   Association   for   Computing   Machinery ,   1989 , 36 ( 2 ) : 230 ～ 269 
 　 3 　 王意洁 , 王勇军 , 胡守仁 . 面向对象 数据库 管理系统 中 的 事务管理 . 计算机科学 , 1996 , 23 ( 6 ) : 59 ～ 62 
 ( Wang   Yi - jie ,   Wang   Yong - jun ,   Hu   Shou - ren .   Transaction   management   in   object - oriented   database   management   sys  tems .   Computer   Science ,   1996 , 23 ( 6 ) : 59 ～ 62 ) 
 　 4 　 Harder   T ,   Meyer - Wegener   K ,   Mitschang   B   et   al .   PRIMA — — a   DBMS   prototype   supporting   engineering   applications .   In :   Agrawal   R ,   Bell   D   eds .   Proceedings   of   the   13th   International   Conference   on   Very   Large   Data   Bases .   San   Mateo ,   CA :   Morgan   Kaufman   Publishers ,   Inc . ,   1987 .   47 ～ 59 
 1998 - 05 - 05 收到 原稿   
 1998 - 08 - 05 收到 修改稿 
