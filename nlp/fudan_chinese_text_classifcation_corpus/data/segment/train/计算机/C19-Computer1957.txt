微型机 与 应用 
 MICROCOMPUTER   &   ITS   APPLICATIONS 
 1999 年   第 18 卷   第 1 期   Vol.18   No.1   1999 
 
 
 
 Java 多线程 技术 在 博奕 程序 中 的 应用 
 禹晓辉 　 蒋晓冬 
 　 　 摘 　 要 ： 如何 在 传统 的 博奕 程序 中 引入 Java 多线程 机制 ， 以 提高 博奕 树 搜索 效率 ， 并 给出 了 1 个 具体 的 应用 实例 。 
 　 　 关键词 ： Java 　 多线程 机制 　 博奕 树 
 　 　 线程 是 操作系统 的 一种 新 概念 ， 是 比 传统 进程 粒度 更 小 的 可 并发 执行 的 单位 。 C 和 C++ 采用 单线程 体系结构 ， 而 Java 却 提供 了 多线程 支持 。 一方面 ， Java 环境 本身 就是 多线程 的 ； 另一方面 ， Java 语言 内置 多线程 控制 ， 提供 了 1 个类 Thread ， 由 它 负责 启动 、 运行 和 终止 线程 ， 并 可 检查 线程 状态 。 Java 的 线程 还 包括 了 用于 对 多线程 实行 并发 控制 的 同步 原语 。 利用 Java 的 多线程 编程 接口 ， 可 方便 地 构筑 支持 多线程 的 应用 ， 提高 程序 的 并发 度 和 执行 效率 。 
 　 　 笔者 曾 参与 开发 了 基于 IBM   Visual   Age   for   Java 环境 的 黑白棋 博奕 程序 。 通过 将 Java 多线程 机制 引入 博奕 树 搜索 ， 明显 加大 了 搜索 平均 深度 ， 取得 了 很 好 的 效果 。 
 1 　 线程 的 概念 及 生命周期 
 　 　 所谓 “ 线程 ” 是 “ 进程 ” 中 某个 单一 顺序 的 控制流 。 新兴 的 操作系统 ， 如 Macos 、 Windows   NT 等 ， 均 把 线程 视为 其 基本 执行 单位 。 线程 也 是 Java 中 相当 重要 的 组成部分 ， 如 任何 1 个 Java   Applet 的 Paint ( ) 和 update ( ) 方法 均 由 AWT 绘图 与 事件处理 线程 所 调用 。 图 1 表示 了 线程 在 它 的 生命周期 中 的 任何时刻 所能 处 的 状态 以及 引起 状态 改变 的 方法 。 
 
 图 1 　 线程 生命周期 
 2 　 博奕 
 　 　 博奕 就是 对策 或 斗智 ， 它 不仅 存在 于 棋类 游戏 中 ， 而且 存在 于 政治 、 经济 、 军事 和 生物 竞争 之中 。 在 人工智能 领域 ， 大多 以 下棋 为 例来 研究 博奕 规律 。 博奕 为 人工智能 提供 了 1 个 很 好 的 试验 场所 ， 人工智能 中 的 许多 概念 和 方法 都 是从 棋类 程序 中 提炼 而 得 ， 博奕 的 许多 研究成果 现已 用于 军事 指挥 和 经济 决策 系统 之中 。 
 　 　 博奕 问题 的 状态 空间 — — 博奕 树是 1 种 特殊 的 与 / 或树 ， 结点 代表 格局 。 所谓 格局 就是 反映 下棋 态势 的 全部 信息 ， 如 棋子 位置 、 轮到 谁 走 下 一步 等 ， 可用 状态变量 表示 。 图 2 是 1 棵 博奕 树 的 局部 。 
 
 图 2 　 博奕 树 局部 
 　 　 在 2 人 零 和 非 偶然性 全 信息 博奕 中 ( 即 对 奕 双方 利益 完全 对立 ) ， 对 奕 双方 都 力图 在 状态 空间 中 找到 1 条使 自己 得分 最多 的 路径 。 设 所有 使 甲方 获胜 的 终局 为 可 解端 结点 ， 得 分为 + b ； 所有 使 乙方 获胜 的 终局 为 不可 解端 结点 ， 得 分为 - b ； 分别 按 甲方 与 乙方 走法 ， 从端 结点 向 根可 一步步 推算出 各 中间 结点 和 根 结点 的 得分 ， 这 就是 对 博奕 树 的 极小 极大 化 分析法 。 
 　 　 然而 ， 即使 1 个 很小 的 博奕 状态 空间 ， 也 可能 生成 十分 庞大 的 博奕 树 ， 它 可能 有 的 终局 数 也 很大 。 企图 对 它们 采用 完整 的 极小 极大 化 分析 是 不 可能 的 ， 实际 可行 的 办法 是 ： 在 1 个 被 分析 的 结点 下面 ， 只 生成 “ 似 合理 的 ” 博奕 树 的 一部分 ( 给定 深度 限制 ， 除去 重复 和 希望 不大 的 分枝 ) ， 并用 得分 函数 f 对树 的 各叶 结点 进行 得分 估值 ， 然后 用 极大 极小 化 分析 计算 树中 各 结点 及根 结点 的 得分 估值 ， 以便 选择 当前 估计 的 最佳 策略 。 这些 计算 所得 的 估值 称为 倒推 估值 ( Back   up   Value ) ， 其 精度 有赖于 得分 函数 。 
 　 　 显然 ， 如何 在 限定 的 时间 内 ( 本 系统 为 5s ) 尽量 提高 搜索 的 深度 是 至关重要 的 。 一般 认为 这 有待 硬件 设施 的 提升 ， 然而 研究 后 发现 ， 在 传统 的 单线程 博奕 程序 中 ， 对手 用于 思考 棋步 的 时间 对 己方 而言 是 闲置 的 ， 而且 也 很 难 被 利用 。 但 在 引入 多线程 机制 后 ， 采用 “ 时间 窃取 ” 的 技术 ， 将 对方 的 思考 时间 转变 为 我方 的 可 利用 时间 ， 用于 增加 搜索 深度 ， 或 在 搜索 深度 不变 条件 下 ， 提高 得分 函数 的 精度 ， 从而 显著 改善 了 博奕 程序 的 整体 性能 。 
 3 　 应用 实例 
 　 　 基于 上述 思想 ， 我们 在 IBM   Visual   Age   for   Java 环境 下 开发 了 黑白棋 博奕 程序 。 下面 给出 该 程序 的 主体 架构 及 涉及 多线程 应用 的 相关 代码 。 为 便于 理解 有 必要 先 将 黑白棋 规则 作 一下 简要 介绍 。 
 　 　 1 . 黑白棋 规则 
 　 　 ( 1 ) 棋盘 为 8 × 8 方格 ， 双方 分别 执 黑白 2 色 棋子 。 
 　 　 ( 2 ) 初始状态 ： 棋盘 中间 4 格 放入 黑 、 白 各 2 棋子 ， 如图 3 ( a ) 。 
 　 　 ( 3 ) 投子 、 吃 子 规则 ( 以 黑子 为例 ) ： 
 　 　 ① 当黑棋 落子 时 ， 以此 格为 中心 分别 沿 8 个 方向 ( 上 、 下 、 左 、 右 、 左 上 、 右 上 、 左 下 、 右 下 ) 来 寻找 原有 的 黑白子 ， 若 在 某个 方向 上 找到 的 第一个 黑子 与 刚 投下 的 黑子 间 无 空格 ， 则 这 2 个 黑子 间 的 所有 白子 变为 黑子 ， 如图 3 ( b ) 、 图 3 ( c ) 。 
 
 
 图 3 　 黑白棋 规则 
 　 　 ② 黑子 若 找 不到 使白棋 变为 黑色 的 走法 ， 则 必须 放弃 一步 ， 由 对方 走棋 ； 若 找 得到 ， 则 不能 放弃 该步 。 
 　 　 ③ 胜负 判定 ， 当 双方 均 放弃 一步 或 棋盘 上 放满 棋子 时 ， 清点 棋盘 上 的 两色 棋子 ， 多者 获胜 。 
 　 　 2 . 程序设计 要求 
 　 　 ( 1 ) 由 计算机 和 玩家 各执 一色 棋子 ， 在 棋盘 中放棋 。 玩家 可 选择 先手 或 后 手 。 
 　 　 ( 2 ) 程序 走 每 一步棋 的 计算 时间 限制 为 5s ( Pentium   75 , 32MB   RAM ) ， 超时 则 由 程序 强制 落子 。 
 　 　 3 . 程序设计 
 　 　 ( 1 ) 本 软件 是 1 个 Applet ， 程序 中 定义 实现 了 4 个类 ： 
 　 　 Reversi ： 是 整个 Applet 的 骨架 ， 负责 用户界面 的 管理 ； 
 　 　 RevBoard ： 负责 与 棋局 相关 的 各 程序 成分 ， 如 搜索器 、 棋局 存储 等 程序 的 调度 ； 
 　 　 RevSearch ： 搜索器 ； 
 　 　 RevPlate ： 定义 了 棋局 的 内部 存储 结构 及 1 组 维护 方法 。 
 　 　 ( 2 ) 本 软件 运行 过程 中 ， 将 有 2 个 线程 th - search , th - sleep 并行执行 ， 如图 4 所示 ( 假定 玩家 先 手 ) 。 
 
 图 4 　 th - search   和   th - sleep   的 运行 状态 
 　 　 当 Applet 开始运行 时 ， 启动 th - search 线程 ， 开始 搜索 ； 当 玩家 落子 后 ， 即 启动 th - sleep 线程 ， 并 立刻 执行 sleep ( 5000 ) ， 进行 睡眠 状态 。 th - search 执行 搜索 。 5s 后 ， th - sleep 醒来 ， 要求 th - search 提供 搜索 结果 ， 并 由 相关 程序 据此 落子 ， 而 th - sleep 则 转为 suspend 状态 ， 此时 玩家 在 思考 ， 而 th - search 的 搜索 也 在 进行 。 当 对方 落子 后 ， 又 重新启动 th - sleep 线程 ， 如此 周而复始 ， 直到 程序 结束 。 可以 看出 th - sleep 实际上 起到 了 1 个 计时器 的 作用 。 
 　 　 ( 3 ) 程序代码 
 　 　 public   class   Reversi   extends   Applet   Revboard   board ; 
 　 　 { 
 　 　 　 / / 界 构造 部分 程序 略 
 　 　 } 
 　 　 public   class   RevBoard   extends   Panel 
 　 　 { 
 　 　 　 RevPlate   plate ; / / 棋局 
 　 　 　 RevSearch   searcher ; / / 搜索器 
 　 　 　 public   RevBoard ( ) ; 
 　 　 　 plate = new   RevPlate ( ) ; 
 　 　 　 Plate , Init ( ) ; / / 创建 棋局 并 初始化 
 　 　 　 searcher = new   RevSearch ( ) ; 
 　 　 　 search . Search ( plate ) / / 启动 搜索 线程 
 　 　 　 Thread   th - sleep ; 
 　 　 public   boolean   mouseDown ( Event   evt , int   x , int   y ) 
 　 　 { 
 　 　 　 / / 玩家 落子 时 所 做 处理 
 　 　 　 if ( plate . valid ( x , y ) / / 如果 落子 位置 有效 
 　 　 　 / / 落子 记录 ， 重画 棋盘 
 　 　 　 / / Searcher 针对 落子 情况 作 相应 调整 
 　 　 　 if ( th - sleep = = null ) / / 若 th - sleep 未 创建 
 　 　 　 { 
 　 　 　 　 th - sleep = new   Thread ( this ) ; 
 　 　 　 　 th - sleep . start ( ) ; 
 　 　 　 } 
 　 　 　 else 
 　 　 　 th - sleep   resume ( ) ; 
 　 　 } 
 　 　 Public   void   run ( ) / / th - sleep 线程 的 主要 执行 部分 
 　 　 { 
 　 　 　 while ( true ) 
 　 　 　 { 
 　 　 　 　 try { 
 　 　 　 　 　 Thread   sleep ( 5000 ) ; 
 　 　 　 　 } catch ( Exception   e ) ; 
 　 　 　 　 getAnswer ( ) ; / / 取 搜索 结果 
 　 　 　 　 th - sleep   suspend ( ) ; 
 　 　 　 } 
 　 　 } 
 } 
 Class   RevSearch   implements   Runnalbe 
 { 
 　 　 RevBoard   board ; 
 　 　 Thread   th - search ; / / 搜索 线程 
 　 　 void   search ( RevPlate   plate ) 
 　 　 { 
 　 　 　 if ( th - search = = null ) / / 若 th - search 尚未 创建 
 　 　 　 { 
 　 　 　 　 th - search = new   Thread ( this ) ; 
 　 　 　 　 th - search . start ( ) ; 
 　 　 　 } 
 　 　 } 
 　 　 　 Public   Void   run ( ) / / th - search   的 实际 执行 部分 
 　 　 　 { 
 　 　 　 } 
 　 　 } 
 　 　 class   RevPlate 
 　 　 { / / 略 } 
 4 　 结束语 
 　 　 由于 引入 了 多线程 技术 ， 本 软件 取得 了 很 好 的 效果 。 在 IBM   Pentium   75 、 32MB 内存 机器 上 ， 利用 α — β 剪枝 方法 构造 博奕 树 ， 结果 5s 内 平均 搜索 深度 达 4 层 ， 访问 状态 结点 达 7000 个 ， 与 没 采用 多线程 技术 的 程序 相比 ， 效率 提高 了 1.5 ～ 2 倍 。 实践证明 ， Java 多线程 机制 具有 很 高 的 实用价值 。 事实上 ， 由于 多线程 的 核心思想 即 并行 ， 因此 ， 在 基于 多处理机 的 系统 上 ， 多线程 机制 的 威力 必将 得到 更 大程度 的 发挥 。 此外 ， Java 多线程 技术 的 应用 也 不仅仅 局限于 上述 的 博奕 领域 ， 如何 将 Java 多线程 技术 广泛应用 到 分布式系统 中 ， 是 需要 深入探讨 的 问题 。 
 作者 单位 ： 南京大学 计算机科学 与 信息 系 ( 210093 ) 
 参考文献 
 　 1 　 蔡自兴 ， 徐光 皊 . 人工智能 及其 应用 . 北京 ： 清华大学出版社 ， 1996 
 　 2 　 Vanhelsuwe   L 著 ， 邱仲 潘译 . Java 从 入门 到 精通 . 北京 ： 电子 工业 出版社 ， 1997 
 ( 收稿 日期 ： 1998 - 09 - 01 ) 
