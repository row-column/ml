软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年 　 第 10 卷 　 第 11 期 　 Vol.10 　 No.11 　 1999 
 
 
 
 一类 树型 知识库 的 更新 算法 
 马绍汉   陶雪红 
 　 　 摘要 　 知识库 的 更新 意即 向 知识库 中 添加 新 知识 ， 同时 为 维护 相容性 而 删除 旧 知识 . 已有 的 知识库 更新 方法 在 通常 情况 下 都 是 难解 的 . 该文 从 限制 问题 的 结构 出发 ， 给出 了 一种 当 知识库 对应 的 约束 图为 树时 的 多项式 时间 更新 算法 . 在 树型 约束 图中 ， 算法 通过 一个 自 底向上 的 过程 ， 得到 更新 后 的 知识库 . 
 　 　 关键词 　 人工智能 ， 知识库 更新 ， 算法 复杂性 ， 约束 图 ， 约束 可 满足 问题 . 
 　 　 中图法 分类号 　 TP182 
 A   Tree - like   Knowledge   Base   Revision   Algorithm 
 MA   Shao - han   TAO   Xue - hong 
 ( Department   of   Computer   Science   Shandong   University   Ji ' nan   250100 ) 
 　 　 Abstract 　   Knowledge   base   revision   is   to   add   new   knowledge   into   the   knowledge   base ,   and   to   delete   old   knowledge   if   it   is   necessary   for   preserving   consistency .   The   recently   proposed   knowledge   base   revision   methods   are   all   intractable   in   general   case .   By   restricting   the   structure   of   the   knowledge   base ,   a   polynomial   revision   algorithm   is   given   in   this   paper   when   the   corresponding   constraint   graph   of   the   knowledge   base   is   a   tree .   In   the   constraint   tree ,   the   authors   use   a   bottom - up   process   to   get   the   revision   knowledge   base . 
 　 　 Key   words 　 Artificial   intelligence ,   knowledge   base   revision ,   algorithmic   complexity ,   constraint   graph ,   constraint   satisfiability   problem . 
 　 　 知识库 在 人工智能 研究 中 占有 重要 地位 . Ginsberg 等 人 介绍 了 多种 知识库 更新 方法 ， 其中 一类 是 基于 模型 的 方法 ， 一类 是 基于 公式 的 方法 ， 但 所有 这些 方法 在 通常 情况 下 都 是 难解 的 ( intractable ) ［ 1 ］ . 对 基于 模型 的 方法 ， 文献 ［ 1 ］ 中 指出 ， 当 知识库 是 Horn 公式 的 集合 ， 新 知识 是 Horn 公式 且 长度 有 一 常数 上界时 ， 存在 多项式 时间 算法 ； 对 基于 公式 的 方法 ， 我们 在 文献 ［ 2 ～ 4 ］ 中 给出 了 几类 特殊 条件 下 的 多项式 时间 算法 . 
 1   基本概念 
 　 　 本文 在 命题逻辑 的 范围 内 讨论 知识库 的 更新 . 我们 用 T 表示 知识库 ， 知识库 是 命题 公式 的 有限 集 ， 用 p 表示 要 加入 的 新 知识 . 给定 知识库 T 和 公式 p ， T 。 p 表示 向 知识库 T 中 加入 新 知识 p 更新 后 的 知识库 . “ 。 ” 称为 更新 操作符 ， 常用 下标 表示 所 采用 的 更新 方法 . 我们 用 符号 “ ～ ” 表示 否定 . 
 　 　 定义 1 ［ 1 ］ .   Ginsberg 更新 方法 . 令 T 是 可 满足 的 知识库 ， p 是 可 满足 的 新 知识 ， 令 
 
 即 W ( p , T ) 是 T 中 所有 与 p 相容 的 极大 命题 公式 集 的 集合 . 则 
 T 。 Gp = { T ′ ∪ { p } | T ′ ∈ W ( p , T ) } . 
 　 　 例 ： T = { a , b , a ∧ bc } , p = ～ c , 则 
 
 因此 
 
 　 　 定义 2 . ［ 1 ］   WIDTIO ( when   in   doubt   throw   it   out ) 更新 方法 . 定义 
 
 用 这种 方法 , 在 最坏 情况 下 , T 中 的 所有 公式 均 被 抛弃 . 如对 上例 中 的 T 和 p ， 则 T 。 widp = { ～ c } . 
 　 　 本文 将 重点 讨论 WIDTIO 更新 方法 . 
 2   算法 设计 与 分析 
 　 　 问题 结构 与 求解 复杂性 密切相关 . 直观 上 看 ， 知识库 中 各 知识 之间 的 联系 越 密切 ， 加入 新 知识 时 判断 和 消除矛盾 就 越 复杂 . 为 寻找 可解 算法 ， 我们 将 对 知识 间 的 联系 进行 限制 . 在 Rina   Dechter 等 人 对 约束 可 满足 问题 ( constraint   satisfiability   problem ) 和 真值 维护 ( truth   maintenence ) 的 研究 中 ， 限制 问题 的 结构 为树型 ， 得到 若干 有效 算法 ［ 5 , 6 ］ . 我们 将 这种 思想 用于 知识库 更新 ， 限制 知识库 结构 为树型 ， 找到 一个 多项式 时间 算法 . 
 2.1   约束 图 
 　 　 我们 用 图来 描述 知识库 中 公式 间 的 关系 ， 将 每个 公式 表示 为 图 中 的 一个 结点 ， 若 两 公式 有 一个 共享 变量 ， 则 图 中 相应 两 结点 间 存在 一条 边 ， 边用 共享 变量 标记 . 我们 称 这种 图为 约束 图 , 类似 于 约束 可 满足 问题 中 的 对偶 约束 图 ( dual   constraint   graph ) ［ 7 ］ . 
 　 　 例如 ： T = { a , b , a ∧ bc } ， 则 相应 约束 图如图 1 所示 . 
 
 图 1 
 　 　 若 一个 知识库 的 约束 图为 若干 树 的 集合 ， 称为 树型 知识库 . 在 树型 知识库 中 ， 任意 两 公式 间 至多 有 1 个 共享 变量 ， 至多 有 两个 公式 包含 同一个 变量 . 可见 ， 树型 知识库 各 公式 间 联系 较 简单 . 本文 仅 讨论 知识库 的 约束 图为 树型 的 简单 情况 . 
 2.2   算法 思想 
 　 　 定义 3 .   删除 集 . 对 公式 集 T ， 可 找到 一个 极大 相容 集 U ( 即 不 存在 另 一 相容 集 ST 且 US ) ， 我们 将 T - U 称做 极小 删除 集 . 这种 极小 删除 集可有 多个 ， 将 T 的 所有 极小 删除 集 的 并 集 称做 T 的 删除 集 . 
 　 　 从 公式 集 T 中 去掉 删除 集 ， 可 使 公式 集 相容 ， 此时 公式 集中 的 公式 即 为 出现 在 所有 极大 相容 集中 的 公式 . 求 T 。 widp 的 算法 即 从求 删除 集 入手 . 
 　 　 算法 首先 构造 T ∪ { p } 的 约束 图 ， 约束 图 可能 有 多个 连通分支 ， p 的 加入 仅 可能 与 包含 p 的 分支 内 的 公式 发生 矛盾 ， 对 其他 分支 无 影响 ， 因此 , 只 需 考虑 包含 p 的 分支 . 若该 分支 为树 ， 可 采用 我们 提出 的 算法 . 因为 p 一定 要 属于 更新 后 的 知识库 ， 我们 将 p 作为 根 结点 进行 特殊 处理 . 
 　 　 考虑 以 p 为根 的 树中 一子 树 . 设根为 公式 R ， 通过 共享 变量 C1 , C2 , ... , Ck 与 各子 树 相连 ( 如图 2 所示 ) . 
 
 图 2 
 　 　 设对 每个 子树 ， 当 Ci 为 0 和 1 时 ， Ti 的 删除 集均 已知 . 由于 原 知识库 是 可 满足 的 ， 对 任一 子树 Ti ， 对 Ci = 0 或 Ci = 1 ， 至少 在 一种 情况 下 Ti 可 满足 ， 即 其 删除 集为 空 . 否则 ， 若 不论 Ci 取 0 或 1 ， Ti 都 不 满足 ， 则 说明 原 知识库 不可 满足 . 
 　 　 对于 C1 , C2 , ... , Ck 的 一组 确定 值 ， 整个 树 可以 看做 由 R , T1 , T2 , ... , Tk 这 K + 1 个 独立 部分 组成 . T1 , T2 , ... , Tk 的 删除 集 已知 ， R 的 删除 集 也 可知 ( 若 对于 这组值 来说 , R 为 真 ， 则 删除 集为 空 ； 否则 为 { R } ) . 这 K + 1 部分 删除 集 的 并 集即 为 整个 树 在 C1 , C2 , ... , Ck 为 这 组值 时 的 删除 集 . 遍历 C1 , C2 , ... , Ck 的 所有 值 ， 可 得 若干 特定 值时 的 删除 集 . 求 这些 集合 的 极小 集 ， 再求 并 集 ， 即 得到 整个 树 的 删除 集 . 因此 ， 由子 树 的 删除 集可得 整个 树 的 删除 集 . 算法 即 根据 这种 思想 设计 的 . 
 　 　 算法 在 以 p 为根 的 树 中 ， 自 底向上 ( 保证 处理 某 结点 时其 所有 子 结点 均 处理完毕 ) ， 逐步 求子 树 的 删除 集 ， 这个 过程 一直 进行 到 根 结点 ， 至此 ， 得到 整个 树 的 删除 集 ， 进而 得到 T 。 widp . 
 2.3   算法 描述 
 　 　 算法 中 ， 约束 图 的 每个 结点 保存 一张 真值表 ， 其 结构 见表 1 . 其中 P 表示 与 父 结点 的 共享 变量 ( 根 结点 无 此项 ) ; C1 , C2 , ... , Ck 表示 与 k 个子 结点 的 共享 变量 ( 叶 结点 无 此项 ) ; V 表示 公式 的 真假 值 . 
 表 1 
 
 PC1C2 ... CkV 
 000 ... 00 
 .................. 
 111 ... 11 
 
 　 　 真值表 中 的 每 一行 称做 一项 . 一个 结点 ， 除 与 父 结点 、 子 结点 的 共享 变量 外 ， 还 可能 有 其他 变量 ， 设为 Y1 , Y2 , ... , Yj , 这些 变量 均 不列 在 真值表 中 . 对 P 和 C1 , C2 , ... , Ck 的 一组 值 来说 ， 若 存在 Y1 , Y2 , ... , Yj 的 一组 值使 公式 为 真 ， 则 真值表 中 V 值为 1 ( 真 ) ， 否则 为 0 ( 假 ) . 这 说明 , 在 共享 变量 一定 时 ， 即 在 不 影响 其他 公式 时 ， 尽量 使该 公式 为 真 . 这样 ， 尽量 多地 保留 了 原有 知识 ， 体现 了 “ 极小 修改 ” 的 原则 . 
 　 　 每个 结点 中 还 保存 一 数组 S , S ［ 0 ］ 记录 P ( 与 父 结点 的 共享 变量 ) 为 0 时以 该 结点 为根 的 子树 的 删除 集 , S ［ 1 ］ 记录 P 为 1 时以 该 结点 为根 的 子树 的 删除 集 . 为 表达清晰 , 我们 用 NODE . S 表示 结点 NODE 的 数组 S . 
 　 　 下面 给出 采用 WIDTIO 方法 进行 更新 的 算法 . 
 　 　 算法 .   REVISION1 . 
 　 　 输入 :   非空且 可 满足 知识库 T = { f1 , f2 , ... , fn } ， 可 满足 新 知识 p 
 　 　 输出 :   T 。 wid   p 
 　 　 Step1 . 
 　 　 ( 1.1 )   构造 T ∪ { p } 的 约束 图 . 
 　 　 ( 1.2 )   如果 p 为 图 中 一个 孤立 的 结点 ， 输出   T 。 widp = T ∪ { p } , 算法 结束 . 
 　 　 ( 1.3 )   如果 p 所在 分支 不是 树 , 输出 “ 此 算法 无法 更新 ” , 算法 结束 . 
 　 　 ( 1.4 )   在 以 p 为根 的 树 中 ， 计算 各 结点 的 真值表 . 
 　 　 Step2 . 
 　 　 在 以 p 为根 的 树 中 ， 自 底向上 ( 保证 处理 某 结点 时 ， 其子 结点 已 处理完毕 ) ， 对 每个 结点 NODE ， 做 : 
 　 　 ( 2.1 )   如果 NODE 为叶 结点 : 
 　 　 　 　 　 若 P = 0 时 V = 0 ， 则 S ［ 0 ］ = { NODE } ， S ［ 1 ］ = ; 
 　 　 　 　 　 若 P = 1 时 V = 0 ， 则 S ［ 1 ］ = { NODE } ， S ［ 0 ］ = . 
 　 　 ( 2.2 )   如果 NODE 为 中间 结点 ( 各子 结点 分别 记作 CHILD1 ， CHILD2 ， ... ， CHILDk ， 将 NODE 与 CHILDi 的 共享 变量 记做 Ci ) ： 
 　 　 　 　 　 对 NODE 真值表 中 P = 0 的 每一项 j ， 设 C1 ， C2 ， ... ， Ck 取值 分别 为 u1 , u2 , ... , uk , 
 　 　 　 　 　 令其 对应 集合 Dj = CHILD1 . S ［ u1 ］ ∪ CHILD2 . S ［ u2 ］ ∪ ... ∪ CHILDk . S ［ uk ］ , 
 　 　 　 　 　 若 V = 0 , Dj = Dj ∪ { NODE } , 
 　 　 　 　 　 求 这些 P = 0 的 项 对应 的 集合 的 极小 集合 ， 再求 这些 极小 集合 的 并 集 ， 即得 NODE . S ［ 0 ］ . 
 　 　 　 　 　 对 P = 1 的 每一项 进行 同样 的 操作 ， 得 NODE . S ［ 1 ］ . 
 　 　 ( 2.3 )   如果 NODE 为根 结点 :   / *   根 结点 ( 即 新 知识 p ) 一定 要 为 真 ， 因此 ， 只 考虑 V = 1 的 项 .   * / 
 对 V = 1 的 每一项 j ， 设 C1 , C2 , ... , Ck 取值 分别 为 u1 , u2 , ... , uk ， 
 令其 对应 集合 Dj = CHILD1 . S ［ u1 ］ ∪ CHILD2 . S ［ u2 ］ ∪ ... ∪ CHILDk . S ［ uk ］ , 
 求 这些 集合 的 极小 集合 ， 将 这些 极小 集合 的 并 集记 做 U . 
 　 　 Step3 . 
 　 　 输出 T 。 widp = ( T - U ) ∪ { p } ( 即 从 T 中 删除 U 中 公式 , 再 加入 p ) . 
 　 　 在 ( 2.2 ) 中 ， 真值表 的 每一项 j 对应 一 集合 Dj ， Dj 是 各子 树及 NODE 在 该 取值 时 删除 集 的 并 集 . 由于 子树 的 两个 删除 集 S ［ 0 ］ 和 S ［ 1 ］ 至多 1 个 非空 ， NODE 的 删除 集 或 为 空 或 为 { NODE } ， Dj 实际上 是 选择 各子 树及 NODE 非空 删除 集 的 并 集 . 于是 ， 真值表 中 每一项 对应 着 对 非空 删除 集 的 一种 选择 . 因此 ， 求 集合 的 极小 集再求 并 集 ， 可简化 为求 这种 选择 的 极小 集及 并 集 . 我们 可用 k + 1 维 数组 W 记录 这种 选择 ， W ［ 1 ］ ～ W ［ k ］ 对应 子树 ， 若 CHILDi . S ［ ui ］ = , 令 W ［ i ］ = 0 ， 否则 , W ［ i ］ = 1 ； W ［ k + 1 ］ 对应 NODE ， 若 V = 1 ， 则 W ［ k + 1 ］ = 0 ； 否则 , W ［ k + 1 ］ = 1 . 于是 , 数组 为 1 的 项 说明 选中 子树 或 NODE 的 非空 删除 集 ， 为 0 表示 没 选中 . 例如 ， 对 NODE 真值表 中 ( C1C2C3V ) = ( 1010 ) 的 一项 ， 按 算法 
 D = CHILD1 . S ［ u1 ］ ∪ CHILD2 . S ［ u2 ］ ∪ CHILD3 . S ［ u3 ］ ∪ { NODE } , 
 若 CHILD1 . S ［ u1 ］ ＜ ＞ , CHILD2 . S ［ u2 ］ ＜ ＞ , CHILD3 . S ［ u3 ］ = , 则 D 实际上 是 CHILD1 ， CHILD2 和 NODE 非空 删除 集 的 并 集 . 用 数组 记录 这种 选择 , 则 W = ( 1101 ) . 这样 ， 可 使 真值表 中 每一项 对应 一 数组 ， 我们 仅 需 对 这些 数组 进行 相应 处理 ， 最后 再 由 数组 对应 出 删除 集 . 我们 将 据此 对 算法 进行 简化 . 
 　 　 我们 通过 对 真值表 进行 修改 , 使 其 起到 上述 数组 W 的 作用 . 修改 前 , 真值表 中 关于 C1 , C2 , ... , Ck , V 的 一项 ( u1 , u2 , ... , uk , v ) ， 表示 变量 C1 , C2 , ... , Ck 值为 u1 , u2 , ... , uk 时 ， 公式 值为 v ； 修改 后 ， 变为 该项 对应 的 数组 ， 记录 对 非空 删除 集 的 一种 选择 . 另外 ， 每 结点 设 k + 1 维 数组 W 记录 对 修改 后 真值表 处理 的 最终 结果 . 每 结点 还设 k 维 数组 Flag , 若 CHILDi . S ［ 1 ］ < > ， 则 Flag ［ i ］ = 1 ， 否则 , Flag ［ i ］ = 0 . 这样 ， 若 已知 选中 CHILDi 的 非空 删除 集 ， 可 由 Flag ［ i ］ 判断 该 非空 删除 集是 S ［ 0 ］ 还是 S ［ 1 ］ . 
 　 　 我们 将 REVISION1 的 ( 2.2 ) 和 ( 2.3 ) 进行 改进 ， 得到 如下 算法 . 
 　 　 算法 .   REVISION2 . 
 　 　 输入 :   非空且 可 满足 知识库 T = { f1 , f2 , ... , fn } ， 可 满足 新 知识 p 
 　 　 输出 :   T 。 widp 
 　 　 Step1 . 
 　 　 ( 1.1 )   构造 T ∪ { p } 的 约束 图 . 
 　 　 ( 1.2 )   如果 p 为 图 中 的 一个 孤立 的 结点 ， 输出   T 。 widp = T ∪ { p } , 算法 结束 . 
 　 　 ( 1.3 )   如果 p 所在 分支 不是 树 , 输出 “ 此 算法 无法 更新 ” , 算法 结束 . 
 　 　 ( 1.4 )   在 以 p 为根 的 树 中 ， 计算 各 结点 的 真值表 . 
 　 　 Step2 . 
 　 　 在 以 p 为根 的 树 中 ， 自 底向上 ( 保证 处理 某 结点 时 ， 其子 结点 已 处理完毕 ) ， 对 每个 结点 NODE ， 做 : 
 　 　 ( 2.1 )   如果 NODE 为叶 结点 : 
 　 　 　 　 　 若 P = 0 时 V = 0 ， 则 S ［ 0 ］ = { NODE } ， S ［ 1 ］ = ; 
 　 　 　 　 　 若 P = 1 时 V = 0 ， 则 S ［ 1 ］ = { NODE } ， S ［ 0 ］ = . 
 　 　 ( 2.2 )   如果 NODE 为 中间 结点 ： 
 　 　 ( 2.2 . 1 )   / * 修改 真值表 * / 
 　 　 　 　 　 将 NODE 真值表 中 各项 的 V 值 取反 ( 即 1 置 0 ， 0 置 1 ) . 
 　 　 　 　 　 对于 与 NODE 连接 的 每个 子 结点 ( 各子 结点 分别 记做 CHILD1 ， CHILD2 ， ... ， CHILDk ， 将 NODE 与 CHILDi 的 共享 变量 记做 Ci ) ， 做 ： 
 　 　 　 　 　 如果 CHILDi . S ［ 0 ］ = CHILDi . S ［ 1 ］ = , 　 　 　 / *   子树 可 满足 ， 两个 删除 集均 空   * / 
 　 　 　 　 　 　 　 将 NODE 真值表 中 各项 的 Ci 值 全置 0 ， 
 　 　 　 　 　 　 　 Flag ［ i ］ = 0 ; 
 　 　 　 　 　 如果 只有 CHILDi . S ［ 0 ］ < > , / *   Ci 为 0 时子 树有 非空 删除 集   * / 
 　 　 　 　 　 　 　 将 NODE 真值表 中 各项 的 Ci 值 取反 ( 即 1 置 0 , 0 置 1 ) ， 
 　 　 　 　 　 　 　 Flag ［ i ］ = 0 ; 
 　 　 　 　 　 如果 只有 CHILDi . S ［ 1 ］ < > , / *   Ci 为 1 时子 树有 非空 删除 集   * / 
 　 　 　 　 　 　 　 Flag ［ i ］ = 1 . 
 　 　 ( 2.2 . 2 )   / *   求 删除 集   * / 
 　 　 　 　 　 对 NODE 中 P = 0 的 所有 项 : 
 　 　 　 　 　 / *   ①   类似 求 极小 集合 ， ②   类似 求 并 集 ， ③   由 数组 得 删除 集   * / 
 　 　 　 　 　 ①   只要 存在 关于 C1 , C2 , ... , Ck , V 的 两项 α , β , 并且 α ∧ β = α , 则 将 β 删除 , 其中 ∧ 为 按位 与 . 
 　 　 　 　 　 ②   对 剩余 所有 项 按位 或 , 结果 是 K + 1 维 数组 , 记做 W . 
 　 　 　 　 　 ③   NODE . S ［ 0 ］ = 
 　 　 　 　 　 　 从 i = 1 到 k ， 　 　 　 　 / *   W ［ 1 ］ ～ W ［ k ］ 对应 子树 的 删除 集   * / 
 　 　 　 　 　 　 　 　 若 W ［ i ］ = 1 ， 则 NODE . S ［ 0 ］ = NODE . S ［ 0 ］ ∪ CHILIi . S ［ Flay ［ i ］ ］ 
 　 　 　 　 　 　 若 W ［ k + 1 ］ = 1 / *   W ［ k + 1 ］ 对应 NODE 的 删除 集   * / 
 　 　 　 　 　 　 　 　 NODE . S ［ 0 ］ = NODE . S ［ 0 ］ ∪ { NODE } 
 　 　 　 　 　 　 对 P = 1 的 所有 项 进行 同样 的 操作 , 可得 NODE . S ［ 1 ］ . 
 　 　 ( 2.3 )   如果 NODE 为根 结点 : 
 　 　 ( 2.3 . 1 )   同 ( 2.2 . 1 ) 
 　 　 ( 2.3 . 2 )   删除 NODE 中 V = 1 的 所有 项 ， 对 剩余 项 , 做 ： 
 　 　 　 　 　 　 / *   即 删除 真值表 修改 前 V = 0 的 项 ， 保证 根 结点 ( 即 新 知识 p ) 为 真   * / 
 　 　 　 　 　 　 ①   只要 存在 关于 C1 , C2 , ... , Ck , V 的 两项 α , β , 并且 α ∧ β = α , 则 将 β 删除 , 其中 ∧ 为 按位 与 . 
 　 　 　 　 　 　 ②   对 剩余 所有 项 按位 或 , 结果 是 K + 1 维 数组 , 记做 W . 
 　 　 　 　 　 　 ③   U = 
 　 　 　 　 　 　 　 从 i = 1 到 k ， 　 　 　 　 / *   W ［ 1 ］ ～ W ［ k ］ 对应 子树 的 删除 集   * / 
 　 　 　 　 　 　 　 若 W ［ i ］ = 1 ,   则   U = U ∪ CHILDi . S ［ Flag ［ i ］ ］ . 
 　 　 Step3 . 
 　 　 输出 T 。 widp = ( T - U ) ∪ { p } ( 即 从 T 中 删除 U 中 公式 , 再 加入 p ) . 
 　 　 若 T ∪ { p } 可 表示 为 树形 结构 , 在 以 p 为根 的 树 中 ， 子 结点 的 左右 顺序 是 无关 的 ， 因此 该树 唯一 确定 . 该 算法 采用 自 底向上 的 过程 ， 由叶 结点 开始 ， 不断 由子 树 的 删除 集 得到 树 的 删除 集 . 叶 结点 的 删除 集可 根据 公式 真假 直接判断 ； 在 由子 树 的 删除 集求 树 的 删除 集时 , 遍历 了 共享 变量 的 所有 取值 ， 若树 的 删除 集 存在 ， 则 一定 可 找到 . 因此 ， 在 以 p 为根 的 树 中 ， 我们 一定 能 正确 找到 删除 集 ， 进而 得到 T 。 widp . 算法 的 正确性 即 由此 得到 保证 . 
 2.4   算法 分析 
 　 　 下面 我们 分析 REVISION2 的 时间 复杂性 . 设 T 中有 n 个 公式 ， T 中 的 公式 和 p 的 长度 有 常数 上界 r . 
 找出 两 公式 间 的 共享 变量 ， 需用 O ( r2 ) 时间 ， ( 1.1 ) 要 找 出任 两 公式 间 的 共享 变量 以 确定 图 的 边 ， 需 O ( n2r2 ) 时间 ； ( 1.2 ) 需 O ( 1 ) 时间 ； ( 1.3 ) 判断 是否 有圈 ， 可用 深度 优先 搜索算法 ， 对 e 条边 的 图 复杂性 为 O ( e ) ［ 8 ］ . 此处 任两 公式 间 至多 有 r 条边 ， 整个 图 至多 有 n ( n + 1 ) r / 2 条边 ， 所以 , ( 1.3 ) 用 O ( n2r ) 时间 ； 由于 公式 长度 有 常数 上 界 ， 所以 计算 一个 结点 的 真值表 所用 时间 有 常数 上 界 ， 则 ( 1.4 ) 需 O ( n ) 时间 . 因此 , Step1 需 O ( n2 ) 时间 . 
 　 　 ( 2.1 ) 需 O ( 1 ) 时间 . 由于 公式 长度 有 常数 上 界 ， 所以 真值表 大小 有 常数 上 界 ， ( 2.2 . 1 ) 主要 修改 真值表 ， 需 O ( 1 ) 时间 ； ( 2.2 . 2 ) 的 ① 和 ② 也 是 对 真值表 的 处理 ， 用 O ( 1 ) 时间 ； ( 2.2 . 2 ) 的 ③ 不断 向 NODE . S 中 加入 公式 ， 而 NODE . S 至多 可有 n 个 公式 , 所以 , ( 2.2 . 2 ) 的 ③ 至多 需 O ( n ) 时间 . 于是 ( 2.2 ) 可 在 O ( n ) 时间 内 完成 . 同理 ， ( 2.3 ) 也 可 在 O ( n ) 时间 内 完成 . 因此 ， Step2 循环体 用 O ( n ) 时间 ， 至多 循环 n + 1 次共需 O ( n2 ) 时间 . 
 　 　 T - U 要 从 n 个 元素 的 集合 中 减去 至多 n 个 元素 ， 用 O ( n2 ) 时间 , 再 加入 p 用 O ( 1 ) 时间 ， 因此 , Step3 用 O ( n2 ) 时间 . 
 　 　 综上所述 ， 算法 REVISION2 的 时间 复杂性 为 O ( n2 ) . 于是 ， 可 得到 如下 定理 . 
 　 　 定理 .   对 可 满足 知识库 T 和 可 满足 新 知识 p ， 当 T ∪ { p } 的 约束 图为 树型 ， 且 所有 公式 长度 均 有 常数 上界时 ， 可 在 O ( n2 ) 时间 内 求得 T 。 widp . 
 3   结束语 
 　 　 本文 给出 了 一类 树型 知识库 的 多项式 时间 更新 算法 . 该 算法 与 知识库 结构 有关 ， 适合 知识库 中 知识 间 联系 较 松散 的 情况 ， 如 电子线路 和 基于 模型 的 医疗 诊断系统 ［ 6 ］ . 该 算法 虽 是 一种 简单 情况 下 的 算法 ， 但 它 表明 知识库 更新 的 复杂性 与 知识库 的 结构 密切相关 ， 为 我们 探索 更新 问题 复杂性 来源 ， 并 进一步 寻找 适当 限制 消除 其 难解 性 提供 了 线索 . 另外 ， 在 文献 ［ 7 ］ 中将 非树型 结构化 为树型 结构 的 技术支持 下 ， 该 算法 可 找到 更 广泛 的 应用领域 . 
 基金项目 ： 本文 研究 得到 国家自然科学基金 和 国家 863 高科技 项目 基金 资助 . 
 作者简介 ： 马绍汉 , 1938 年生 , 教授 ， 博士生 导师 , 主要 研究 领域 为 算法 复杂性 , 人工智能 . 
 　 　 　 　 　 陶雪红 , 女 ， 1969 年生 , 博士 , 讲师 , 主要 研究 领域 为 知识库 更新 . 
 作者 单位 ： 山东大学 计算机科学 系   济南   250100 
 　 　 　 　 　 E - mail :   xuehongtao @ hotmail . com 
 本文 通讯联系 人 : 马绍汉 ， 济南 250100 , 山东大学 计算机科学 系 
 参考文献 
 　 1   Eiter   T ,   Gottlob   G .   On   the   complexity   of   propositional   knowledge   base   revision ,   updates ,   and   counterfactuals .   Artificial   Intelligence ,   1992 , 57 ( 2 ～ 3 ) : 227 ～ 270 
 　 2   马绍汉 ， 陶雪红 . 知识库 更新 的 研究 . 计算机科学 ， 1995 , 21 ( 3 ) : 32 ～ 36 
 ( Ma   Shao - han ,   Tao   Xue - hong .   Research   on   knowledge   base   revision .   Computer   Science ,   1995 , 21 ( 3 ) : 32 ～ 36 ) 
 　 3   马绍汉 ， 陶雪红 ， 孙伟 . 一类 命题 知识库 的 更新 算法 . 计算机 研究 与 发展 , 1996 ， 33 ( 2 ) : 127 ～ 131 
 ( Ma   Shao - han ,   Tao   Xue - hong ,   Sun   Wei .   A   knowledge   base   revision   algorithm .   Computer   Research   and   Development ,   1996 , 33 ( 2 ) : 127 ～ 131 ) 
 　 4   陶雪红 , 孙伟 ， 马绍汉 . 命题 知识库 更新 的 算法 及其 复杂性 . 软件 学报 ， 1996 ， 7 ( 5 ) : 300 ～ 305 
 ( Tao   Xue - hong ,   Sun   Wei ,   Ma   Shao - han . Knowledge   base   revision   algorithm   and   complexity .   Journal   of   Software ,   1996 , 7 ( 5 ) : 300 ～ 305 ) 
 　 5   Dechter   Rina ,   Pearl   Judea .   Network - based   heuristics   for   constraint - satisfaction   problems .   Artificial   Intelligence ,   1988 , 34 ( 1 ) : 1 ～ 38 
 　 6   Dechter   Rina ,   Dechter   Avi .   Structure - driven   algorithms   for   truth   maintenance .   Artificial   Intelligence ,   1996 , 82 ( 1 ) : 1 ～ 20 
 　 7   Dechter   Rina ,   Pearl   Judea .   Tree   clustering   for   constraint   networks .   Artificial   Intelligence ,   1989 , 38 ( 3 ) : 353 ～ 366 
 　 8   马绍汉 . 图 算法 . 贵阳 ： 贵州 人民出版社 ， 1988 
 ( Ma   Shao - han .   Graph   Algorithms .   Guiyang :   Guizhou   People ' s   Press ,   1988 ) 
 本文 1998 - 05 - 12 收到 原稿 , 1998 - 12 - 14 收到 修改稿 
