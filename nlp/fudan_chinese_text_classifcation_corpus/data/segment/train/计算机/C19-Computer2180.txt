计算机 应用 研究 
 APPLICATION   RESEARCH   OF   COMPUTERS 
 2000 　 Vol.17 　 No.2 　 P.22 - 24 
 
 
 
 面向 Agent 程序设计 中 继承 机制 的 研究 
 路军 　 王亚东 　 王晓龙 　 王喆 　 万庆 红 
 摘   要   对 面向对象 技术 在 面向 Agent 程序设计 中 的 应用 进行 了 系统 的 研究 ， 指出 了 继承 机制 在 面向 Agent 程序设计 中 的 应用 及 目前 存在 的 两个 问题 ， 并 分析 了 解决 的 方法 ， 为 今后 的 研究 指明 了 方向 。 
 关键词   面向对象   可 继承性   聚合   类 
 1   引言 
 　 　 对 面向 Agent 程序设计 的 研究 近几年来 受到 国内外 众多 专家学者 的 关注 ， 它们 大都 是 对 Shoham 提出 的 Agent0 编程语言 [ 4 ] 和 面向 Agent 编程 理论 [ 5 ] 的 改进 和 发展 ， 如 澳大利亚 学者 Devindra   Weerasooriya 等 人 提出 的 并发 的 面向 Agent 语言 [ 6 ] ， 哈尔滨工业大学 姚郑 博士 提出 的 AOPL 语言 [ 8 ] 等 。 
 　 　 如何 改进 撔 拍 ? 愿望 - 意向 ( BDI ) Agent 中 的 面向 Agent 程序设计 是 本文 讨论 的 重点 。 
 　 　 Agent 是 一个 反应 的 、 自治 的 、 内部 驱动 的 实体 ， 置身于 变化 的 不 确定 的 世界 里 ， 它们 可以 感知 这个 世界 并 对 其 作出反应 。 到 目前为止 ， 还 没有 几例 成熟 的 、 大规模 的 Agent 系统 的 应用 ， 部分 原因 是 由于 缺乏 成熟 的 语言 和 软件工具 ， 但 最大 障碍 是 缺乏 使 系统 复杂性 得到 有效 控制 的 方法 。 
 　 　 对系统 复杂性 的 管理 ， 历来 是 大规模 嵌入 软件系统 的 设计者 们 最富 挑战性 的 工作 ， 需要 抽象化 、 构造 技术 、 继承 、 模块化 和 其它 机制 来 管理 它们 的 内在 复杂性 。 面向对象 技术 是 当今 最前沿 的 方法论 ， 此 方法 通过 对象 ( Object ) 允许 抽象 ， 通过 类 ( Class ) 的 分层 实现 继承 。 
 　 　 面向对象 技术 中 的 对象 模型 和 动态 模型表示 技术 ， 加以 适当 的 扩充 和 约束 ， 可以 作为 面向对象 技术 用 在 面向 Agent 程序设计 中 的 理论 基础 [ 3 ] 。 
 2   面向对象 技术 中 的 相关 概念 
 　 　 面向对象 技术 尽管 已经 在 各行各业 中 普遍 得到 应用 ， 但 对 面向对象 中 一些 概念 的 定义 还 没有 一个 统一 的 标准 ， 下面 我们 描述 几个 相关 概念 。 
 2.1   对象 
 　 　 对象 是 一个 实体 ， 包含 状态 ( 信息 ) 和 可 执行 的 操作 ( 行为 ) ， 它 既 可以 检查 又 可以 改变 自身 的 状态 。 
 2.1 . 1   构造 现实 世界 中 的 对象 
 　 　 在 现实 世界 中 ， 一个 对象 被 认为 是 相关 知识 和 行为 的 软件包 ， 是 要 解决 的 问题 的 反映 。 
 　 　 我们 可以 把 对象 想象 成能 执行 某个 任务 的 “ 小人 ” ， 其中 装载 着 “ 私人 的 数据 ” 。 
 2.1 . 2   对象 的 封装 ( Encapsulate ) 
 　 　 对象 分为 “ 内部 ” 和 “ 外部 ” 两 部分 。 信息 在 对象 内部 的 表示 方法 是 透明 的 ， 一个 系统 中 的 其它 软件 不 能够 直接 访问 一个 对象 的 “ 内部 ” ， 这 就 称为 封装 。 一个 对象 所 具有 的 方法 ( 操作 或 过程 ) 允许 系统 中 的 其它 对象 查询 信息 ， 触发 某个 动作 或者 改变 某种 状态 。 
 2.1 . 3   封装 的 好处 
 　 　 ( 1 ) 封装 绑定 数据 和 相关 过程 。 
 　 　 ( 2 ) 由于 封装 对象 的 状态 由 对象 自身 来 维护 ， 所以 状态 的 表示 可以 随意 改变 而 不 影响 系统 中 的 其它 对象 。 
 　 　 ( 3 ) 对象 的 方法 ( Method ) 是 透明 的 ， 系统 的 其它 部分 只 需 知道 接口协议 就 可以 了 ， 没有 也 不 需要 知道 具体操作 是 如何 完成 的 。 
 2.2   类 
 　 　 一个 类 可以 看成 是 对象 的 一个 “ 工厂 ” ， 一个 类 定义 了 变量 ( Variable ， 也 称为 属性 ) 和 类 中 所有 的 方法 ( Method ) 。 每 一个 独立 的 对象 都 有 其 自身 的 变量值 ， 定义方法 的 代码 通过 对象 共享 。 
 　 　 类 通过 聚合 ( Aggregate ) 和 继承 ( Inheritance ) 来 达到 “ 重用 ” 。 聚合 和 继承 是 可 重用 的 两种 最 一般 的 形式 ， 可 分别 描述 为 “ part   of ” 和 “ is   a ” 的 关系 类型 。 给出 一个 聚合 的 例子 如图 1 所示 。 
 
 图 1 　 聚合 的 一个 例子 
 2.3   继承 
 　 　 图 2 是 一个 继承 的 例子 ， 其中 从 父类 中 导出 的 子类 符合 “ is   a ” 关系 ， DB - File “ is   a ” File ； Text - File “ is   a ” File , 这 和 讨论 聚合 时 的 “ part   of ” 关系 有所不同 。 
 　 　 要 区分 继承 和 聚合 之间 的 不同 ， 只要 对 树结构 的 任一 顶点 提问 ： “ 这个 类 的 一个 对象 和 它 的 父亲 是 同一个 类型 吗 ？ ” ， 如果 回答 是 肯定 的 ， 则 是 继承 关系 ， 否则 为 聚合 关系 。 
 
 图 3 　 继承 的 一个 例子 
 3   面向 Agent 程序设计 中 继承 机制 的 引入 
 　 　 对象 、 类 等 面向对象 概念 在 面向 Agent 程序设计 ( AOP ) 中 的 应用 ， 使得 将 继承 机制 集成 到 AOP 中 成为 可能 和 必然 。 Lobel   Crnogorac 等 人 已经 给出 了 AOP 中 有关 继承 的 概念 [ 1 ] ， 本节 中 我们 首先 给出 dMARs 系统 [ 2 ] 的 编程 环境 ， 然后 对 它 的 继承 机制 加以分析 ， 指出 引入 继承 机制 后 的 好处 及 系统 内 存在 的 两个 问题 。 
 3.1   引入 继承 的 好处 
 　 　 继承 使 用户 可以 扩展 一个 现存 的 类 ， 增加 相应 的 变量 ( Variable ) 和 方法 ( Method ) 来 定义新 类 。 通过 共享 类间 的 代码 来 大幅度 地 减少 系统 中 代码 的 数量 。 
 　 　 在 AOP 中 引入 继承 有 双重 的 潜在 利益 ： 第一 ， 通过 代码 共享 来 降低 编程 的 复杂性 ； 第二 ， 继承 的 引入 有助于 多 Agent 系统 模型 的 修改 。 
 3.2   Agent 的 表示 
 　 　 一个 Agent 族 ( Family ) X 是 一个 三元组 < Bx ,   Gx ,   Px > 。 其中 Bx 是 一个 信念 原子 集 ， 每 一个 信念 原子 b ( v ) ( b 是 一个 谓词 符号 ， v = ( v1 ,   ... ,   vn ) , vi 是 一个 项 ) 反映 了 Agent 所 获得 的 环境 状态 信息 ； Gx 是 一个 目标 集 ， 其中 的 每个 目标 描述 了 此 系统 所 期望 的 状态 。 如果 g 是 一个 谓词 符号 ， v 如 前面 所 定义 ， 目标 ! g ( v ) 说明 一个 Agent 要 达到 一种 状态 ， 在 此 状态 下 g ( v ) 是 一个 真 信念 ； Px 是 一个 规划 集 ， 每个 规划 指出 如何 实现 一个 目标 或 对 某种 情况 如何 作出反应 。 
 　 　 一个 Agent 族 是 一个 Agent 实例 的 集合 ， 这些 Agent 实例 具有 相同 的 信念 集 ， 达到 相同 的 目标 集 ， 使用 相同 的 规划 集来 达到 所有 它们 的 目标 。 
 　 　 Agent 的 实例 是 动态 的 ， 运行 时才 存在 的 实体 ， 而 Agent 族 是 静态 的 ， 相当于 OOP 中类 的 概念 。 任何 时候 一个 Agent 都 包含 一个 基本 信念 原子 集 ， 发生 在 Agent 周围环境 或 Agent 内部 的 事件 将 导致 Agent 激活 自身 相应 的 规划 。 每 一个 规划 包含 激活 条件 、 上下文 条件 和 规划图 三 部分 ， 可以 表示 为 < Pinv ,   Pcon ,   Pgp > 。 其中 激活 条件 ( Invocation ) 指 激活 此 规划 必须 发生 的 事件 ； 事件 ( Event ) 是 对 信念 或 目标 的 增减 ， 用 + 和 - 分别 表示 增减 操作 ， 于是 + b ( v ) ， - b ( v ) ， + ! g ( v ) ， - ! g ( v ) 都 是 事件 ； 上下文 条件 ( Context ) 是 一个 由 信念 原子 和 连接词 ∧ 和 ∨ 组成 的 逻辑 表达式 ， 上下文 条件 必须 被 Agent 的 基 信念 原子 集所 满足 ， 此 规划 才能 执行 ； 规划图 ( Graph ) 是 一个 非 循环 图 ， 它 的 有 向 边 是 一些 子目标 和 原 动作 ， 表示 为了 达到 此 目标 所 必须 达到 的 子目标 和 原 动作 。 
 　 　 一个 Agent 族 的 实例 包含 一个 初始 的 基本 信念 集 ， 要 实现 的 目标 和 Agent 族 所用 的 规划 。 当 一个 Agent 和 环境 进行 交互 时 ， 它 采纳 并 提交 相应 的 规划 ， 形成 意向 。 
 　 　 例 1 . 图 3 中 给出 了 一个 Agent 族 SimplePlane 的 几个 规划 ， 此 Agent 族 用来 模拟 简单 类型 的 飞机 。 事件 + ! landed ( base ) 触发 第一个 规划 ， 本 规划 完成 在 好 天气 ( w ( good ) ) 和 好 能见度 ( v ( good ) ) 下 着陆 的 任务 。 此 规划 的 执行 蕴含 子目标 ! checkPos ( V ) ， 继而 触发 各自 的 规划 。 两个 ! checkPos ( V ) 规划 的 选择 基于 各自 的 优先权 ， 高 优先权 的 规划 先 执行 ， 如果 失败 ， 则 执行 下 一个 规划 。 规划 + rain ( V ) 对 环境 的 变化 作出反应 ， 它 是 在 信念 rain ( V ) 被 加到 Agent 的 信念 集中 时 被 触发 的 。 
 
 图 3 　 SimplePlane 的 规划 集 
 　 　 下面 我们 指出 当 一个 简单 的 继承 机制 加入 到 一个 诸如 dMARs 的 面向 Agent 语言 时 可能 出现 的 问题 。 在 以下内容 中 ， 继承 完全 引用 OOP 中 的 概念 ， 因此 ， 一个 Agent ( 相当于 OOP 中 的 对象 ( Object ) 继承 了 它 的 父 Agent 的 所有 规划 ( 相当于 OOP 中 的 方法 ( Method ) ) ， 重 定义 了 一些 规划 ， 并且 可能 加入 一些 新 规划 。 
 4   引入 继承 机制 后 存在 的 问题 及 解决 方法 的 分析 
 4.1   行为 保留 ( Preservation ) 问题 
 　 　 Agent 和 环境 之间 的 交互 产生 了 Agent 的 行为 ( Behaviour ) 。 假设 已经 实现 了 一个 Agent 族 X ， 并 证明 了 它 能 完成 一些 期望 的 行为 ， 我们 通过 继承 X 并 增加 一些 新 的 规划 来 定义 一个 新 Agent 族 Y 。 族 Y 的 任意 一个 实例 是否 还 至少 能 达到 所有 族 X 的 实例 所 能 达到 的 目标 ( 假设 放在 相同 的 环境 中 ) ？ 换句话说 ， 我们 能否 保证 Y 的 一些 特性 而 不 需要 确切 地 证明 它们 。 
 　 　 例 2 . 假设 SimplePlane 的 实例 在 好 天气 和 能见度 下 都 能 成功 着陆 。 现在 我们 考虑 一个 新 的 Agent 族 AdvancedPlane ， 它 在 继承 了 所有 SimplePlane 的 规划 的 基础 之上 ， 增加 了 一个 针对 目标 ! landed ( V ) 的 新 规划 ， 如图 4 所示 ， 此 规划 使 Agent 在 任何 天气 和 能见度 下 都 能 着陆 。 于是 我们 继承 并 扩展 了 SimplePlane ， 现在 我们 试图 证明 Agent 族 AdvancedPlane 能 在 任何 条件 下 着陆 。 
 
 图 4 　 AdvancedPlane 的 规划 集 
 　 　 而 我们 甚至 不能 保证 它 在 好 天气 和 好 能见度 下 着陆 ， 这 是因为 ， 如果 新 的 规划 比 继承 的 规划 具有 更高 优先权 的话 ， 新 规划 将 被 首先 触发 执行 ， 而 新 规划 中 可能 包含 错误 ， 从而 引起 SimplePlane 坠毁 。 
 　 　 我们 注意 到 ， 还是 有 一些 继承 的 特例 ， 确实 能 保留 行为 。 如 在 上例 中 ， 如果 继承 的 规划 比新 规划 具有 更高 优先权 的话 ， AdvancedPlane 将 保留 SimplePlane 的 行为 ， 即 它们 都 能 在 好 天气 、 高 能见度 下 着陆 。 我们 还 可以 构造 出 一些 不 包含 规划 的 优先权 的 、 更为 复杂 的 例子 ， 结果 仍然 不能 保证 行为 的 保留 。 而 我们 认为 ， 在 理想 情况 下 ， 继承 机制 应当 保证 行为 保留 。 
 4.2   继承 异常 ( Anomaly ) 问题 
 　 　 假设 我们 已经 定义 了 一个 Agent 族 X ， 它 能 完成 了 一些 期望 的 行为 。 现在 我们 想要 建立 一个 特殊 的 Agent 族 Y ， 可以 完成 X 所能 完成 的 所有 目标 以及 一些 其它 的 目标 。 我们 从 X 中 继承 所有 的 规划 ， 同时 将 不 在 X 中 出现 的 行为 通过 编写 新 规划 来 实现 。 如果 在 此 情况 下 ， X 和 Y 不能 共享 代码 ， 我们 称为 发生 了 继承 异常情况 。 
 　 　 例 3 . 假设 我们 定义 一个 新 的 Agent 族 NewPlane ， 它 在 继承 了 所有 SimplePlane 的 规划 并 增加 了 一个 针对 目标 ! CheckPos ( V ) 的 新 规划 ， 此 规划 含有 上下文 条件 ( Context   Condition )   v ( poor ) ， 使 Agent 能 在 低 能见度 下 检测 自身 的 位置 ， 如图 5 所示 。 因此 ， NewPlane 的 实例 可以 在 任何 能见度 、 好 天气 时 着陆 ， 然而 继承 的 规划 的 上下文 条件 仍然 限制 Agent 只能 在 好 的 能见度 下 才能 着陆 ， 因此 这些 规划 必须 用 新 的 上下文 条件 w ( good ) 进行 重写 。 
 
 图 5 　 NewPlane 的 规划 集 
 　 　 所以 尽管 在 两个 Agent 族间 还有 一些 代码 可以 共享 ， 如对 目标 + rain ( V ) 和 ! ChechPos ( V ) 的 规划 ， 但 可 共享 代码 的 数量 已经 大大减少 了 。 我们 甚至 还 可以 构造 出 没有 代码 共享 的 例子 。 
 　 　 对 Agent 父亲 族 的 规划 的 重 定义 是 易错 的 ， 耗时 的 ， 而且 违反 了 模块化 和 封装 的 概念 。 继承 的 引入 就是 为了 通过 代码 共享 来 解决 这一 问题 的 ， 而 继承 异常 问题 大大 地 减弱 了 继承 的 实用性 。 
 4.3   问题 解决 方法 的 分析 
 　 　 从 以上 分析 可以 看出 ， 继承 机制 引入 后 ， 潜在 利益 是否 能够 实现 主要 依赖于 继承 机制 的 定义 ， 特别 应当 注意 的 是 可能 发生 两类 问题 ： 缺少 行为 的 保留 和 存在 继承 异常 问题 。 这 两个 问题 相当于 系统 有效性 和 完备 性 的 问题 ， 其中 行为 的 保留 类似 于 有效性 ： 只有 期望 的 行为 才能 被 继承 机制 所 演绎 ； 继承 异常 类似 于 完备 性 ： 所有 期望 行为 都 能 被 继承 机制 所 演绎 。 缺少 行为 的 保留 导致 需要 对 继承 的 Agent 的 每 一个 特性 进行 证明 ； 而 继承 异常 和 继承 机制 的 表达能力 密切相关 ， 一个 继承 异常 通常 在 继承 机制 不足以 提供 Agent 之间 完成 相关 抽象 行为 的 代码 共享 时 发生 。 这 两个 问题 能 大大 减弱 继承 机制 的 可用性 ， 解决 它们 需要 更 复杂 的 继承 机制 的 设计 。 
 　 　 事实上 表明 ， 这种 方法 通常 是 利弊 各半 的 ， 设计 更 复杂 的 系统 可能 减少 继承 异常现象 的 发生 ， 但 同时 增加 了 行为 保留 的 问题 。 如何 设计 出能 很 好地解决 这 两个 问题 的 继承 机制 ， 将 是 我们 今后 的 主要 工作 。 
 5   结束语 
 　 　 到 目前为止 ， 许多 基于 BDI 结构 的 面向 Agent 程序设计 系统 已经 发展 起来 [ 7 ] ， 相应 地 ， 面向 Agent 的 程序设计 语言 ， 如 AGENT0 [ 4 ] ， 也 被 提出 并 用于 Agent 程序设计 。 然而 ， 很少 有人 在 如何 对 面向 Agent 系统 进行 分析 和 设计 上 下功夫 。 
 　 　 本文 对 面向对象 技术 在 Agent 程序设计 中 的 应用 进行 了 初步 地 研究 ， 并 对 AOP 中 的 继承 机制 加以分析 ， 指出 它 依然 是 一种 不 成熟 的 技术 ， 对 它 的 研究 将 是 今后 BDI   Agent 发展 的 主要 方向 之一 。 
 本 项目 的 研究 获得 国家 “ 863 ” 高科技 项目 的 资助 ( 项目编号 :   863 - ZD - 06 - 01 ) 
 路军 （ 哈尔滨工业大学 计算机科学 与 工程系   哈尔滨   150001 ） 
 王亚东 （ 哈尔滨工业大学 计算机科学 与 工程系   哈尔滨   150001 ） 
 王晓龙 （ Department   of   Computing   The   HongKong   Polytechnic   University ） 
 王喆 （ 大庆石油管理局   黑龙江 大庆   163712 ） 
 万庆 红 （ 大庆 采油 二厂   黑龙江 大庆   163414 ） 
 参考文献 
 1 ， L . Crnogorac ,   A . S . Rao ,   K . Ramamohanarao .   Analysis   of   Inheritance   Mechanisms   in   Agent - Oriented   Programming .   In   IJCAI - 97 ,   Nagoya ,   Japan ,   1997 
 2 ， Mark   d ' Inverno ,   David   Kinny ,   Michael   Luck ,   and   Michael   Wooldridge .   A   Formal   Specification   of   dMARS .   Technical   Report72 ,   AAII ,   November ,   1997 
 3 ， David   Kinny ,   M . Georgeff ,   and   Anand   Rao .   A   Methodology   and   Modelling   Technique   for   Systems   of   BDI   Agents .   MAAMAW ' 96 ,   1996 
 4 ， Yoav   Shoham .   AGENT0 :   a   Simple   Agent   Language   and   its   Interpreter .   In   Proceedings   of   the   Ninth   National   Conference   on   Artificial   Intelligence ,   AAAI - 91 ,   pages   704 ～ 709 ,   San   Jose ,   CA ,   1991 
 5 ， Yoav   Shoham .   Agent - Oriented   Programming .   Artificial   Intelligence ,   60 ( 1 ) :   51 ～ 92 ,   1993 
 6 ， Devindra   Weerasooriya ,   A . Rao ,   K . Ramamohanarao .   Design   of   a   Concurrent   Agent - Oriented   Language .   In   Intelligent   Agents :   Theories ,   Architectures ,   and   Languages .   LNAI   890 .   Springer   Verlag ,   1995 
 7 ， 路军 ,   王亚东 ,   王晓龙 .   " 信念 - 愿望 - 意向 " Agent 的 研究 与 进展 .   计算机科学 ,   1999 ,   26 ( 2 ) 
 8 ， 姚郑 ,   高   文 .   面向 Agent 的 程序设计 .   软件 学报 ,   1997 ,   8 ( 1 ) 
 收稿 日期 ： 1999 年 8 月 11 日 
