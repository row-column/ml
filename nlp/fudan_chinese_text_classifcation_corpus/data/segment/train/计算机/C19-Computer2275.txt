计算机 应用 研究 
 APPLICATION   RESEARCH   OF   COMPUTERS 
 2000 　 Vol.17 　 No.5 　 P.62 - 64 
 
 
 
 用 Java 语言 开发 专家系统 
 万 江平 　 严明 　 杨建梅 
 摘     要     介绍 用 Java 语言 实现 的 一个 基于 产生 式 规则 的 小型 专家系统 。 其 产生 式 规则 采用 简化 的 M.1 格式 ， 给出 了 知识 表示 和 主要 数据结构 及 链表 的 实现 方法 ， 详细 说明 了 正向 推理 的 运行 过程 ， 并 讨论 了 反向 推理 的 实现 。 最后 提出 了 用 专家系统 实现 主动性 服务 的 应用 思路 。 
 关键词     产生 式     Java     反向 推理       正向 推理     主动 服务 
 1     前言 
 　 　 专家系统 是 人工智能 发展 的 高级阶段 的 产物 ， 是 人工智能 领域 中 取得 的 最好 成果 之一 。 将 专家 的 知识 和 经验总结 成 规则 ， 以 适当 的 形式 存入 计算机系统 ， 建立 知识库 ， 然后 对 输入 的 原始数据 选用 合适 的 规则 进行 推理 ， 作出 判断 和 决策 ， 去 解决 那些 需要 专家 决定 的 复杂 问题 。 专家系统 已 用于 工业 、 农业 、 医学 、 地质 、 气象预报 、 军事 及 教育 等 方面 。 
 　 　 Feigenbaum 指出 ： 启发式 ( 方法 和 规则 ) 是从 实际 经验 得出 的 。 专家系统 使用 启发式 ( Heuristic ) 方法 和 规则 处理 问题 。 能 在 问题 空间 中 有效 地 限制 搜索 量 的 一种 规则 、 策略 、 决窍 、 简易 措施 或 任何 方法 [ 1 ] 。 在 大多数 情况 下 ， 专家系统 能 给出 满意 的 问题解答 。 其 推理机 类似 于 抽象思维 模拟 ， 经验 知识 是 形象思维 的 一种 体现 。 
 　 　 产生式系统 中 的 产生 式 ( Production ) 一词 是从 波斯特 机中 借用 过来 的 ， 所谓 波斯特 机是 1943 年 波斯特 ( E . Post ) 根据 串 替换 规则 ( String   Replacement   Rules ) 提出 的 一种 计算 模型 。 每 一条 规则 就 称为 一个 产生 式 。 每个 产生 式 是 由 认识 部分 和 行为 部分 所 组成 ， 因此 产生 式 也 可以 看成 是 一个 情况 — 行为 对 ( Situation - Action   Pair ) 。 当 给定 一组 事实 后 ， 我们 即可 用 模式匹配 技术 去 寻找 适用 的 产生 式 ， 寻找 的 方法 就是 代入 事实 后能 使 产生 式 的 前提 成立 ， 将 这样 的 产生 式 用 在 这组 事实上 [ 6 ] 。 
 　 　 本文 介绍 我们 用 Java 语言 实现 的 一个 基于 产生 式 规则 的 小型 专家系统 知识 表示 和 推理 的 具体 实现 ， 并 就 其 在 主动性 服务 等 方面 的 应用 进行 了 初步 的 思考 。 
 2     知识 的 表示 
 　 　 采用 简化 的 M.1 的 知识 表示 方法 ， 写出 的 一个 去 酒店 所 需 信息 的 规则 集 如下 ： 
 R1 :   if     Distance   & gt ;   5   mile   then   method   =   bus 
 R2 :   if     Distance   & gt ;   1   mile   and   time   < 15   min   then   method = " bus "   R3 :   if   Distance >   1   mile   and   time   & gt ;   15   min   then   method   =   walk 
 R4 :   if     method   =   bus   and   hotel   in   city   then   method   =   taxi 
 R5 :   if     method   =   bus   and   hotel   in   suburb   then   method   =   own   car 
 R6 :   if     method   =   walk   and   weather   =   bad   then   method   =   jacket   and     
 　 　 walk 
 R7 :   if     method   =   walk   and   weather   = good   then   method   =   no   jacket 
 　 　 内部 采用 属性 ( Attribute ) - 值 ( Value ) 的 表示 方法 ， 属性 是 某 一 事物 的 特性 ， 对 具体 场合 有 与 之 对应 的 值 。 例如 有 degree 为 属性 ， yes 为值 。 在 这里 ， 我们 建立 起 一种 适用 于 正向 、 反向 两种 推理方法 的 数据结构 。 
 　 　 存储 信息 的 数据结构 如下 ： 
 事实 结点 ： class   Fact   { 
 　 　 　 　 　 　 　 　 　 　 　 　 　 String   name ; 
 　 　 　 　 　 　 　 　 　 　 　 　 　 String   value ; 
 　 　 　 　 　 　 　 　 　 　 　 } 
 　 　 其中 name 描述 的 是 属性 ， value 描述 的 是 值 。 
 规则 结点 ： class   Rule   { 
 　 　 　 　 　 　 　 　 　 　 　 　 　 List   premise ; 
 　 　 　 　 　 　 　 　 　 　 　 　 　 Fact   conclude ; 
 　 　 　 　 　 　 　 　 　 　 　 　 　 boolean   Checked = false ; 
 　 　 　 　 　 　 　 　 　 　 　 } 
 　 　 其中 premise 为 一个 前提 链表 ， 其 结点 为 Fact 类 ， Conclude 是 该 规则 的 结论 ， Checked 是 布尔 类型 ， 作为 该 规则 是否 被 检测 过 的 标志 。 
 　 　 下面 是 事实 链表 和 规则 链表 ： 
 　 　 List   Facts ;   ( 事实 链表 )   List   Rules ;   ( 规则 链表 ) 
 　 　 List   workrule ;   ( 可用 规则 链表 ， 只 在 正向 推理 中 有用 ) 
 　 　 Java 语言 中 的 对象 引用 实际上 就是 一个 指针 ， 可以 编写 这样 的 类来 实现 链表 中 的 结点 。 
 class   Node 
 { 
 　 　 Object   data ; 
 　 　 Node   next ;     / / 指向 下 一个 结点 
 } 
 　 　 将 数据 域 定义 成 Object 类 是因为 Object 类 是 广义 超类 ， 任何 类 对象 都 可以 给 其 赋值 ， 增加 了 代码 的 通用性 。 为了 使 链表 可以 被 访问 ， 还 需要 定义 一个 表头 ， 表头 必须 包含 指向 第一个 结点 的 指针 Head 和 指向 当前 结点 的 指针 Pointer 。 为了 便于 在 链表 尾部 增加 结点 ， 可 增加 一 指向 链表 尾部 的 指针 Tail 。 另外 还 可以 用 一个 域来 表示 链表 的 大小 ， 当 调用者 想得到 链表 的 大 小时 ， 不必 遍历 整个 链表 。 图 1 是 这种 链表 的 示意图 。 
 
 图 1 链表 的 数据结构 
 3     正向 推理 的 实现 
 　 　 使用 正向 推理 ， 必须 考虑 到 冲突消解 。 在 这里 ， 我们 采用 的 消解 方式 是 ： 把 适用 的 规则 以 队列 方式 存储 ， 选择 规则 时 按照 队列 的 先进先出 策略 ， 按照 顺序 选取 。 专一性 顺序 ， 即 如果 某一 规则 条件 部分 规定 的 情况 比 另 一 规则 条件 部分 规定 的 情况 更 有 针对性 ， 则 这条 规则 有 较 高 的 优先级 。 此外 ， 若 某 一 规则 已经 被 检测 过 ， 那么 下次 将 已 检测 过且 成果 的 规则 放在 一边 ， 不予 重选 。 以上 三种 消解 方式 ， 优先级 递增 。 
 开始 ： do 
 {   / / 由 前提 链表 中 的 事实 ， 判断 规则 集中 哪些 适用 : 
 　 规则 = 规则 链表 头 结点 ; 
 　 while ( 规则 ! = null ) 
 　 {   if   ( 该 规则 未 被 检验 过 ) 
 　 　 　 if   ( 该 规则 前提 可 满足 ) 
 　 　 　 　 　 　 将 该 规则 加入 可用 规则 链 尾部 ; 
 　 　 　 从 规则 集中 取 下 一条 规则 ; 
 } 
 　 修改 标志 = false ; 
 　 规则 = 可用 规则 链表 头 结点 ; 
 　 while   ( 规则 ! = null ) 
 　 {   if   ( 该 规则 被 检测 过 ) 
 　 　 { 取 下 一条 规则 ; 
 　 　 　 　 　 continue ; 
 　 　 } 
 　 根据 取得 的 未 被 检测 过 的 规则 ， 得到 其 结果 ; 
 　 将 该 规则 置 为 检测 过 ; 
 　 if   ( 该 结果 不 在 前提 队列 中 ) 
 　 { 将 结果 插入 前提 队列 尾部 ; 
 　 　 　 　 　 　 修改 标志 置 true , 
 　 　 　 　 　 　 break ; 
 　 　 } 
 }   / / end   of   while 
 　 / / 如果 while 循环 结束 且 修改 标志 为 false , 
 　 / / 则 所有 规则 都 被 测试 过 ， 不再 有 新 结论 
 　 if   ( 修改 标志 =   = false ) 
 　 { 搜索 结果   =   前提 队列 的 最后 结点 ; 
 　 / / 最后 插入 前提 队列 尾部 的 是 最近 一次 检测 的 结果 ， 也 就是 最 
 　 / / 终 结果 将 规则 集 链表 中 所有 规则 的 Checked 标志 置 false ; 
 　 　 　 return   搜索 结果 ; 
 　 　 } 
 　 }   while   ( true ) ; 
 　 　 用户 输入 当前 可以 满足 的 前提 组 ， 从 总 规则 集中 寻找 其 前提 部分 可以 被 用户 指定 的 前提 所 满足 的 规则 ， 依次 检测 这些 规则 ， 冲突消解 策略 如上所述 ， 将 这些 规则 产生 的 结论 并入 前提 组中 ， 重新 判断 总 规则 集中 有 哪些 新 规则 可以 得到 满足 ， 如此 循环 ， 直到 不再 有 新 的 结论 被 并入 前提 组中 为止 。 此时 ， 最后 得到 的 一个 结论 必定 是 推理 的 结果 。 
 　 　 下面 是 输入 ： distance = 9   mile   and   weather = bad   and   time   =   20   min 时 链表 的 状态 ， 结果 是 ： jacket   and   walk 
 
 4     反向 推理 的 实现 
 　 　 反向 推理 用 得 较 多 ， 主要 是 目标 明确 ， 推理 快 。 实现 算法 如下 ： 
 开始 ： 
 从 Rule 规则 队列 中 寻找 推出 Goal 结论 的 规则 ; 
 if   ( 找到 )   { while ( 该 规则 的 前提 部 的 属性 未 测试 完 ) 
 { / / 以该 规则 的 前提 部 的 属性 作为 新 的 Goal ， 递归 调用 推理 函数 ; 
 　 　 if   ( 上面 的 推理 不 成立 ) 
 　 　 {   return   false ； 　 / / 结束 ,   失败 
 　 　 } / / 只要 有 一个 前提 不 成立 ,   那么 整个 结论 就 不 成立 ,   取 
 　 　 / / 前提 中 的 下 一个 属性 ; 
 　 　 }   / / while 循环 结束 ,   意味着 所有 前提 成立 ,   即 结论 成立 
 　 　 return   true ; 
 　 　 }     / / end   of   if 
 else { / / 找 不到 任何 规则 可 得到 此 Goal 向 用户 询问 该 Goal 的 实际 值 ; 
 　 　 if   ( 用户 所 输入 的 值 与 所 需值 相等 ) 
 　 　 　 return   true ;   
 　 　 else   return   false ; 
 } 
 　 　 推理 过程 看起来 就 像 一个 搜索 过程 。 由于 对 规则 作 了 严格 的 规定 ， 因此 ， 只 需 考虑 那些 所用 到 的 规则 ， 也 就是 查找 到 其 结论 部分 与 所 推断 的 事实 相符合 的 规则 即可 对 推理 过程 作出 解释 。 
 5     应用 的 思路 
 　 　 当今 的 计算机 软件系统 变得 越来越 大 ， 它们 所 提供 的 服务 ( 即 功能 、 命令 、 操作 以及 资源 等 的 总称 ) 越来越 多 、 越来越 全 。 通常 ， 用户 对 服务 的 请求 是 以 “ 选择 — 执行 ” 模式 ( 或 类似 的 模式 ) 进行 的 ， 其中 “ 选择 ” 是 指 指定 服务 ( 无论是 用 名字 指定 ， 还是 通过 击 鼠标 钮 激活 图标 来 指定 ) ， 而 “ 执行 ” 是 指 服务 自身 的 运行 。 这种 “ 选择 — 执行 ” 模式 使得 服务 处于 一种 被动 的 地位 ， 即 如果 用户 不 知道 如何 请求 某 服务 的 存在 。 则 此 服务 也许 就 永远 被 搁置 一边 了 。 曹 存根 提出 了 主动性 服务 的 观点 ， 在 一定 条件 下 ， 即使 用户 未 选择 某一 服务 ， 服务 自己 也 可以 激活 自己 并 运行 起来   [ ３ ] 。 我们 认为 产生 式 专家系统 可以 实现 “ 在 一定 条件 下 ” 的 处理 ， 尤其 是 当 条件 比较复杂 的 情况 下 效果 更好 。 其 产生 式 规则 既 可以 由 人工 确定 ， 更 应该 由 系统 根据 其 状态 动态 产生 ( 如何 产生 ， 则 是 值得 花大 力气 去 认真 研究 ) 。 这 可以 成为 “ 人性化 ” 的 软件系统 的 基础 。 这 是 要 掌握 用 C 或 C++ ， 甚至 Java 实现 产生 式 专家系统 的 实际意义 ： 它 是 实现 应用 系统 更 智能化 的 一种 有效 手段 ， 也 是 构成 智能 体 ( Agent ) 的 基础 。 例如 将 专家系统 作为 一种 软件 构件 以 增加 应用 系统 的 智能 。 我们 认为 不仅 是 软件系统 ， 所有 的 计算机 应用 系统 中 同样 可以 提供 而且 应该 提供 主动性 服务 ， 这 既 是 计算机技术 发展 的 趋势 ， 更是 市场 激烈 竞争 的 要求 。 
 万 江平 ( 华南理工大学 电子信息 学院       工商管理 学院     广州   510641 ) 
 严明 ( 华南理工大学 电子信息 学院     工商管理 学院     广州   510641 ) 
 杨建梅 ( 华南理工大学 电子信息 学院     工商管理 学院     广州   510641 ) 
 参考文献 
 1 ， E .   A .   Fergenham ,   The   Art   of   Artificial   Intelligent :   Theme   and   Case   Studies   of   Knowledge   Engineering   l979 
 2 ， Paul   Harmon ,   David   King ,   Expert   System   Artificial   Intelligence   in   Business .   John   Wiley   & amp ;   Sons ,   INC   1985 
 3 ， 曹 存根 .   关于 主动性 服务 的 若干 讨论 .   软件 学报 ,   1995 ,   6 ( 11 ) :   694 ~ 698 
 4 ， 廖 卫东 ,   陈     梅 .   Java 程序设计 实用 指南 .   北京 :   机械 工业 出版社 
 5 ， 陈文伟 .   决策支持系统 及其 开发 .   北京 :   清华大学出版社 ,   1994 ,   10 
 6 ， 路 耀华 . 思维 模拟 与 知识 工程 . 北京 :   清华大学出版社 ,   1997 ,   9 
 收稿 日期 ： 1999 - 12 - 6 
