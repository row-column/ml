软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年   第 1 期   No.1   1999 
 
 
 
 实时 环境 下 的 问题 求解 *   
 陈 　 正 　 　 张 　 钹   
 　 　 摘要 　 实时 环境 下 的 问题 求解 是 近年来 规划 问题 研究 感兴趣 的 话题 . 在 讨论 了 传统 规划 算法 的 不足 之后 , 引入 了 在 实时 环境 下 求解 问题 的 方法 — — 任意 时间 算法 . 任意 时间 算法 可以 合理 分配 时间 资源 , 保证系统 最佳 的 输出 性能 ； 同时 , 任意 时间 算法 可以 在 任意 时刻 中断 , 并 输出 当时 相对 最优 可行 解 . 遗传算法 具有 任意 时间 算法 的 特性 , 在 介绍 了 同 其他 搜索算法 的 不同之处 后 , 通过 实验 得出 利用 随机 搜索 技术 和 知识 指导 相结合 的 方法 , 可以 较 好 地 处理 实时 规划 问题 . 最后 给出 结论 , 并且 简单 地 讨论 了 实时 规划 算法 求解 问题 的 策略 , 同时 讨论 了 今后 的 发展 方向 . 
 　 　 关键词 　 规划 , 任意 时间 算法 , 遗传算法 , 算子 . 
 　 　 中图法 分类号 　 TP18 
 Real - Time   Problem   Solving   
 CHEN   Zheng 　 ZHANG   Bo   
 　 　 Abstract 　 　 Real - time   problem   solving   is   an   interesting   topic   in   planning   in   recent   years .   Besides   discussing   the   deficiency   of   traditional   planning   algorithm ,   the   authors   imported   the   anytime   algorithm ,   which   can   solve   the   real - time   problems   in   this   thesis .   Anytime   algorithm   could   allocate   time   resource   reasonably   to   ensure   the   best   system   output   performance .   Anytime   algorithm   could   be   interrupted   at   any   time   and   output   the   relatively   best   probable   solution   in   that   time .   Genetic   algorithm   has   the   properties   of   the   anytime   algorithm .   After   introducing   the   differences   between   this   and   other   search   algorithms ,   through   the   experiments ,   the   authors   found   that   the   method ,   which   combines   the   random   search   technology   and   knowledge   based   method ,   could   solve   real - time   planning   problems   relatively   better   that   other   methods .   At   last ,   the   authors   gave   out   the   conclusion ,   discussed   the   policy   of   real - time   planning   problem   solving   algorithm   simply ,   and   discussed   the   possible   developments   in   the   future . 
 　 　 Key   words 　 Planning ,   anytime   algorithm ,   genetic   algorithm ,   operator . 
 　 　 传统 的 规划 是从 具体 行为 到 输出 动作 之间 的 一个 映射 , 它 认为 外界 环境 的 变化 很小 , 同时 外界 环境 对于 规划系统 来说 是 完全 可以 预知 的 一个 系统 . GPS （ general   problem   solve ） 可以 说 是 最初 的 规划系统 , GPS 对 规划 问题 作 了 一些 假设 , 它 假设 规划 是 由 动作 组成 的 序列 , 规划 输出 的 行为 都 是 可以 预言 的 , 这种 假设 现在 我们 称为 “ 传统 规划 ” （ Classical   Planning ） . 虽然 现在 有 不少 人 对 这种 假设 提出 了 疑问 , 但是 它 确实 能 解决 不少 问题 . ［ 1 ］ 
 　 　 上面 的 假设 虽然 能够 解决 一些 规划 方面 的 问题 , 但是 大多 情况 下 只 适用 于 离线 规划 环境 ； 当 机器人 处于 易变 的 、 不 完全 已知 的 环境 时 , 必须 不断 地 感知 周围环境 , 作出 相应 的 反应 . 在 这种 条件 下 , 显然 不 可能 再 把 机器人 的 行为 认为 是 可以 预知 的 动作 序列 了 . 因此 出现 了 不少 考虑 环境 对系统 的 影响 的 在线 规划 算法 , 如 ： Agre   和   Chapman ［ 2 ］ , Georgeff 和 Lansky ［ 3 ］ , Rosenschein 和 kaelbling ［ 4 ］ , Sanborn 和 Hendler ［ 5 ］ , Schoppers ［ 6 ］ , Firby ［ 7 ］ 等等 . 如果 把 这些 方法 简单化 , 就 可以 认为 它们 是 在 接受 外界 的 刺激 ( Stimulus ) 下 所 作出 的 反应 ( Response ) . ［ 1 ］ 
 　 　 传统 规划 认为 一个 规划 器具 有 足够 的 时间 寻找 最佳 结果 . 但是 , 如果 这个 时间 对于 一个 实际 问题 来讲 太 长 的话 , 就 应该 选择 在 找到 最佳 结果 前 , 得到 每个 时刻 的 局部 最优 结果 . 这 就 要求 我们 能 在 任意 时刻 中止 规划 算法 , 并且 给出 当时 的 最优 结果 , 具有 这种 特点 的 算法 我们 称为 “ 任意 时间 算法 ” ( Anytime   Algorithm ) . ［ 8 ］ 
 　 　 此外 , 现在 规划 研究 的 一种 趋势 是 , 把 传统 的 规划 方法 和 某种 响应 能力 ( 也 就是 能够 处理 动态 和 突发事件 的 能力 ) 相结合 , 出现 了 “ 分层 规划 ” 等 算法 , 这 对 解决 机器人 的 规划 问题 很 有 意义 . 
 1   任意 时间 算法 
 　 　 依赖于 时间 的 算法 就是 要 研究 在 给定 的 时间 内 如何 对 一些 事件 作出 最好 的 响应 . 在 现实 的 规划 问题 中 , 存在 着 很多 资源 限制 , 如 时间 资源 、 机器 的 硬件资源 等等 因素 , 如何 在 给定 的 资源 内 对系统 作出 最佳 的 规划 成为 规划 问题 研究 的 关键 . 而且 , 现实 的 规划 问题 处于 易变 的 环境 中 , 这 要求 算法 能够 适应环境 的 变化 . 
 　 　 近年来 提出 了 很多 关于 实时 环境 下 问题 求解 的 方案 , 其中 任意 时间 算法 具有 较 突出 的 特点 . 给出 一定 的 输入 数据 , 同时 分配 一定 的 时间 和 其他 资源 , 任意 时间 算法 将 给出 各种 性能 的 输出 结果 . 通过 分析 给定 的 输入 的 类型 、 给定 的 时间 以及 输出 结果 的 质量 , 可以 得到 一定 具有 预计 性 的 算法 模型 , 根据 这个 模型 , 可以 按照 算法 各个 部分 的 重要性 来 分配 时间 资源 , 以 求得 在 最 短 的 时间 内 给出 最优 输出 结果 . 任意 时间 算法 提出 的 解决方案 能够 较 好 地 适应 外部 以及 内部 的 不确定性 因素 , 满足 实时 环境规划 的 需要 . 
 　 　 对于 每个 需要 作出 响应 的 时间 c , 我们 假设 机器人 对 c 作出 任何 响应 都 有 一个 决定 过程 , 每个 决定 过程 我们 都 分配 一些 时间 , 返回 的 是 输出 响应 的 最好 的 结果 ε ∈ . 我们 定义 γ 是从 C × ＋ 到 的 映射 , 因此 , 对于 每个 c ∈ C 和 正 实数 δ , γ ( c , δ ) = ε 表示 机器人 在 给定 的 时间 δ 内 对 c 作出 的 最好 的 响应 类型 是 ε , 在 描述 机器人 对付 依赖于 时间 的 规划 问题 的 时候 , 我们 感兴趣 的 是 组合 的 功能 utility ( c , γ ( c , δ ) ) , 它 是 对 给定 时间 内所 输出 结果 的 一个 评价 . 
 　 　 下面 , 我们 介绍 5 种 类型 和 时间 相关 的 规划 算法 的 输出 性能 . 我们 设 ( x , y ) = utilit 
 ( x , γ ( x , y ) ) . ［ 8 ］ 
 　 　 ( 1 )   单调 上升 性 : c ∈ C , δ , ε ∈ R + , μ ( c , δ ) ≤ μ ( c , δ + ε ) ; 
 　 　 ( 2 )   阶跃 上升 ( 如图 1 ( a ) 所示 ) : c ∈ C , r , k ∈ R + , ; 
 　 　 ( 3 )   线性 增长 无 边界 ( 如图 1 ( b ) 所示 ) : c ∈ C , λ ∈ R + , μ ( c , δ ) = λ * δ ; 
 　 　 ( 4 )   线性 增长 有 边界 ( 如图 1 ( c ) 所示 ) : c ∈ C , r , λ ∈ R + , ; 
 　 　 ( 5 )   渐渐 减慢 上升 速度 ( 如图 1 ( d ) 所示 ) : c ∈ C , f , μ ∈ ( c , t ) = f ( t ) , 其中 f 是 单调 增函数 , 而且 x , y ∈ R + , f ′ ( x ) 和 f ′ ( y ) 存在 , x ＜ y ( f ′ ( y ) ≤ f ′ ( x ) ) . 
   
 图 1   
 　 　 现在 许多 规划系统 都 符合 第 2 种 类型 , 无论 提供 给 多少 时间 , 这些 系统 都 需要 固定 的 时间 来 完成 相同 的 任务 , 给 的 时间 如果 较 多 , 它们 也 仅仅 是 用来 规划 其他 事情 或者 什么 也 不 做 . 如果 给定 的 时间 不够 , 那么 , 系统 将 执行 缺省 的 动作 . 如果 当 规划 的 事件 可以 预测 的话 , 或者 规划 所 需要 的 时间 很 短 , 那么 , 第 2 种 方法 可以 得到 较 好 的 结果 . 第 3 、 4 种 方法 是 第 5 种 方法 的 特例 , 它们 在 实际 应用 中有 较 好 的 性能 , 可以 随着 给定 时间 的 增加 而 输出 最优 的 规划 结果 . 
 　 　 任意 时间 算法 的 特点 在于 : ( 1 )   它们 可以 在 任意 时刻 中断 , 而 不 需要 附加 的 负担 ; ( 2 )   它们 可以 在 任意 时刻 中断 , 并 返回 一些 结果 ; ( 3 )   返回 的 结果 随着 时间 的 增长 , 性能 也 在 改善 .   而 正是 
 ( 2 ) 、 ( 3 ) 两个 特点 使得 这个 不同于 其他 传统 的 规划 算法 , 为了 有所区别 , 我们 称之为 “ 任意 时间 算法 ” ( Anytime   Algorithms ) . ［ 8 ］ 
 2   遗传算法 （ GA ） 
 　 　 通过 上面 的 描述 不难看出 , 任意 时间 算法 最大 的 特点 就 在于 它 合理 地 利用 了 提供 给 它 的 资源 , 使得 这个 算法 可以 适应 实际 环境 的 需求 , 在 需要 的 时刻 可以 输出 当时 的 最优 解 . 任意 时间 算法 不仅 可以 不断 优化 算法 输出 的 结果 , 使 性能 随着 时间 的 增加 而 增长 ； 而且 它 可以 对 各个 子系统 合理 地 分配资源 , 达到 系统 的 最优 输出 . 不过 , 任意 时间 算法 给出 的 是 实时 算法 的 一个 框架 , 适用 于 各种 实时 计算 , 但是 对于 不同 的 实际 问题 , 还 需要 在 任意 时间 算法 理论指导 下 采用 相应 的 解决 策略 . 在 规划 方面 出现 了 许多 适用 于 实时 环境 的 需求 的 算法 , 它们 都 遵循 任意 时间 算法 提出 的 框架 , 其中 “ 遗传算法 ” 可以 说 具有 较 突出 的 特点 . 
 2.1   遗传算法 介绍 
 　 　 遗传算法 是 一种 基于 自然选择 和 自然 遗传学 机制 的 搜索 方法 . 它 通过 自然选择 中 的 “ 优胜劣汰 ” 的 策略 在 每次 搜索 中 生成 一些 新 的 串 结构 , 淘汰 较差 的 结构 , 对于 最 适合 的 结构 加以 保留 , 每次 都 是 利用 随机 技术 进行 交叉 生成 下一代 . 由于 利用 了 这种 随机 技术 , 使得 遗传算法 不同于 其他 传统 的 搜索 方法 , 但 它 又 不仅仅 是 随机 搜索 , 因为 它 还 有效 地 利用 了 许多 历史 信息 , 使得 在 每代 生成 中 都 朝着 最好 的 方向 前进 . 
 　 　 传统 的 搜索 方法 与 遗传算法 比较 起来 , 最大 的 区别 就 在于 它们 的 “ 鲁棒性 ” . 传统 的 搜索算法 大多 只 适用 于 某些 特定 的 环境 , 如果 环境 发生变化 , 算法 就 不能 很 好 地 适应 变化 来求 出 较优 解 ； 而 对于 遗传算法 , 采用 了 随机 技术 , 使得 它 可以 运行 于 任何 复杂 环境 中 , 而且 能够 通过 不断 优化 自身 的 解来 逼近 最优 解 . 在 介绍 遗传算法 前 , 我们 先 来 看看 传统 的 搜索算法 的 特点 . 
 　 　 传统 的 搜索算法 大体上 可以 分为 3 类 ： ［ 9 ］ 
 　 　 ( 1 )   基于 微分 概念 的 搜索 . 整个 搜索 过程 就是 对 搜索 空间 进行 微分 , 求其 导数 为 0 的 点 , 或者 利用 Hill 爬山 法求 出 其 局部 最优 值 . 这种 方法 广泛 适用 于 许多 场合 , 但是 , 如果 在 搜索 空间 中 存在 多个 峰值 点时 , 就 不能 很 好 地 找出 整个 搜索 空间 的 最优 解 , 只能 在 找到 局部 最优 解后 随机 寻找 新 的 起始 点 , 继续 开始 新 的 搜索 . 
 　 　 ( 2 )   枚举法 . 这种 方法 适合 于 搜索 空间 是 有限 的 离散 数据 集合 , 缺乏 有效性 , 适用范围 也 比较 小 . 当 搜索 空间 加大 时 , 它 就 显得 不能 适应 实际 环境 , 也 就 显示 出其 较差 的 “ 鲁棒性 ” . 
 　 　 ( 3 )   随机 搜索 . 遗传算法 是 利用 “ 随机 选择 ” 作为 一个 工具 来 指导 算法 在 一个 参数 编码 串 组成 的 空间 中 进行 搜索 . 它 不是 单纯 的 随机 搜索 , 而 仅仅 是 利用 随机 选择 作为 搜索 手段 , 将 系统 的 输出 作为 评价 , 使得 系统 的 输出 性能 不断 提高 , 求得 最优 解 . 
 　 　 评价 一个 搜索算法 的 准则 在于 , 算法 是否 能够 在 给定 的 时间 与 资源 范围 内 给出 较优 的 解决方案 . 仅仅 输出 最优 解并 不能 表明 这个 算法 一定 是 最好 的 , 在 实际 环境 中 , 我们 更 重视 的 是 能够 在 给定 的 资源 （ 包括 时间 资源 ） 内 给出 最好 的 响应 . 而 遗传算法 正是 具有 这方面 的 特点 . 它 存在 着 不同于 其他 算法 的 特性 , 主要 表现 为 以下 4 个 方面 ： 
 　 　 ( 1 )   搜索 空间 是 参数 集合 的 编码 , 而 不是 参数 本身 . 
 　 　 ( 2 )   GAs 的 搜索 空间 是 一群 例子 , 而 不是 一个 实例 . 这样 可以 避免 只 搜索 到 局部 极值 , 而 丢失 全局 最优 . 
 　 　 ( 3 )   GAs 利用 输出 结果 的 性能 来 指导 算法 朝着 最优 的 方向 前进 , 而 不 利用 一些 特殊 的 知识 . 这样 保证 了 系统 的 鲁棒性 , 可以 适用 于 任何 环境 . 
 　 　 ( 4 )   利用 随机 工具 作为 搜索 手段 . 
 　 　 以上 4 个 特性 使得 遗传算法 可以 在 搜索 中 保持良好 的 鲁棒性 , 适用 于 任何 实际 环境 . 
 2.2   传统 GA 算法 的 算子 
 　 　 遗传算法 在 编码 串 空间 进行 搜索 , 搜索 过程 中 使用 算子 来 对 串 进行 处理 , 得到 新 的 串 集合 . 在 GA 算法 中先 寻找 一个 基本 可行 解 , 然后 对 这个 基本 可行 解 进行 进化 （ 优化 ） , 进化 的 方法 （ 算子 ） 基本上 来说 有 以下 3 种 ： ① selection （ 选择 ） , ② Crossover （ 交叉 ） , ③ mutation （ 突变 ） . 
 　 　 GAs 通过 以上 3 个 算子 在 串 编码 空间 进行 搜索 , 根据 系统 输出 的 结果 性能 对 编码 串 进行 评价 , 利用 随机 技术 进行 Reproduction , 同时 利用 随机 技术 选择 交叉点 , 对 编码 串 进行 交叉 , 得到 新 的 下一代 编码 串 , 同时 在 这个 过程 中 允许 在 突变 概率 内 对 编码 串 进行 突变 . 
 2.3   遗传算法 的 特点 
 　 　 ( 1 )   遗传算法 具有 任意 时间 算法 的 特点 , 可以 在 任意 时刻 中断 , 并 输出 当时 的 基本 较优 可行 解 （ 当然 很多 遗传算法 输出 的 解 并 不 符合要求 , 但是 , 经过 适当 改进 可以 满足 实际 问题 的 要求 ） . 随着 规划 时间 的 增加 , 系统 的 性能 在 增长 . 
 　 　 ( 2 )   遗传算法 采用 随机 技术 , 因此 可以 避免 传统 搜索 方法 的 局部 最优 的 限制 , 找到 全局 最优 解 . 
 　 　 ( 3 )   由于 其 收敛 取决于 评价 以及 知识 的 应用 , 因此 , 只有 与 一些 传统 方法 相结合 才能 发挥 其 最大 效用 . 
 　 　 ( 4 )   传统 算法 则 需要 较 多 的 知识 支持 , 当 知识 不 明显 或者 缺乏 时 , 就 无法 给出 解答 方法 ； 而 遗传算法 只要 给出 评价 方法 , 就 可以 进行 规划 , 受 外部 条件 的 限制 较少 . 
 3 　 实际 问题 求解 
 3.1   实际 应用 中 简单 遗传算法 ( SGA ) 存在 的 问题 
 　 　 遗传算法 最 重要 的 一个 特点 就是 它 不同于 其他 规划 算法 , 具有 很强 的 鲁棒性 , 可以 适用 于 各种 易变 的 环境 , 而且 它 能够 不断 优化 输出 的 结构 , 取得 较优 的 输出 解 . 但是 , SGA 仅仅 依靠 系统 的 输出 作为 评价 , 而 不 利用 系统 的 一些 有用 的 经验 知识 或 其他 有效 知识 , 虽然 这样 提高 了 系统 的 鲁棒性 , 但是 却 使得 整个 系统 的 搜索 速度 比较 缓慢 , 收敛 缓慢 , 而且 还有 可能 找 不到 搜索 解 . 尽管如此 , 遗传算法 给出 的 观点 仍 值得 我们 作为 指导 依据 . 它 采用 了 自然界 中 “ 优胜劣汰 ” 的 原则 , 符合 实时 算法 的 需求 , 可以 不断 优化 系统 的 输出 , 能够 在 任意 时刻 中断 并 输出 较优 解 , 因此 , 适当 地 对 遗传算法 进行 改造 , 就 可以 得到 一个 较 好 的 实时 搜索算法 . 
 3.2   实际 应用 
 　 　 遗传算法 广泛应用 于 许多 搜索 领域 , 下面 以其 在 “ 路径 搜索 ” 算法 方面 的 应用 作为 例子 , 来 看看 遗传算法 在 实际 应用 中 存在 的 问题 . 
 传统 的 搜索 方法 虽然 存在 自身 的 缺陷 , 不适 用于 易变 的 外界 环境 , 但是 它 也 存在 着 很多 优点 , 它 可以 很 好 地 利用 许多 已知 的 知识 作为 搜索 指导 , 较 快 地 得到 系统 的 解 . 因此 , 可以 合理 地 对 遗传算法 进行 改造 , 在 遗传算法 的 基础 上 增加 一些 知识 算子 来 指导 搜索 的 方向 , 加快 搜索 的 速度 , 来 弥补 简单 遗传算法 中 随机 搜索 的 缺陷 . 
 在 规划 中 , 遗传算法 的 主体 都 是 相同 的 , 还是 利用 随机 技术 作为 基本 依据 , 但是 由于 加入 了 知识 的 指导 , 使得 系统 在 每代中 都 朝着 优化 的 方向 前进 . 在 SGA 中 采用 的 方法 基本上 都 是 先 寻找 一个 基本 可行 解 , 然后 对 这个 基本 可行 解 进行 进化 （ 优化 ） . 进化 通过 事先 选定 的 算子 和 评价 方法 进行 操作 . 进化 的 方法 基本上 来说 有 以下 3 种 ： 复制 、 交叉 、 突变 . 然而 在 实际 问题 解决 中 , 由于 不同 问题 采用 的 知识 表示 方法 不同 , 因此 在 算子 的 实际 应用 中 也 存在 较大 的 差别 , 而且 评价 方法 也 不同 , 所以 对于 不同 问题 , 上面 3 种 算子 也 要 进行 相应 的 改变 以 适应 实际 需求 . 下面 , 我们 以 “ 路径 规划 ” 算法 中 的 实际 解决方案 为例 , 来 看看 实际 知识 是 如何 应用 于 遗传算法 中 的 . 
 路径 规划 要 解决 的 问题 是 ： 给定 一个 具有 障碍 的 二维 空间 , 给定 起点 和 终点 , 寻找 一条 无障碍 的 最 短 路径 . 
 　 　 . 数据表示 方法 
 　 　 在 路径 规划 中 , 实际 路径 采用 的 表示 方法 是 采用 路径 中 的 一系列 关键点 来 表示 实际 路径 , ( s , d1 , d2 , ... , dn , e ) 就 代表 一条 实际 路径 , 其中 s 为 起点 , e 为 终点 , di 为 路径 中 的 关键点 . 
 　 　 . 评价 方法 
 　 　 ( 1 )   与 障碍物 相交 的 长度 （ 越短 越 好 ） ; 
 　 　 ( 2 )   与 障碍物 相交 的 次数 （ 越少 越 好 ） ; 
 　 　 ( 3 )   路径 长度 （ 越短 越 好 ） . 
 其中 优先级 逐渐 降低 , 力求 先 找出 可行 解 , 然后 再 寻求 最优 路径 . 
 　 　 . 算子 
 　 　 ( 1 )   交叉 算子 ： 采用 的 是 随机 在 两条 路径 中 选择 一个 交叉点 , 然后 对 这 两条 路径 进行 交叉 , 得到 两条 新 的 路径 , 如图 2 所示 （ 选择 3 作为 交叉点 ） . 
   
 图 2 　 交叉 算子   
 　 　 ( 2 )   突变 ： 突变 有 以下 几种 : ① 随机 改变 关键点 的 位置 , ② 加点 , ③ 减点 , 也 就是 随机 抽取 一个点 , 在 其 位置 上 改变 、 加入 或者 删除 一个点 . 改变 / 加入 的 点 的 位置 也 是 随机 生成 的 . 如图 3 所示 , 改变 / 加 / 减点 位置 选择 在 3 . 
   
 图 3 　 突变 算子 （ 改变 ／ 加 ／ 减点 ）   
 　 　 综上所述 不难看出 , 传统 的 GA 对 解决 路径 规划 问题 采用 的 就是 随机 的 方法 与 评价 策略 相结合 的 方法 . 这种 方法 经过 多代 的 选择 后 可以 得到 较优 的 解决方案 , 但是 如果 障碍物 较 多 , 那么 实际 搜索 时间 就 会 变得 很长 , 甚至 找不出 解答 方案 , 因为 随机 搜索 寻找 最优 解 毕竟 速度 比较慢 , 而且 可以 说 逼近 最优 的 速度 完全 取决于 评价 策略 . 同时 , 由于 缺乏 实际 知识 的 指导 , 因而 随机 方法 存在 一定 的 适用性 . 
 　 　 针对 以上 问题 , 适当 地 改进 算子 , 加入 实际 知识 的 指导 , 增加 了 以下 算子 . 
 　 　 . 躲避 障碍 的 交叉 
 　 　 在 路径 规划 中 , 需要 寻求 的 是 一条 无障碍 的 最 短 路径 . 在 GA 算法 中 先是 生成 一些 基本 可行 解 , 然后 对 这些 基本 可行 解 进行 优化 , 在 GA 算法 的 最 开始 , 这个 基本 可行 解是 采用 随机 的 方法 生成 , 因此 不可避免 地 存在 着 与 障碍物 的 交遇 , GA 在 每代 生成 中 试图 去除 这些 不 可行 部分 , 同时 达到 路径 长度 最短 . 利用 路径 规划 算法 的 特点 , 我们 在 GA 算法 的 算子 中 进行 适当 的 改进 , 使得 每次 操作 后 路径 都 尽可能 地 避开 障碍物 , 与 障碍物 的 交叉 尽量减少 , 从而 加快 最优 解 的 寻找 . 
 　 　 具体 采用 的 算子 操作 如下 ： 对 一条 实际 的 路径 ( s , d1 , d2 , ... , dn , e ) , 如果 其中 di - dj 与 障碍物 相交 , 那么 “ 躲避 障碍物 的 算子 ” 则 会 处理 这 段 不合 理解 , 代之以 其他 的 关键点 . 其 主要 的 指导思想 就是 利用 平时 人们 搜寻 路径 时 , 遇到 障碍物 就 争取 避开 这 条 原则 , 力求 使 新 生成 的 路径 与 障碍物 的 相交 点 尽可能少 , 具体 采用 的 方法 如图 4 所示 . 在 增加 新 关键点 策略 方面 , 可以 有 以下 两种 ： ( 1 )   寻找 一个 新 关键点 来 代替 原有 的 不合理 关键点 ; ( 2 )   寻找 几个 新 关键点 来 代替 原有 的 不合理 关键点 . 
   
 图 4 　 躲避 障碍 算子   
 　 　 . 距离 最近 交叉 
 　 　 在 路径 规划 中 除了 需要 躲避 障碍物 之外 , 另外 一个 重要 的 条件 就是 要求 路径 长度 最短 . 在 交叉 中有 可能 使 两条 生成 的 路径 的 长度 都 增加 , 因此 , 适当 地 选择 交叉点 , 使 交叉 后 路径 的 长度 尽量 变短 , 也 是 要 采用 的 一种 策略 . 考虑 到 路径 长度 的 因素 , 因此 , 在 交叉 时 我们 选择 两点 距离 较 短 的 点 作为 交叉 选择 点 . 
 　 　 假设 两条 路径 分别 为 路径 1 : ( s , d1 , d2 , ... , dn , e ) 与 路径 2 : ( s , d ′ 1 , d ′ 2 , ... , d ′ m , e ) ； 计算 各个 点 之间 的 距离 , 找出 距离 最短 的 点 , 假设 为 i = { j ｜ min ( ｜ d1 , d ′ 2 ｜ - ｜ d1 , d2 ｜ , ｜ d ′ 1 , d2 ｜ - ｜ d ′ 1 , d ′ 2 ｜ , ... , ｜ dj , d ′ i + 1 ｜ - ｜ dj , dj + 1 ｜ - ｜ d ′ j , di + 1 ｜ - ｜ d ′ j , d ′ j + 1 ｜ , ... ) } , 则 选择 di 作为 交叉点 , 交叉 路径 1 和 路径 2 , 得到 新 的 路径 1 ′ : ( s , d1 , ... , di , di + 1 , ... , dm , e ) 与 路径 2 ′ : ( s , d ′ 1 , ... , d ′ i , d ′ i + 1 , ... , dn , e ) , 如图 5 所示 . 
   
 图 5 　 距离 最近 交叉 算子   
 　 　 . 对 路径 进行 优化 
 　 　 在 由 遗传算法 交叉 生成 的 路径 中 , 不可避免 地 存在 着 很多 自圈 路径 , 消除 这些 自圈 , 得到 实际 的 路径 才 是 系统 最终 的 需要 . 首先 需要 解决 的 是 把 由 关键点 组成 的 路径 转换成 由图 中 每个 实际 点 组成 的 实际 路径 , 对于 一条 从 ( x1 , y1 ) 到 ( x2 , y2 ) 的 路径 （ 图中 虚线 表示 的 路径 ） 可以 转换成 图中 实际 表示 的 路径 , 也 就是 把 每个 小 方格 看成 是 一个点 , 如图 6 所示 . 
   
 图 6 　 优化 路径   
 　 　 实现 算法 如下 ： 
 　 　 
 　 　 x = x1 
 　 　 y = y1 
 　 　 i = 0 
 　 　 while   ( i ＜ ｜ x2 - x1 ｜ + ｜ y2 - y1 ｜ { 
 　 　 　 　 
 　 　 　 　 
 　 　 　 　 则 ( ［ x ］ , ［ y ］ ) 为 其下 一步 的 坐标 , 其中 ［ x ］ 与 ［ y ］ 是 x , y 四舍五入 的 结果 x = x + Δ x 
 　 　 } 
 　 　 其次 就是 对 交叉 求出 的 较优 解 进行 优化 , 优化 的 方法 也 就是 对 整个 路径 先求 出 其 “ 精细 路径 ” , 去除 其中 重复 的 路径 , 最后 得到 最短 的 一条 路径 , 如图 7 所示 . 
   
 图 7 　 去除 重复 路径   
 　 　 除了 上面 提到 的 一些 利用 知识 的 算子 外 , 我们 还 引入 了 一些 相关 的 技术 , 与 遗传算法 相结合 来 共同 求解 问题 . 对于 规划 空间 , 我们 先 在 较 粗粒度 上 进行 搜索 , 得到 初步 的 可行 解后 再 对 规划 空间 进行 细化 , 求得 准确 的 较优 可行 解 . 
 　 　 同时 , 我们 也 引入 了 “ 分 区域规划 ” 的 概念 , 利用 知识 对 规划 的 空间 进行 区域 划分 , 对 划分 后 的 区域 分别 进行 规划 （ 利用 遗传算法 ） , 然后 合并 结果 , 得到 较优 的 可行 解 . 
 　 　 在 路径 规划 算法 中 , 我们 先较 粗地 划分 规划 的 整个 区域 , 找出 一些 基本 可行 解 , 然后 对 区域 进行 划分 , 得到 哪些 区域 是 路径 比较 集中 的 , 哪些 区域 是 障碍物 较 多 、 路径 不 集中 的 , 然后 再 在 细 的 区域 粒度 下 进行 规划 . 利用 分层 规划 的 概念 后 , 可以 使 系统 搜索 的 速度 加快 . 
 3.3 　 总结 知识 在 实时 求解 问题 中 的 应用 
 　 　 通过 上面 的 实验 不难看出 , 单纯 利用 遗传算法 对 问题 进行 求解 既 存在 优点 , 也 存在 不足之处 . 虽然 单纯 地 利用 随机 技术 可以 提高 系统 的 “ 鲁棒性 ” , 但是 缺乏 相关 知识 的 指导 , 使得 系统 搜索 的 方向 比较 盲目 , 单纯 的 随机 搜索 使得 系统 趋于稳定 的 速度 大大降低 . 适当 地 引入 经验 知识 做 指导 , 可以 大大 加快 系统 的 搜索 速度 , 同时 又 利用 遗传算法 的 随机 选择 作为 技术 , 避免 了 丢失 全局 最优 解 , 因此 , 分层 规划 越来越 受到 大家 的 重视 . 
 　 　 但是 也 不容忽视 的 是 , 引入 的 知识 是否 合适 , 对系统 的 性能 的 影响 是 很大 的 , 不 合适 的 知识 不仅 不会 对系统 的 搜索 速度 起到 什么 正面 作用 , 而且 还有 可能 把 搜索 带入 歧途 , 导致系统 丢失 最优 解 . 而且 引入 知识 后 , 系统 在 处理 知识 方面 不可避免 地 需要 投入 适当 的 开销 , 因此 , 需要 平衡 其 利弊 来 考虑 引入 哪 方面 的 知识 . 我们 在 实验 中 发现 , 在 路径 规划系统 中 最 花费 时间 的 部分 就是 对 路径 的 评价 . 引入 不同 的 知识 评价 的 时间 不同 . 只有 合理 的 利用 知识 和 遗传算法 相结合 , 才能 更好 地 取得 搜索 的 结果 . 
 3.4   实   验 
 　 　 根据 文章 中 提到 的 方法 , 我们 在 IMB － PC   Pentium133 机器 上 实现 了 路径 规划 算法 , 程序 采用 Microsoft   V C++ 4.2 开发 , 在 Windows95 下 运行 , 以下 的 实验 数据 均 是 在 此 环境 下 得到 的 . 
 　 　 在 路径 规划 程序 中 , 我们 在 300 * 200 （ pixel ） 的 地图 上 进行 规划 , 路径 障碍物 可 随机 或 人工 生成 , 初始化 随机 路径 数设 为 100 , 路径 中 关键点 个数 设为 10 , 随机 突变 概率 为 5 ％ . 评价 方法 采用 “ 路径 与 障碍物 相交 长度 ” 以及 “ 路径 实际 长度 ” 作为 评价 . 在 规划 的 初期 以 “ 与 障碍物 相交 长度 ” 评价 为主 , 到 了 规划 后期 , 路径 趋于 合理 , 与 障碍物 相交 的 长度 渐渐 变小 , 因此 评价 以 “ 路径 最短 ” 为主 . 我们 分别 通过 以下 几种 途径 对 遗传算法 进行 测试 ： 
 　 　 ( 1 )   采用 基本 随机 算法 , 不 加入 任何 多余 的 知识 信息 ; 
 　 　 ( 2 )   改变 初始 路径 个数 以及 关键点 个数 ; 
 　 　 ( 3 )   引入 相应 的 知识 信息 作为 指导 . 
 　 　 从 实验 中 不难看出 , 基本 的 遗传算法 虽然 具有 很强 的 鲁棒性 , 可以 适应 外界 环境 , 但是 由于 缺乏 相应 的 知识 作为 指导 , 容易 陷入 迷途 , 导致 需要 较长 的 时间 才能 找到 较优 解 , 而且 如果 系统 初始 的 人口 规模 不 大 , 还 容易 使 系统 稳定 在 某些 解上 , 而 这些 解并 不 满足 系统 的 要求 . 在 路径 规划 算法 中 , 如果 在 障碍物 的 数目 相对来说 并不多 的 情况 下 , 基本 的 遗传算法 可以 较 好 地 找出 可行 最优 解 , 但是 , 随着 障碍物 的 增加 , 基本 遗传算法 的 寻找 速度 就 大大 减低 . 下面 的 例子 就 稳定 在 一个 不 适宜 的 解上 , 但是 如果 加大 人口 规模 , 系统 就 可 跳出 这个 相对 稳定 解 , 有 可能 寻找 到 较优 可行 解 . 系统 运行 了 78 代后 , 基本 稳定 在 这个 解上 , 与 障碍物 相交 长度 最短 为 37 , 如图 8 所示 . 
   
 图 8 　 基本 遗传算法   
 　 　 在 引入 了 相应 知识 指导 后 , 系统 性能 大大提高 . 我们 引入 的 知识 基本 观点 在于 两个 方面 : 一方面 是 尽量避免 与 障碍物 相交 , 也 就是 上面 提到 的 避免 碰撞 算子 , 另一方面 也 引入 了 相应 知识 使得 路径 长度 尽量 减短 , 例如 ： 交叉 中 有意识 选择 交叉点 、 优化 相应 路径 等 方法 . 从 实验 中 我们 看出 , 并 不是 所有 知识 对系统 都 能 起到 效果 , 而且 具体 对系统 的 影响 也 不同 . 不同 知识 适用 的 方面 也 各不相同 , 在 系统 开始 时 , 避免 碰撞 算子 起到 了 显著 的 作用 , 到 了 系统 运行 的 后期 , 路径 较 短 算子 开始 起 作用 . 同时 , 还 需注意 到 的 是 加入 知识 算子 后 加大 了 系统 的 负载 , 无论 从 时间 还是 空间 复杂度 上 来说 都 比 基本 遗传算法 大 . 因此 不可 盲目 地 引入 知识 , 只有 选择 适合 系统 的 知识 , 才能 发挥 其 最大 的 效果 . 如何 适当 选择 知识 , 处理 知识 与 复杂度 之间 的 平衡 关系 也 是 需要 进一步 研究 的 问题 . 采用 以上 方法 , 我们 进行 了 相应 实验 , 实验 结果 如图 9 ( a ) 、 ( b ) 所示 . 实验 1 数据 见表 1 . 
   
 图 9 　 加入 知识 （ 避障 算子 ） 后 规划 结果   
 表 1   
 
 n   
 N 
 C1   
 5 
 5992   
 71 
 5623   
 80 
 1094   
 77 
 1075   
 83 
 796   
 46 
 817   
 73 
 818   
 19 
 819   
 66 
 8510   
 80 
 8511   
 20 
 6412   
 59 
 9313   
 49 
 9414   
 69 
 7415   
 36 
 4916   
 73 
 9717   
 43 
 9618   
 31 
 10119   
 41 
 9920   
 30 
 115 
 n   
 N 
 C21   
 28 
 10222   
 18 
 11423   
 32 
 11024   
 40 
 11425   
 55 
 11026   
 80 
 6327   
 60 
 9028   
 75 
 9029   
 34 
 10030   
 86 
 8531   
 25 
 7132   
 29 
 5933   
 44 
 7234   
 23 
 7235   
 86 
 6136   
 0 
 7337   
 44 
 7538   
 16 
 5539   
 57 
 5940   
 61 
 59 
 n   
 N 
 C41   
 74 
 5942   
 81 
 5943   
 20 
 5944   
 8 
 5945   
 2 
 5046   
 23 
 4147   
 86 
 6248   
 20 
 6249   
 32 
 2650   
 28 
 2651   
 11 
 2552   
 39 
 2553   
 28 
 2554   
 3 
 2455   
 6 
 2756   
 0 
 1957   
 0 
 1358   
 11 
 059   
 31 
 060   
 82 
 0 
 
 其中 n 代表 第几代 , N 代表 第 n 代中评 价值 最高 的 路径 编号 , C 代表 第 n 代中评 价值 最高 的 路径 与 障碍物 相交 的 长度 . 
 　 　 在 实验 1 中 , 系统 运行 了 60 代 左右 后 基本 稳定 , 而且 寻找 出 较优 可行 解 . 在 其他 实验 中 , 我们 发现 引入 不同 的 避障 算子 , 对系统 的 性能 的 影响 也 各不相同 , 在 这里 就 不 给出 具体 的 实验 数据 了 . 
 　 　 从 实验 数据 可以 看出 , 引入 规划 知识 , 对 搜索 起到 了 很大 的 指导作用 , 加快 了 搜索 速度 . 但是 , 我们 也 注意 到 , 随着 知识 的 引入 , 加大 了 系统 的 复杂度 , 每 代为 了 躲避 障碍物 需要 花费 较 多 的 时间 , 而且 随着 障碍物 的 增加 , 系统 增加 的 关键点 也 逐渐 增加 , 系统 的 空间 和 时间 复杂度 都 明显 加大 . 因此 , 并 不是 引入 知识 就 一定 对 规划 起到 正 作用 , 只有 达到 一定 程度 , 才能 发挥 其 最大 作用 . 可以 确认 的 一点 是 , 随着 知识 的 引入 , 可以 减小 初始 的 人口 ； 如果 不 引入 知识 , 当 障碍物 数量 达到 一定 程度 时 , 系统 搜索 会 稳定 在 一些 不 可行 解上 , 这时候 只有 加大 初始 人口 才能 求 出 可行 解 , 不过 随着 知识 的 引入 , 可以 较 好地解决 这个 问题 . 因此 , 如何 处理 好 障碍物 数量 、 初始 人口 、 知识 类型 以及 规划 的 时间 、 空间 复杂度 之间 的 关系 成为 今后 研究 的 关键 .   
 4 　 总 　 结 
 　 　 实时 规划 算法 要求 系统 能 在 制定 的 资源 内 给出 相对 最优 的 解决方案 , 同时 , 系统 可以 处理 各种 突发 的 意外事件 , 可以 在 任意 时刻 中止 规划 算法 , 输出 当时 认为 最优 的 解决方案 ； 给定 的 时间 越 多 , 系统 的 输出 性能 就 越 好 . 任意 时间 算法 提出 的 框架 符合 这些 特性 , 也 决定 了 它 适用 于 实时 环境 下 问题 规划 求解 . 利用 任意 时间 算法 , 可以 合理 分配 系统资源 , 以 求得 最优 系统 性能 ； 同时 , 在 实际 应用 中 适当 地 引入 经验 知识 作为 指导 , 可以 大大 加快 系统 的 规划 速度 , 以 求得 最优 解决方案 . 
 本文 研究 得到 国家自然科学基金 和 国家 863 高科技 项目 基金 资助 。 
 作者 介绍 ： 陈正 , 1972 年生 , 博士 , 主要 研究 领域 为 人工智能 ， 实时 环境 问题 求解 ， 规划 ， 调度 . 
 　 　 　 　 　 张钹 , 1935 年生 , 教授 , 博士生 导师 , 中国科学院 院士 , 主要 研究 领域 为 计算机 应用 技术 ， 人工智能 . 
 本文 通讯联系 人 ： 陈正 , 北京   100084 , 清华大学 计算机科学 与 技术 系 
 作者 单位 ： 陈 　 正 　 清华大学 计算机科学 与 技术 系 　 北京 　 100084 　 
 　 　 　 　 　 张 　 钹 　 清华大学 智能 技术 与 系统 国家 重点 实验室 　 北京 　 100084 
 E - mail :   snowchen @ 263 . net 
 参考文献 
 　 ［ 1 ］   McDermott   D ,   Hendler   J .   Planning :   what   it   is ,   what   it   could   be ,   an   introduction   to   the   special   issue   on   planning   and   scheduling .   Artificial   Intelligence ,   1995 , 76 : 1 ～ 16 
 　 ［ 2 ］   Agre   P   E ,   Chapman   D .   Pengi :   an   implement   of   a   theory   of   activity .   In :   Proceedings   of   American   Association   for   Artificial   Intelligence ' 87 .   1987 .   268 ～ 272 .   http :   ∥ www . ncstrl . org 
 　 ［ 3 ］   Georgeff   M   P ,   Lansky   A .   Procedural   knowledge .   IEEE   Proceedings ,   Special   Issue   on   Knowledge   Representation ,   1986 , 74 ( 10 ) : 1383 ～ 1398 
 　 ［ 4 ］   Kaelbling   L   P ,   Rosenschein   S   J .   Action   and   planning   in   embedded   agents .   In :   Patti   Maes   ed .   New   Architectures   for   Autonomous   Agents :   Task - level   Decomposition   and   Emergent   Functionality .   Cambridge ,   MA :   MIT   Press ,   1990 .   35 ～ 48 
 　 ［ 5 ］   Sanborn   J ,   Hendler   J .   A   model   of   reaction   for   planning   in   dynamic   domains .   In :   International   Joint   of   AI   Engineering .   1988 .   http :   ∥ www . ncstrl . org 
 　 ［ 6 ］   Schoppers   M .   Universal   plans   for   reactive   robots   in   unpredictable   environments .   In :   Proceedings   of   the   International   Joint   Conference ' 87   on   Artificial   Intelligence .   1987 .   1039 ～ 1046 .   http :   ∥ www . ncstrl . org 
 　 ［ 7 ］   Firby   R   J .   An   investigation   into   reactive   planning   in   complex   domains .   In :   Proceedings   of   American   Association   for   Artificial   Intelligence ' 87 .   1987 .   http :   ∥ www . ncstrl . org 
 　 ［ 8 ］   Dean   T   L ,   Boddy   M .   An   analysis   of   time - dependent   planning .   In :   Proceedings   of   American   Association   for   Artificial   Intelligence ' 88 .   1988 .   49 ～ 54 .   http :   ∥ www . ncstrl . org 
 　 ［ 9 ］   Goldberg   D   E .   Genetic   Algorithms   in   Search ,   Optimization ,   and   Machine   Learning .   Reading ,   MA :   Addison - Wesley   Publishing   Company ,   Inc . ,   1989 .   3 ～ 6 
 本文 1997 - 10 - 15 收到 原稿 , 1998 - 01 - 09 收到 修改稿   
