计算机 工程 
 COMPUTER   ENGINEERING   
 1999 年   第 25 卷   第 5 期   Vol.25   No.5   1999 
 
 
 
 基于 部件 设计 的 可靠性 研究 
 云晓春   方滨兴 
 摘要   研究 基于 部件 设计 的 可靠性 问题 . 首先 提出 一个 基于 部件 设计 的 模型 : 如何 抽象地 描述 一个 部件 ? 如何 利用 已破 的 部件 构造 新 的 部件 ? 如何 在 给定 部件 实现 的 情况 下 , 静态 地 验证 部件 的 正确性 ? 然后 讲座 在 部件 实现 不 可知 的 情况 下 , 如何 利用 包裹 ( wrapper ) 技术 和 虚拟 部件 行为 模式 动态 地 检测 并 保证 部件 运行 的 正确性 . 
 关键词   基于 部件 设计   形式 语义   可靠性 . 
 Research   on   the   Reliability   of   Component   Based   Design 
 Yun   Xiaochun   Fang   Binxing 
 ( Computer   Department , Harbin   Insititute   of   Technology   Harbin   150001 ) 
 [ Abstract ]   Inthis   paper , we   study   the   problems   of   reliability . We   firstlyu   present   a   model   of   component   bases   design : How   to   describe   a   component   abstractly ? How   to   construct   a   new   component   in   terms   of   sub - conponents ? How   to   verify   the   correcrtness   of   a   component   using   warpper   and   virtral   component   behaviour   pattern . 
 [ Key   words ]   Component   based   design ;   Formal   semantica ;   Reliability 
 　 　 在 开发 大型 商业软件 时 通常 会 遇到 费用 昂贵 、 耗时 、 难于 测试 、 维护 和 更新 等 问题 ， 人们 通常 把 这 一系列 严重 问题 统称 为   "   软件 危机   "   。 基于 部件 设计 的 思想 正是 针对 这些 问题 而 提出 的 。 它 的 基本 策略 是 ： 利用 可 重用 、 预测 试且 可 独立 更新 的 部件 来 装配 软件 。 具体 地 讲 ： 在 软件开发 过程 中 ， 软件 工程师 不再 从 基本 的 代码 写 起 ， 而是 将 具有 某些 特定 功能 的 部件 组合 在 一起 以 构成 一个 复杂 的 系统 。 在 这里 ， 部件 功能 的 获取 不是 通过考察 其 内部 细节 ， 而是 通过观察 部件 接口 的 抽象 描述 获知   [ 1 ]   。 基于 部件 的 设计 是 一个 基于 对象 的 软件 运动 。 它 提出 了 这样 一个 一般性 问题 ： 当 应用 元素 是 由 不同 厂商 使用 不同 语言 、 工具 及 计算 平台 所 构造 的 ， 如何 利用 它们 来 设计 系统 的 ？ 这种 软件开发 方式 的 目标 是 使得 最终用户 和 开发者 能够 像 视听 电子元件 的 生产 、 消费者 那样 享受 到 同样 高层次 的 即插即用 的 应用 互操作性 。 时至今日 ， 利用 已存 部件 构造 软件 已 引起 愈来愈多 的 重视 。 许多 机构 正在 进行 部件 重用 工程 的 研究 ， 大量 的 重用 工具 正在 应用 和 研制 中 [ 2 ]   。 
 　 　 基于 部件 设计 可 被 看作 一个 渐次 积累 的 过程 ： 当 一个 软件 由 一些 子 部件 构造 成功 之后 ， 它 同时 又 可 作为 一个 新 的 部件 放入 部件 库中 被 其它 软件 所 重用   (   如图   1 )   。   
 
 图 1   基于 部件 设计 过程 
 　 　 本文 中 ， 我们 主要 关注 如下 两个 问题 ：   
 　 　 ( 1 )     基于 部件 设计 的 模型 是 什么 ？ 当 利用 子 部件 构造 部件 时 ， 如何 验证 这种 设计 的 正确性 ？   
 　 　 ( 2 )     当 部件 的 实现 不 可知 时 ， 如何 保证 部件 的 正确 执行 ？   
 1     基于 部件 设计 的 模型   
 　 　 一个 部件 的 本质 是 什么 ？ 直觉 上 ， 将 部件 看作 一个 计算 单元 ， 它 具有 其 自身 的 内部 状态 并 提供 一组 操作 来 对 这个 状态 读出 和 写入 。 部件 的 状态 是 不 可见 的 ， 它 只能 通过 调用 部件 中 的 操作 才能 访问 到 。 在 基于 部件 设计 的 模型 中 ， 规定 任何 一个 部件 都 是 由 若干 子 部件 按 一定 的 控制结构 构造 而成 。   
 　 　 由于 基于 部件 的 设计 需要 一种 机制 来 保障 子 部件 之间 可以 相互合作 并 能够 同时 开发 。 为此 ， 通常 的 做法 是 将 每个 部件 的 描述 分成 两个 层次 ：   
 　 　 · 接口 ： 抽象地 描述 每个 部件 的 外部 行为 ， 并 以此 作为 其它 部件 的 使用 依据 。   
 　 　 · 实现 ： 接口 中 描述 的 具体 实现 。   
 1.1     接口   
 　 　 一个 部件 的 抽象 描述 包括 语法 级 和 语义 级 两个 层次 。 语法 级 描述 刻画 了 怎样 调用 一个 部件 的 操作 ； 而 语义 级 描述 则 刻画 了 部件 中 操作 的 行为 特性 。 对于 部件 的 语义 ， 主要 关心 部件 的 初始 特性 以及 一个 操作 的 执行 所 导致 的 部件 特性 的 变化 。 使用 一阶 逻辑   ( first - order   logic )   语言   [ 4 ]   来 描述 部件 的 特性 ：   
 　 　 定义   1         一个 特性   P   指 的 是 对应 于读 操作 的 一个 命题 公式 。 它 或者 是 一个 布尔 真值   T   ， 或者 是 一个 原子 特性   p   ， 或者 是 一个 反 特性 P   ， 或者 是 一个 合取 特性   P1 ∧ P2   ， 或者 是 一个 析取 特性   P1 ∨ P2   ， 或者 是 一个 暗指 特性   P1 =   》 P2   。 即 ：   
 
 　 　 其中 原子 特性 指 的 是 对应 于读 操作 的 一个 关系 表达式 。 例如 ： 假设   X   、   Y   、   R   是 某个 部件 的 读 操作 ， 则 类似 于   X = 1   ，   R < Y   ，   X = R + Y   
 　 　 这样 的 表达式 都 是 原子 特性 。   
 　 　 一个 部件 的 初始 特性 指定 了 它 的 初始状态 要求 。 同时 使用 一个 特性 对来 定义 部件 中 每个 写 操作 的 语义 ， 其 含义 是 ： 如果 相应 写 操作 在 满足 第一个 特性   (   预 条件   )   的 任意 状态 下 执行 ， 则 其 执行 完毕 后 第二个 特性   (   后 条件   )   一定 满足 。   
 　 　 这样 ， 可以 给出 部件 接口 的 模型 ： 一个 部件 的 接口 描述 包括 一个 初始 特性 ， 一组 读写操作 的 名字 及其 语法 描述 ， 另外 对于 每个 写 操作 还 提供 了 一个 特性 对 ， 用于 描述 该 操作 执行 前后 的 行为 约束 。   
 1.2   实现   
 　 　 在 基于 部件 设计 中 ， 将 部件 实现 时 所用 到 的 子 部件 分为 全局 子 部件 和 局部 子 部件 两类 ， 其中 前者 可 被 部件 中 的 每个 操作 所 访问 ， 它 存在 于 部件 的 整个 生命周期 ； 而 后者 则 只能 被 某个 特定 操作 所 访问 ， 它 只 在 相应 操作 执行 时才 创建 ， 并 在 操作 执行 结束 后 即 撤销 。 下面 提出 一个 简单 的 部件 实现 模型 ：   
 　 　 一个 部件 的 实现 包含 以下 两 部分 ：   ( 1 )     其 所有 子 部件 的 名字 和 接口 信息 ；   ( 2 )     根据 子 部件 的 操作 对 读写操作 所 进行 的 定义 。   
 　 　 在 这里   ,     强调 子 部件 的 接口 是 其 在 部件 中 被 重用 的 唯一 依据 ， 即子 部件 的 实现 中 所 描述 的 语法 和 语义 信息 同其 接口 的 抽象 描述 是 一致 的 。 这样 可以 给出 部件 的 实现 模型 ：       部件 中 的 每个 读 操作 的 实现 对应 于 一个 由子 部件 的 读 操作 所 构成 的 程序   ,     而 每个 写 操作 的 实现 对应 于 一个 由子 部件 的 读 或 写 操作 所 构成 的 程序 。   
 　 　 那么 ， 什么 是 一个 程序 ？ 为此 定义 一个 简单 的 程序 模型 ： 一个 程序 或者 是 一个 原子 程序 ； 或者 是 程序   P1 和   P2 的 顺序 执行 ； 或者 是 以 特性 S 为 测试 条件 的 程序 P 的 选择 执行 ； 或者 是 以 特性 S 为 测试 条件 的 程序 P 的 循环 执行 。 其中 原子 程序 则 对应 于 一个 调用 操作 c . op , 其 语义 是 调用 部件 c 中 的 操作 op 。 假设   P 、 P1 、 P2 程序 ， 而 S 是 部件 中 的 一个 特性 ， 则 上述 程序 模型 可 形式化 地 描述 如下 ：   
 P ≡ c . op | P1 ; P2 | if   S   then   P1 | while   S   do   P1 
 1.3     语义 一致性 验证   
 　 　 一个 部件 的 接口 描述 同其 具体 实现 相互 分离 引发 了 一个 潜在 的 问题   :     该 部件 的 实现 是否 正确 地 满足 了 其 接口 中 所 给定 的 抽象 描述   ?     为 解决 这种 正确性 问题   ,     应用   Hoare   逻辑   [ 4 ]   作为 进行 证明 的 基本 手段 。   Hoare   逻辑 是 一种 对 程序 进行 推理 的 理论 。 它 讨论 了 程序正确性 证明 的 问题 并 提出 了 一种 独立 的 公理 方法 来 获得 程序 的 稳定性 。   
 　 　 由 上节 所 刻画 的 部件 实现 模型 可知   ,     部件 中 所有 操作 的 实现 都 是 由其子 部件 中 的 操作 合成 的 ， 故而 部件 的 语义 可 由 这些 子 操作 的 合成 语义 所 代表 。 基于 此   ,     提出 相应 的 验证 策略 ： 首先 根据 子 部件 接口 中 所 给出 的 语义 说明 ， 应用   Hoare   逻辑 所 给出 的 规则 计算 出 部件 的 初始 特性 以及 每个 写 操作 的 预 条件 和 后 条件 ， 然后 对照 给定 的 部件 接口 说明 以及 一组 验证 条件 ， 判断 部件 实现 的 正确性 。   
 　 　 可 使用 下面 的 算法 计算 一个 部件 的 实现 所 代表 的 语义 ：   
 　 　 该 部件 的 初始 特性 等价 于 其 所有 全局 子 部件 的 初始 特性 所 构成 的 合取 特性 ； 由于 子 部件 接口 中 给出 了 每个 写 操作 的 语义 信息 ， 因此 对于 任 一个 原子 程序   c . op   ， 可假定 其 对应 预 条件 和 后 条件 为   ( p , q )   ， 根据 这一 假设 ， 对于 部件 中 每个 写 操作 ， 若 其 对应 的 程序 为   C   ， 则 该 操作 的 预 条件 和 后 条件 可 递归 地 计算 如下 
 ：   
 　 　 根据 上面 的 算法 ， 我们 可 给出 部件 正确性 的 定义 ：   
 　 　 定义   2   对于 任 一个 部件 ， 假设   P1   是 其 接口 中 所 给定 的 初始 特性 ， 且 对于 每个 写 操作   wi   其 对应 的 预 条件 和 后 条件 分别 为   Pi1   和   Qi1   ； 应用 上面 的 算法 计算 该 部件 实现 的 语义 ， 假设 所 计算 出 的 初始 特性 为   P2   ， 且 对于 每个 写 操作   wi   计算 其预 条件 和 后 条件 ， 结果 为   Pi2   和   Qi2   ； 则 仅 当 下列 条件 成立 时 ， 该 部件 在 逻辑 上 一定 是 正确 的 ：   
 　 　 ( 1 )     下列 特性 恒为 真 ： P1 = 》 P2 ,   Pi1 = 》 Pi2 ,   Qi2 = 》 Qi1 ;   
 　 　 ( 2 )     对于 部件 实现 中任 一个 写 操作 wi ， 假设 其 对应 的 程序 为 C ， 则 下列 特性 恒为 真 ： 
 　 
 　 　 显然 ， 定义   2   是 一个 充分条件   ,     即 满足 定义   2   的 部件 一定 是 正确 的 ， 但 反之 并 不 成立 。 定义   2   的 意义 就 在于 它 为 开发 一个 正确 的 部件 提供 了 指南 ， 虽然 依据 这一 定义 开发 部件 受到 一定 约束 ， 但 毕竟 对于 一些 安全性 要求 很 高 的 领域   (   如 航空 、 航天   )   ， 知道 了 什么样 的 部件 实现 一定 是 正确 的 。 在 这里 ， 还 需 强调 一点 ： 总是 假设 子 部件 是 正确 的 。 在 这 一 假设 之上 ， 一个 逻辑 上 正确 的 部件 实现 才 是 真正 正确 的 。 那么 ， 在 只 给 定子 部件 接口 信息 的 情况 下 ， 如何 验证 子 部件 的 正确性 ？   
 2   部件 的 容错 运行   
 　 　 由于 通常 情况 下 ， 部件 重用 时 ， 其 具体 实现 细节 是 不 可见 的 。 因此 ， 无法 使用   Hoare     逻辑 静态 地 验证 部件 的 正确性 。 下面 将 提出 一种 运行 时 技术 使 其 能够 在 未知 部件 实现 的 情况 下 检测 部件 的 运行 同其 接口 说明 是否 一致 。   
 　 　 由于 在 部件 的 接口 中 形式化 地 描述 了 部件 的 语义 信息 ， 因此 基本 策略 是 构造 一个 生成器   ( generator )   ， 其 功能 是 利用 部件 接口 中 的 形式 语义 ， 自动 生成 一个 包裹 部件 ， 该 部件 接收 来自 外部 的 调用 要求 ， 监视 被 测试 部件 的 运行 并 在 出现 运行 时 错误 时 进行 相应 处理 。   
 　 　 一个 包裹 部件 包含 两个 子 部件 ： 被 监测 部件 和 信号灯 部件   ( semaphore )   。 信号灯 部件 用于 在 监测 到 运行 时 错误 时 设置 出错 标志 并 在 操作 执行 完毕 后 设置 结束 标志 ， 它 提供 了   4   个 操作 ：   
 　 　 ( 1 ) fault   ： 读 操作   - -   表明 错误 标志 是否 置位 ；   
 　 　 ( 2 ) setfault   ： 写 操作   - -   对 错误 标志 进行 置位 ；   
 　 　 ( 3 ) over   ： 读 操作   - -   表明 操作 是否 结束 ； 
 　 　 ( 4 ) setover   ： 写 操作   - -   对 结束 标志 进行 置位 。   
 　 　 作为 额外 的 一层 设计 ， 包裹 部件 根据 信号灯 子 部件 中 的   fault   操作 和   over   操作 提供 了 两个 读 操作   w _ fault   和   w _ over   用于 表明 被 监测 部件是否 出错 以及 前 一个 操作 是否 结束 ， 这里 假设 对 每个 部件 操作 的 调用 是 单线程 的 ； 同时 该 包裹 部件 提供 了 一组 与 被 测 部件 相同 的 读 操作 用于 观察 被测 部件 的 状态 特性 ； 至于 包裹 部件 中 的 写 操作 集合 则 同 被 测 部件 的 写 操作 集合 相同 ， 但 其 语义 有所 变化 ： 包裹 部件 接收 到 写 操作 调用 要求 后 ， 首先 测试 对应 操作 的 预 条件 ， 如果 不 满足 则 挂 起 该 调用 ， 否则 执行 相应 的 部件 操作 ； 操作 执行 完毕 后 ， 对 结束 标志 置位 并 测试 该 操作 的 后 条件 ， 如果 不 满足 则 将 信号灯 错误 标志 置位 。 图   2   给出 了 包裹 部件 的 执行 算法 。   
 
 图 2   包裹 部件 执行 算法 
 　 　 包裹 部件 的 技术 提供 了 检测 部件 运行 时 错误 的 手段 ， 那么 当 检测 到 部件 错误 时 如何 在 不 修改 源程序 的 前提 下 动态 地 对 部件 进行 替换 ？ 为此 提出 一个 新 的 部件 行为 模式 ： 虚拟 部件 ， 期望 在 设计 中 系统地 使用 这一 模式 以 保证 部件 的 容错 运行 。   
 　 　 类似 于 实际 部件 的 设计 ， 虚拟 部件 也 提供 了 一个 单一 的 接口 描述 ； 所 不同 的 在于 ， 虚拟 部件 模式 中 ， 部件 实现 不再 是 单一 的 ， 而是 允许 在 设计 中将 满足 该 接口 描述 的 多个 部件 聚集 起来 构成 一个 部件 组 ， 同时 为 该 部件 组 构造 一个 代理 部件 作为 连接 客户端 同 部件 组 的 桥梁 。 当 客户程序 调用 虚拟 部件 的 接口 中 所 给出 的 操作 时 ， 它 不再 直接 同 具体 部件 打交道 ， 而是 向 相应 的 代理 部件 发出 调用 要求 ， 由 代理 在 部件 组中 动态 地 选择 可靠 部件 ， 并 在 发现 部件 运行 时 错误 时 ， 自动 地 对 部件 进行 替换 ， 从而 实现 对 客户端 透明 的 部件 容错 运行 。 图   3   给出 了 虚拟 部件 的 结构 ， 这里 假定 部件 组中 的 每个 部件 都 是 一个 包裹 部件 ， 具有 自 检错 的 能力 。   
 
 图 3   虚拟 部件 结构 
 　 　 在 虚拟 部件 模式 中 ， 其 可靠性 是 通过 代理 部件 动态 地 选择 部件 组中 的 正确 部件 完成 的 。 在 部件 组中 采用 文献   [ 3 ]   所 提出 的   coordinator - cohort   计算 方案 ， 即将 部件 组中 的 一个 成员 部件 设定 为 协调 部件   ( coordinator )   ， 用来 执行 客户端 所 要求 的 操作 ； 并 把 部件 组中 的 其它 的 部件 成员 称为 随从 部件   ( cohort )   ， 这些 部件 是 被动 的 ， 它们 不 执行 客户端 的 调用 操作 。 如果 协调 部件 发生 错误 ， 则 选取 一个 随从 部件 作为 新 的 协调 部件 。 另外 ， 随从 部件 需要 周期性地 根据 协调 部件 的 内部 状态 更新 其 自身 状态 ， 以 用作 备份 目的 。 基于 这一 计算 方案 ， 图   4   中 描述 了 代理 部件 执行 动态 调用 的 算法 。   
 
 图 4   代理 部件 动态 调用 算法 
 　 　 在 虚拟 部件 中 ， 为 实现 部件 之间 的 状态 传送 ， 我们 约定 代理 部件 以及 部件 组中 的 每个 成员 都 必须 包含 两个 操作 ：   get _ state   和   set _ state   ， 这样 ， 在 每次 动态 调用 的 结尾 ， 代理 部件 就 可以 通过   get _ state   从 协调 部件 中 读取 其 内部 状态 ， 然后 调用 每个 随从 部件 的   set _ state   操作 ， 对 其 状态 进行 更新 。   
 　 　 显然 ， 如果 一个 部件 组有   n   个 部件 成员 ， 则 客户端 的 调用 要求 在 至多   n - 1   个 部件 成员 出错 的 情况 下 仍 能 可靠 地 完成 。 对比 单 部件 运行 的 模式 ， 这一 行为 模式 能够 获得 更 高 的 可靠性 。   
 3   结论   
 　 　 本文 给出 了 一个 基于 部件 设计 的 简单 模型 ， 并 在 这 一 模型 的 基础 上 给出 了 进行 正确性 验证 的 策略 。 我们 坚信 这些 内容 对于 提高 基于 部件 设计 的 可靠性 具有 积极 的 指导意义 。     
 作者简介 : 云晓春 , 男 , 28 岁 , 博士生 , 主要 从事 基于 部件 设计 技术 及 并行计算 技术 研究 
 作者 单位 : 哈尔滨工业大学 计算机系   哈尔滨 150001 
 参考文献   
 1 　 Adler   R   M . Emerging   Standards   for   Component   Software . IEEE   Computer ， 1995 ， ( 3 ) ： 68   
 2 　 Zaremsk   A   M , Wing   J   M . Signature   Matching :   A   Key   to   Reuse .   ACM   Transactions   on   Software   Engineering   and   Methodology ， 1995 ， 4 ( 2 ) ： 146   
 3 　 Maffeis   S . Run - time   Support   for   Object - oriented   Distributed     
 Programming . Ph . D   Dissertation   in   University   of   Zurich ， 1995 - 02 ： 137 
 4 　 Gordon   M   J   C . Programming   Language   Theory   and   Its   Implemen - tation . Prentice   Hall ， 1988 ： 13 - 29   
 收稿 日期 : 1998 - 06 - 19 
