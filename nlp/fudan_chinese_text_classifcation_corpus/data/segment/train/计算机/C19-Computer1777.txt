软件 学报 
 JOURNAL   OF   SOFTWARE   
 1999 年   第 10 卷   第 5 期   Vol.10   No.5   1999 
 
 
 
 实时 数据库系统 中 的 嵌套 事务 
 刘云生 　 李 国徽 
 摘要 　 传统 的 原子 事务 是 由 一个 平坦 数据库 操作 序列 组成 的 , 事务 的 执行 具有 ACID ( Atomicity ,   Consistency ,   Isolation ,   Durability ) 特性 . 然而 , 在 实时 应用环境 下 , 这些 却 不 太 适用 . 该文 提出 了 一种 支持 实时 应用 的 嵌套 事务 模型 , 给出 了 嵌套 事务 的 特性 及 正确性 标准 , 着重 对 嵌套 实时 事务 的 优先级 分派 与 并发 控制协议 进行 了 讨论 . 
 关键词 　 事务 模型 , 嵌套 事务 , 优先级 分派 , 并发 控制 , 事务 正确性 ,   实时 数据库 . 
 中图法 分类号 　 TP311 
 Nested   Transactions   in   Real - time   Database   Systems 
 LIU   Yun - sheng 　 LI   Guo - hui 
 College   of   Computer   Science   and   Technology   Huazhong   University   of   Science   and   Technology   Wuhan   430074 
 Abstract   In   the   traditional   transaction   model ,   a   trans   action   is   a   flat   sequence   of   the   database   operations   and   the   executions   of   trans   actions   have   the   ACID ( Atomicity ,   Consistency ,   Isolation ,   Durability )   properties .   But   under   the   real - time   environment ,   these   appear   unsuitable .   A   nested   transac   tion   model   to   support   real - time   applications   is   proposed   and   the   properties   and   the   correctness   stanadards   of   nested   transactions   are   presented   in   this   pap   er .   The   priority   assignment   strategies   and   the   concurrency   control   protocol   for   nested   real - time   transactions   are   discussed   with   emphasis . 
 Key   words   Transaction   model ,   nested   transaction ,   pri   ority   assignment ,   concurrency   control ,   transaction   correctness ,   real - time   d   atabase . 
 　 　 实时 应用 要求 事务 能 自动 监视系统 ( 数据库 ) 的 状态 及其 变迁 , 在 特定 情形 或 时间 点 触发 特定   的 活动 （ 事务 ） . 被 触发 ( triggered ) 的 活动 按照 应用 语义 的 要求 可以 是 触发 ( triggering ) 事   务 的 一个 部件 、 一个 独立 的 事务 或 触发 事务 的 子 事务 . 这 就 要求 我们 提供 嵌套 事务 机制 , 并 给   出 嵌套 事务处理 的 调度 算法 、 并发 控制协议 及 事务 执行 的 正确性 标准 . 
 　 　 一般地说 , 嵌套 事务 的 语义 来源 主要 有 以下 几个 方面 : 
 　 　 （ 1 ）   动态 触发 的 活动 按 应用 要求 成为 触发 事务 的 子 事务 ; 
 　 　 （ 2 ）   在 分布式应用 环境 下 , 一个 事务 可以 划分 成 若干个 代理 事务 , 在 不同 的 节点 上 分工合作   执行 , 这些 代理 事务 就是 原 事务 的 子 事务 ; 
 　 　 （ 3 ）   在 一些 工程 应用 中 , 长寿 （ long - lived ） 事务 或 开端 （ open - ended ） 事务 成为 对系   统 资源 要求 的 瓶颈 . 可以 把 长寿 事务 或 开端 事务 划分 成 若干个 逻辑 上 独立 的 子 事务 , 使 占用 的   资源 能 被 提前 释放 ; 
 　 　 （ 4 ）   应用 语义 在结构上 显式 地 要求 一个 事务 为 另 一 事务 的 子 事务 . 
 1   嵌套 事务 模型 
 1.1   嵌套 事务 
 　 　 在 传统 的 平坦 原子 事务 模型 中 , 一个 事务 就是 一个 平淡 的 操作 序列 , 没有 内部结构 , 具有 ACID (   Atomicity , Consistency , Isolation , Durability ) 特性 . 事务 的 调度 和 并发 控制 满足 可 串行化   的 正确性 标准 . 嵌套 事务 则 不同 . 
 　 　 定义 1 .   显式 地 包含 另 一 事务 的 事务 称为 嵌套 事务 . 被包   含者 称为 子 事务 , 包含 者 称为 其父 事务 , 以 p ( t1 , t2 ) 表示 t1 为 t2 的 父 事务 , 或用 c ( t   2 , t1 ) 表示 t2 是 t1 的 子 事务 . 
 　 　 子 事务 又 可 包含 其 自身 的 子 事务 . 父 事务 按照 同步 和 异步 两种 方式 触发 子 事务 . 在 同步 方式 中   , 子 事务 被 触发 执行 时 , 父 事务 处于 等待 状态 , 直到 子 事务 执行 完成 . 在 异步 方式 中 , 父子 事务   同时 并发 执行 . 
 　 　 定义 2 .   在 事务 的 执行 过程 中 触发 一个 子 事务 的 行为 称为 事务 嵌套 事   件 , 记为 NTE . 
 NTE ∷ = Eid ( 〈 TID 〉 , 〈 SYN 〉 ) , 
 其中 Eid 为 事件 标识符 , TID 为 被 触发 事务 的 标识 , SYN 为 上面 所 讨论 的 触发 方式 . 
 　 　 与 一个 事务 t 相 联系 的 所有 事务 嵌套 事件 组成 的 集合 称为 事务 t 的 事务 嵌套 事件 集 , 记为 NTE   t . 
 　 　 定义 3 .   事务 t1 为 t2 的 祖先 事务 , 记为 p * ( t1 , t2 ) , 当且 仅   当 
 p ( t1 , t2 ) ∨  t ( p ( t1 , t ) ∧ p * ( t , t2 ) ) . 
 此时 , 我们 也 称 t2 为 t1 的 后代 事务 , 记为 c * ( t2 , t1 ) . 
 　 　 定义 4 .   与 一个 事务 相联 的 所有 事件 的 事件 经历 ［ 1 ］ 称为 该   事务 的 经历 , 记为 Ht , 即 
 Ht ∷ = 〈 Et , ＜ t 〉 　 Et  OEt ∪ TEt ∪ CEt ∪ NTEt ∪ EEt , 
 其中 ＜ t 为 时序 关系 , OEt 为 事务 的 对象 事件 集 , TEt 为 事务 事件 集 , EEt 为 外部 事件 集 ,   CEt 为 时间 事件 集 ［ 1 ］ , NTEt 为 事务 的 嵌套 事务 事件 集 . 
 　 　 定义 5 .   设有 数据库 事务 集 T , 一个 事务 t ∈ T 称为 根 事务 , 当且 仅 当 
  　 t ′ ∈ T ( t ′ ≠ t ∧ p ( t ′ , t ) ) . 
 　 　 定义 6 .   设有 数据库 事务 集 T , 一个 事务 t ∈ T 称为 叶子 事务 , 当且 仅   当 
  　 t ′ ∈ T ( t ′ ≠ t ∧ c ( t ′ , t ) ) . 
 　 　 定义 7 .   对于 一个 数据库 事务 集 T , t1 , t2 ∈ T , 当且 仅 当 
 c * ( t1 , t2 ) ∨ p * ( t1 , t2 ) ∨ (  t ∈ T ( p * ( t , t1 ) ∧ p * ( t , t2 ) , 
 则 称 t1 , t2 位于 同一 事务 家族 , 记为 R ( t1 , t2 ) . 
 　 　 定义 8 .   设有 数据库 事务 集 T , t1 , t2 ∈ T , 我们 称 t1 , t2 互为 兄   弟 事务 , 记为 S ( t1 , t2 ) , 当且 仅 当 
 R （ t1 , t2 ） ∧ ! p * ( t1 , t2 ) ∧ ! p * ( t2 , t1 ) . 
 在 嵌套 事务 模型 中 , 不同 事务 间 可以 存在 嵌套 关系 而 形成 树形 结构 . 图 1 给出 了 一 嵌套 事务 t   1 , 其中 r ［ A ］ , w ［ B ］ 分别 表示 读数据 对象 A 和 写 数据 对象 B 操作 . t1 在 执行 一些 读写操作 后   同步 触发 子 事务 t11 , t11 执行 完 之后 又 异步 触发 另 一子 事务 t12 , 而 t   11 又 触发 其 自身 的 子 事务 t111 . 
 
 1.2   嵌套 事务 的 执行 
 　 　 在 传统 的 平坦 原子 事务 中 , 事务 一旦 启动 , 它 或者 顺利 执行 完成 到 提交 而 把 结果 反映 到 数据库   中 , 或者 夭折 而 不 给 数据库 和 外部环境 留下 任何 痕迹 . 在 嵌套 事务 中 , 一个 子 事务 的 夭折 并 不   一定 要求 其父 事务 夭折 , 即父 事务 的 执行 并 不 具有 原子 性 , 在子 事务 夭折 时 , 父 事务 可以 作出   如下 选择 : ( 1 )   重 执行 该子 事务 ; ( 2 )   执行 “ 替代 ” / “ 补偿 ” 事务 ; ( 3 )   不管 该子 事务 的 夭折   ; ( 4 )   父 事务 夭折 . 嵌套 事务 的 提交 、 夭折 具有 与 传统 原子 事务所 不同 的 语义 : 
 　 　 ( 1 )   提交 规则 : 一个 子 事务 的 提交 仅 意味着 其 逻辑 操作 的 完成 , 其 对 数据库 的 更改 直到 包含 该   子 事务 的 根 事务 提交 时 才能 真正 反映 到 物理 数据库 . 
 　 　 ( 2 )   夭折 规则 : 当 一个 （ 子 ） 事务 夭折 时 , 其 所有 的 后代 事务 一定 夭折 . 
 　 　 ( 3 )   可见 性 规则 : 一个 子 事务 能 访问 其 祖先 事务所 持有 的 数据 对象 ; 而 在 它 提交 后 , 它 对 数据   库 的 更改 可 被 其父 事务 访问 , 但 不能 被 兄弟 事务 访问 . 
 　 　 提交 规则 和 夭折 规则 保证 了 后面 讨论 的 子 事务 对父 事务 的 夭折 依赖 关系 , 可见 性 规则 及 后面   讨论 的 并发 控制协议 则 保证 了 数据库 的 一致性 . 
 　 　 在 传统 的 原子 事务 中 , 一个 事务 的 开始 ( BEGINt ) 、 提交 ( COMMITt ) 和 夭折 ( ABO   RTt ) 与 其他 事务 没有 必然 的 依赖 关系 , 在 嵌套 事务 中 , 则 与 其他 事务 具有 相关性 . 设有 父   事务 tp , 子 事务 tc , H 为 它们 的 经历 ［ 1 ］ . 
 　 　   ( 1 )   子 事务 对父 事务 存在 夭折 依赖 关系 tc   AD   tp , 
 tc   AD   tp : ( ABORTtp ∈ H )  ( ABORTtc ∈ H ) . 
 　 　 ( 2 )   子 事务 对父 事务 存在 开始 依赖 关系 tc   BD   tp , 
 tc   BD   tp : ( BEGINtc ∈ H )  ( BEGINtp ＜ tBEGIN   tc ) . 
 ( 3 )   父 事务 对子 事务 存在 提交 - 终止 依赖 关系 tp   CD   tc , 
 tp   CD   tc : ( COMMITtp ∈ H )  ( ABORTtc ＜ tCOMMIT   tp ∨ COMMITtc ＜ tCOMMITtp ) . 
 1.3   嵌套 事务 的 正确性 
 　 　 嵌套 事务 正确性 的 概念 及其 所 涉及 的 方面 较之 传统 的 都 更为 复杂 , 在 文献 ［ 1 , 2 ］ 中 对此 已有   详细 的 讨论 , 它 包括 : 时间 正确性 、 结构 正确性 、 行为 正确性 及 结果 正确性 . 如 在 文献 ［ 1 , 2 ］   中 所 论述 , 时间 正确性 和 结构 正确性 由 调度 和 事务管理 通过 一定 的 策略 与 算法 , 使 事务 的 时间   相关性 和 结构 依赖性 ( 如 上述 ) 得到 满足 来 实现 , 这 相对 容易 些 , 不再 赘述 . 这里 着重 讨论 行为   正确性 及 结果 正确性 , 它 由 下列 “ 嵌套 可 串行化 ” 保证 . 
 　 　 定义 9 .   设 事务 集 T = { t1 , t2 , ... , tn } , Dt 为 t 的 后代 事务 集 ,   称 T ′ = { ti1 , ti2 , ... , tim } （ m ≤ n ） 为 T 的 一个 可能 执行 集 , 记为 T ′ = PES   ( T ) , 当且 仅 当 
 t ∈ T ( t  T ′ ( t ′ ∈ Dt ( t ′ T ′ ) ) ) . 
 把 一个 事务 集 T 执行 后 , 数据库 的 状态 及 返回值 集 分别 记为 DBS ( T ) 和 RV ( T ) , 对于 任一 事务 序列   t1 , t2 , ... , tk , 它 串行 执行 后 的 数据库 状态 及 返回值 集 分别 记为 DBS ( t1 , t2 , ... , t   k ) 和 RV ( t1 , t2 , ... , tk ) . 
 　 　 定义 10 .   设有 事务 集 T = { t1 , t2 , ... , tn } , 它 的 一次 执行 是 嵌套   可 串行化 的 , 当且 仅 当 
  T ′ = { ti1 , ti2 , ... , tim }  T ( T ′ = PES ( T ) ∧ DBS ( ti1 , t   i2 , ... , tim ) = DBS ( T ′ ) ∧ RV ( ti1 , ti2 , ... , tim ) = RV ( T ′ ) ) . 
 　 　 事务 执行 的 嵌套 可 串行化 保证 了 数据库 的 一致性 . 下面 讨论 事务处理 如何 保证 嵌套 可 串行化 .   
 2   嵌套 实时 事务 的 处理 
 　 　 传统 事务处理 往往 没有 所谓 的 调度 , 事务处理 按先来 先 服务 的 顺序 进行 . 人们 所说 的 调度 , 严   格 来讲 应 属于 并发 控制 的 范畴 , 即 解决 事务 对 数据 资源 的 竞争 . 实时 事务 的 处理 主要 包括 优先   级 分派 、 调度 与 并发 控制 , 一旦 优先级 分派 策略 确定 了 , 事务 的 调度 按 优先级 进行 就 比较简单   了 , 故 问题 的 关键 是 优先级 分派 策略 与 并发 控制协议 的 开发 . 
 2.1   子 事务 的 优先级 分派 
 　 　 在 实时 数据库系统 中 , 决定 事务 优先级 的 关键因素 是 其 截止期 . 事务 的 截止期 由 应用 语义 或外   部 环境 的 响应 时间 要求 和 事务 间 的 时间 相关性 来 决定 . 采用 考虑 截止期 的 事务 优先级 分派 策   略后 , 每个 事务 则 按 优先级 竞争 CPU 时间 和 其他 系统资源 . 在 嵌套 事务 中 , 每个 （ 子 ） 事务 就   是 一个 竞争 系统资源 的 单位 , 这样 , 就 存在 一个 如何 根据 根 事务 的 截止期 设置 其 后代 事务 截止   期 , 进而 分派 事务 的 优先级 的 问题 . 
 *   统一 截止期 （ SD ） 
 　 　 该 策略 的 主要 思想 是 基于 截止期 来 分派 事务 的 优先级 . 事务 的 优先级 不因 其 嵌套 结构 而 发生   改变 , 同时 , 让 它 所有 的 后代 事务 具有 与其 自身 一样 的 截止期 . 于是 以该 事务 的 名义 所 进行 的   所有 子 事务 在 其 生命周期 中 的 任何时刻 都 得到 与 事务 本身 相同 的 优先级 . 
 　 　 设 t 为 一 嵌套 事务 , 则 其 所有 的 后代 事务 具有 与 它 相同 的 截止期 及 优先级 . 即 
  t ′ ( p * ( t , t ′ )  ( d ( t ′ ) = d ( t ) ∧ ( pr ( t ′ ) = pr ( t ) ) ) , 
 其中 d ( t ) 表示 事务 t 的 截止期 , pr ( t ) 表示 事务 t 的 优先级 . 
 　 　 *   按 比例 设置 后代 事务 的 截止期 
 　 　 该 方法 的 主要 思想 就是 按父 事务 和子 事务所 要 完成 的 工作量 来 设置 子 事务 的 “ 虚拟 截止期 ”   . 空闲 （ slack ） 时间 ［ 3 ］ 在 各 事务 之间 的 分配 也 是 按 父子 事务 工作量 的 比例 来   分配 . 同时 , 我们 也 考虑 事务 的 类型 （ 软 实时 事务 、 固 实时 事务 、 硬 实时 事务 ） . 我们 按 如下   公式 设置 后代 事务 的 “ 虚拟 截止期 ” : 
 dv ( tc ) = min ( dg ( tc ) , dg ( tp ) - Cadj - A ) . 
 　 　 dg ( t ) 是 前面 讨论 的 根据 用户 的 设置 或 外部环境 的 要求 而 确定 的 事务 t 的 截止期 . A 为 事务 的   提交 延迟 或 分布式 环境 下 的 通信 延迟 , Cadj 是 反映 父子 事务 由于 对 系统资源 要求 冲突 的 调整   时间 : 
 　 　 ( a )   如果 父子 事务 异步 （ 并发 ） 执行 , 且 它们 对 数据 资源 的 访问 没有 冲突 ( 它们 不会 由于   数据 资源 的 冲突 而 互相 阻塞 ) , 如果 子 事务 能 在 父 事务 的 截止期 之前 完成 , 就 不会 导致 父 事务   超过 截止期 , 因此 , 令 Cadj = 0 ; 
 　 　 ( b )   当 ①   父子 事务 异步 （ 并发 ） 执行 而 它们 对 数据 资源 的 访问 存在 冲突 ; 或 ②   父 事务   同步 触发 子 事务 . 此时 , 父 事务 可能 被子 事务 阻塞 或父 事务 必须 等待 子 事务 完成 . 这样 , 为了 让   父 事务 有 足够 的 时间 在 其 截止期 之前 完成 , 子 事务 最 晚 完成 时间 到父 事务 的 截止期 之间 的 时   间 应该 大于 估计 父 事务 还要 用 的 时间 . 根据 父子 事务 的 类型 , Cadj 有 如下 的 设定 : 
 　 　 ( 1 )   父子 事务 均 同时 为 软 事务 或固 事务 , 父子 事务 一起 分享 父 事务 的 空闲 时间 : 
 Cadj = ES ( s ) + sl ( tp ) * ( ES ( s ) ／ ( ES ( s ) + ES ( tc ) ) ) . 
 
 　 　 ES ( s ) 表示 tp 完成 触发 tc 后 的 那 部分 工作 估计 所 需要 的 时间 , ES ( tc ) 为 估计 t   c 所 需要 的 时间 , sl ( tp ) 为 tp 的 空闲 时间 . 
 　 　 ( 2 )   tp 为 软 事务 , tc 为固 事务 , 把 tp 的 全部 空闲 时间 分配 给 tc , Cadj = ES ( s ) . 
 　 　 ( 3 )   tp 为固 事务 , tc 为 软 事务 , tp 的 全部 空闲 时间 留给 自己 , Cadj = ES ( s ) + sl ( tp )   . 
 　 　 在 给 事务 的 各子 事务 分配 了 “ 虚拟 截止期 ” 之后 , 我们 可以 分配 事务 的 优先级 pr ( t ) = F ( dv (   t ) ) , 然后 按 优先级 进行 调度 和 并发 控制 . 
 2.2   并发 控制 
 　 　 按 前面 所述 的 提交 规则 和 可见 性 规则 , 结合 事务 的 实时性 和 嵌套 结构 特点 , 我们 提出 一种 按事   务 优先级 夭折 的 并发 控制协议 , 其 规则 是 : 
 　 　 （ 1 ）   当子 事务 t 请求 一个 已 被 其 祖先 事务 锁住 的 数据 对象 o 时 , 子 事务 无条件 地 继承 其 祖先   事务 的 锁 , 而 此后 至 提交 前 , 其 祖先 事务 不能 再 对 o 进行 与子 事务 的 冲突 存取 . 这是 为了 保证 一   个 嵌套 事务 内部 访问 数据库 的 一致性 . 
 　 　 （ 2 ）   兄弟 事务 或 分属 两个 事务 家族 的 事务 之间 的 冲突 按 传统 协议 处理 . 
 　 　 设有 事务 集 T , 对 数据 对象 o 和 t ∈ T , 令 L ( t , o , R ) , L ( t , o , W ) , L ( t , o ) 分别 表示 t 持有 o 的 读锁 、 写   锁 和 锁 （ 不论 读写 ） , 事务 的 优先级 记为 pr ( t ) . 
 　 　 并发 控制协议 可 形式化 地 描述 如下 : 
 　 　 IF    t ′ ∈ T ( ! L ( t ′ , o ) ) 
 　 　 　 THENt 锁住 数据 对象 o 
 　 　 　 ELSE   IF    t ′ ∈ T ( ! L ( t ′ , o , w ) ) ∨ t 申请 为 对 o 的 读锁 
 　 　 　 　 THEN   t 锁住 o 
 　 　 　 　 ELSE   IFt ′ ∈ T ( ！ L ( t ′ , o ) ∨ R ( t , t ′ ) )   / * 所有 锁住 o 的 事务 均 为 t 的 家族   事务 * / 
 　 　 　 　 THEN   IFt ′ ∈ T ( ！ L ( t ′ , o ) ∨ P * ( t , t ′ ) )   / * 所有 锁住 o 的 事务 均 为 t   的 祖先 事务 * / 
 　 　 　 　 　 THEN   t 继承 对 o 的 锁 , t 的 祖先 事务 在 t 提交 前 不能 访问 o 
 　 　 　 　 ELSE 
 　 　 　 　 ABORT   t 
 　 　 　 ELSE   IFt ′ ∈ T ( L ( t ′ , o ) ∨ ! R ( t ′ , t ) )   / * 不是 所有 锁住 o 的 事务 都 是 t   的 家族 事务 * / 
 　 　 THEN   IF   t 的 优先级 比 所有 锁住 o 的 非 家族 事务 的 优先级 都 高 
 　 　 　 　 THEN   夭折 所有 锁住 o 的 非 家族 事务 
 　 　 　 　 　 IFt ′ ∈ T ( L ( t ′ , o ) ∨ R ( t ′ , t ) ) 
 　 　 　 　 　 　 THEN   IF    t ′ ∈ T ( ! L ( t ′ , o ) ∨ p * ( t , t ′ ) ) 
 　 　 THEN   t 继承 祖先 事务 的 锁 
 　 　 　 　 ELSE   ABORT   t 
 　 　 ELSE   t 锁住 o 
 　 　 ELSE   ABORT   t 
 　 　 定理 1 .   对于 一个 事务 集 T = { t1 , t2 , ... , tn } , 如果 它 执行 并 遵   守 前述 的 结构 依赖 关系 及 并发 控制协议 , 则 事务 是 嵌套 可 串行化 的 . 
 证明 : 因为 有子 事务 对父 事务 的 夭折 依赖 关系 , 并且 子 事务 对 数据库 的 更   改 只有 到 包含 该子 事务 的 根 事务 提交 时 才能 真正 反映 到 物理 数据库 , 这 就 保证 了 一个 事务 集   执行 的 效果 等同于 一个 可能 执行 集 PES ( T ) 的 执行 . 而 并发 控制 规则 ( 1 ) 保证 了 父子 事务 并发 执   行时 数据库 的 一致性 , 并发 控制 规则 ( 2 ) 保证 了 兄弟 事务 及 两 家族 事务 并发 执行 时 数据库 的 一   致性 . 所以 , 事务 集 T 的 执行 效果 等同于 PES ( T ) 中 事务 的 一个 串行 执行 的 效果 , 即 事务 执行 是 嵌   套 可 串行化 的 . 
 3   结束语 
 　 　 传统 的 原子 事务 模型 对于 事务 和 商务 型 的 应用 是 有效 的 ， 而 在 实时 应用环境 下 ， 事务 间 可能 存在 结构 上 的 复杂性 ， 这 就 要求 我们 提供 复杂 事务 模型 以 适应 实时 应用 的 需求 ， 本文 在 这方面 的 工作 主要 有 ： 提出 了 一个 嵌套 事务 的 模型 及其 特性 ； 给出 了 嵌套 实时 事务 的 优先级 分派 策略 ： 针对 事务 嵌套 的 牲 ， 提供 了 一种 嵌套 事务 的 并发 控制协议 。 
 　 　 在 实时 应用环境 下 , 原子 事务 的 优先级 分派 及 事务 的 调度 和 并发 控制 已有 较 多 的 讨论 . 而 在 我   们 的 嵌套 事务 中 , 由于 事务 的 嵌套 结构特征 使得 事务 的 处理 与 传统 原子 事务 相比 有 很大 的 差   别 , 如 , 基于 事务 嵌套 特征 的 恢复 就是 一个 复杂 的 问题 , 这些 都 是 我们 今后 工作 的 研究 重点 . 
 　 
 本文 研究 得到 国家自然科学基金 和 国防 预研 基金 资助 . 
 作者 刘云生 ,   1940 年生 , 教授 , 博士生 导师 , 主要 研究 领域 为 现代 （ 主动 、 实时 、 时序 、 内存 等 ） 数据库 理   论 与 技术 及其 集成 实现 , 数据库 与 信息系统 开发 及 实时 应用 , 软件 方法学 与 支撑 环境 . 
 　 　 李 国徽 , 1973 年生 , 博士生 , 主要 研究 领域 为 主动 、 实时 数据库系统 及 集成 .   
 本文 通讯联系 人 : 刘云生 , 武汉   430074 , 华中理工大学 计算机科学 与 技术 学院 
 作者 单位 ： （ 华中理工大学 计算机科学 与 技术 学院   武汉 　 430074 ） 
 参考文献 
 　 [ 1 ]   刘云生 , 胡国玲 . 实时 数据库系统 的 正确性 . 计算机 应用 与 软件 , 1995 , 12 ( 6 ) : 1 ～ 8   
 ( Liu   Yun - sheng ,   Hu   Guo - ling .   The   correctness   of   real - time   database   sys   tems .   The   Computer   Application   and   Software ,   1995 , 12 ( 6 ) : 1 ～ 8 ) 
 　 [ 2 ] 刘云生 , Ramamritham   K , Stankovic   J . 关于 实时 数据库 事务 . 软件 学报 , 1995 , 6 (   10 ) : 614 ～ 621 
 ( Liu   Yun - sheng ,   Ramamritham   K ,   Stankovic   J .   About   real - time   database   transacti   ons .   Journal   of   Software ,   1995 , 6 ( 10 ) : 614 ～ 621 ) 
 　 [ 3 ]   Abbott   R   K ,   Garcir - Molina   H .   Scheduling   real - time   transactions :   a   performance   evaluation .   ACM   Transactions   on   Database   Systems ,   1992 , 17 ( 3 ) : 513 ～ 560 
 本文 1997 - 10 - 14 收到 原稿 , 1998 - 06 - 22 收到 修改稿 
