软件 学报 
 JOURNAL   OF   SOFTWARE 
 2000 　 Vol.11 　 No.4 　 P.557 - 562 
 
 
 
 
 一种 利用 模块 内聚性 的 对象 抽取 方法 
 周毓明 　 徐宝文 
 　 摘要 　 引入 子程序 - 类型 关系 图来 表示 程序 中 类型 和 子程序 之间 的 关系 , 讨论 了 模块 内聚性 的 几个 度量 准则 ， 并 分析 了 增删 子程序 对 模块 内聚 度 的 影响 . 在 此基础 上 ， 给出 了 基于 模块 内聚性 的 对象 抽取 算法 . 
 　 关键词 　 对象 , 对象 抽取 , 内聚性 , 紧密度 , 重叠 度 . 
 　 中图法 分类号 　 TP311 
 An   Object - Extracting   Approach   Using   Module   Cohesion 
 ZHOU   Yu - ming 　 XU   Bao - wen 
 （ Department   of   Computer   Science   and   Engineering 　 Southeast   University 　 Nanjing   210096 ） 
 Abstract 　 　 In   this   paper ,   an   St   ( subprogram - type )   graph   is   introduced   to   represent   the   relation   between   subprograms   and   types   in   programs .   Several   module   cohesion   metrics   are   discussed ,   and   the   effects   of   adding   a   subprogram   to   or   deleting   a   subprogram   from   a   module   are   analyzed   based   on   module   cohesion .   An   object - extracting   algorithm   is   proposed . 
 Key   words 　 Object ,   object - extracting ,   cohesion ,   tightness ,   overlap . 
 　 　 用 面向对象 技术开发 的 的 软件 , 程序 理解 容易 , 后期 维护 方便 . 但 现存 的 许多 软件 的 开发 语言 或 是非 面向对象 语言 , 或 尽管 是 面向对象 的 语言 但 开发 时 没有 使用 面向对象 的 技术 , 再 加上 有些 软件 没有 良好 的 编程 结构 , 导致 软件 后期 维护 十分困难 . 因此 , 如果 能 在 这样 的 系统 中 抽取 出 子程序 与 数据 之间 的 关系 , 尽可能 地 还原 出 系统 设计 人员 头脑 中 的 “ 对象 ” , 并 将 其 转换成 用 面向对象 技术开发 的 系统 , 则 可 提高 系统 的 可靠性 、 可维护性 和 可 重用 性 . 
 这项 工作 的 关键 是 通过 对 程序 行为 的 详细分析 , 抽取 出 相关 的 数据 和 子程序 , 组合成 有 实际意义 的 对象 . 尽管 在 这方面 已有 不少 工作 ［ 1 ～ 4 ］ , 如 Liu 和 Widle 提出 的 基于 全局变量 和 基于 类型 的 方法 ［ 1 ］ 、 Panose 等 人 提出 的 基于 接收器 的 方法 ［ 3 ］ , 但 这些 方法 只是 将 数据 和 子程序 按类型 或 全局变量 简单 的 分类 , 没有 考虑 模块 的 性质 , 抽取 出 的 对象 有 可能 与 实际 中 的 对象 不符 . Canfora 在 Liu 和 Widle 的 方法 的 基础 上 提出 了 用子 图 的 内部 联结 度 的 方法 ［ 2 ］ , 但 该 方法 实际上 还是 利用 全局变量 来 分类 的 , 忽略 了 简单 类型 与 复杂 类型 在 对象 抽取 过程 中 的 作用 不同 这个 事实 . 为 克服 这些 不足 , 本文 提出 一种 基于 模块 内聚性 的 对象 抽取 方法 . 
 1 　 子程序 - 类型 关系 图 
 　 　 正如 人们 所 熟知 的 , 子程序 包括 过程 和 函数 , 过程 常 带有 形参 声明 , 函数 有形 参 声明 和 返回值 类型 声明 , 有时 , 子程序 体内 还 涉及 到 全局变量 的 处理 , 因此 子程序 与 形参 类型 、 返回值 类型 和 全局变量 的 类型 紧密 相关 , 子程序 之间 因 这些 类型 而 关联 . 在 对象 识别 过程 中 , 各 类型 的 作用 是 不 一样 的 , 复杂 类型 比 简单 类型 的 作用 大 . 为 刻画 类型 的 复杂程度 , 下面 先 引入 类型 复杂度 的 概念 . 如果 类型 t1 被 用来 定义 类型 t2 , 则 称 t1 是 t2 的 一个 成分 类型 . 类型 t 的 复杂程度 Ct , l 与 它 的 所有 成分 类型 的 复杂程度 和 成分 类型 相对 于 t 的 嵌套 层次 数 l 有关 ( t 相对 于 本身 的 层次 数是 0 ) , 其 定义 如下 ： 
 
 其中 v 为 基本 类型 的 复杂度 , t ′ 为 指针 所 指向 的 类型 , Complex 为 指针 类型 的 复杂程度 . f 表示 类型 t 的 复杂程度 是 其 所有 成分 类型 t1 , t2 , ... , tn 的 复杂度 Ct1 , l ＋ 1 , Ct2 , l + 1 , ... , Ctn , l + 1 的 函数 , 它 可 随 具体 的 语言 而定 . 例如 , 在 Ada 中 , 当 t 为 记录 类型 时 , f 可取 ∑ Cti , l + 1 ( ti 为 记录 的 成分 类型 ) ; 当   t 为 数组 类型 时 , f 可取 dim * 2 * Ct ′ , l + 1 ( 因为 数组 类型 t 的 复杂性 与 它 的 维数 d 密切相关 , 但 与 数组 元素 具体 数目 没有 太 大 关系 . t ′ 为 数组 元素 类型 , 这里 乘 2 的 原因 是 一维 数组 的 复杂度 显然 比 只有 一个 成分 的 记录 复杂 , 经 考虑 乘 2 较 合适 ) . 在 此基础 上 有 如下 定义 ： 
 　 　 定义 ( 子程序 - 类型 关系 图 ) .   令 Ssubp 表示 系统 中 的 子程序 集 , Ssubp 表示 系统 中 的 类型 集 . 如果 图 G = ( N , E ) 中 N = Ssubp ∪ Stype , E = ｛ ( p , t ) ｜ p ∈ Ssubp ∧ t ∈ Ssubp ∧ t 为 p 中 涉及 到 的 类型 ｝ , 任 一条 边 ( p , t ) 上 的 权值 为 Ct , 0 , 则 称图 G 为 子程序 - 类型 关系 图 . 
 　 　   对图 G 中 的 任一 子程序 结点 p , 记其 涉及 的 类型 集为 Sp - t ( p ) , 即 Sp - t ( p ) = ｛ t ｜ t ∈ Stype ∧ ( p , t ) ∈ E ｝ ; 记 与 任一 类型 结点 t 有关 的 子程序 集为 St - p ( t ) , 即 St - p ( t ) = ｛ p ｜ p ∈ Ssubp ∧ ( p , t ) ∈ E ｝ . 
 　 　 这样 , 系统 中 子程序 与 类型 之间 的 关系 就 体现 在 子程序 - 类型 关系 图上 , 最 简单 的 对象 识别方法 就是 在 子程序 - 类型图 上 找出 一个个 独立 的 子 图 , 每个 独立 的 子 图 就 构成 一个 对象 . 如果 按 这种 方法 抽取 对象 , 有 可能 识别 出 的 对象 没有 实际意义 . 这 主要 有 两种 情况 . 一种 是 将 逻辑 上 属于 不同 对象 的 子程序 封装 在 同一个 对象 中 . 如 , 栈 对象 有 Push - Stack   ( S :   in   out   STACK - TYPE ; Elem :   in   ELEM - TYPE ) 子程序 , 队列 对象 有 Enter - Queue   ( Q :   in   out   QUEUE - TYPE ;   Elem :   in   ELEM - TYPE ) 子程序 , 在 子程序 - 类型 关系 图上 , 这 两个 子程序 因 涉及 到 共同 的 类型 ELEM - TYPE 而 相连 , 按 上面 的 方法 它们 就 封装 在 同一个 对象 中 . 另 一种 是 将 逻辑 上 属于 不同 对象 的 属性 封装 在 同一个 对象 中 . 如 ， 子程序 Init   ( S :   in   out   STACK - TYPE ;   Q :   in   out   QUEUE - TYPE ) 完成 栈 对象 和 队列 对象 的 初始化 , 栈 和 队列 在 子程序 - 类型 关系 图上 因子 程序 Init 而 在 同一个 子图 中 , 按 上面 的 方法 就 将 栈 和 队列 封装 在 同一个 对象 中 . 在 这些 情况 下 抽取 出 的 对象 显然 没有 实际意义 . 如果 利用 模块 的 内聚性 来 抽取 对象 , 则 可以 避免 上述 无 实际意义 的 对象 的 出现 . 为此 , 下面 对 模块 的 内聚性 加以分析 . 
 2 　 模块 内聚性 分析 
 　 　 模块 由 类型 集 以及 操纵 这些 类型 的 子程序 集 组成 , 模块 内 子程序 之间 因 涉及 到 对 相同 的 类型 处理 而 存在 关联 关系 . 模块 的 内聚性 可用 模块 内部 元素 之间 结合 的 紧密 程度 来 刻画 , 从 系统 中 抽取 出 的 模块 应 符合 软件工程 高 内聚 、 低 耦合 的 原则 , 即 抽取 出 的 模块 应 具有 较 高 的 独立性 , 联系 密切 的 元素 不 应 分布 在 多个 模块 中 , 而应 划分 到 同一个 模块 中 . 
 对 子程序 - 类型 关系 图 G = ( N , E ) , 令 MTint ( G ) 表示 图 G 中 所有 子程序 共同 涉及 到 的 类型 , 即 
 MTint ( G ) = ∩ p ∈ SsubpSp - t ( p ) . 
 MTint ( G ) 描述 了 模块 内 所有 子程序 之间 涉及 到 的 共同 类型 集 . 在下文 中 , 为 方便 起 见 , 用 ｜ S ｜ 表示 任何 种类 的 集合 S 中 的 元素 个数 . 为了 描述 表示 模块 的 内聚 度 , 下面 引入 模块 紧密度 、 重叠 度 和 内联 度 的 概念 . 
 　 　 模块 G 的 紧密度 Tightness ( G ) 用 模块 内 所有 子程序 共同 涉及 的 类型 MTint ( G ) 的 相对 复杂性 之 和 与 模块 涉及 的 所有 类型 Stype 的 相对 复杂性 之 和 的 比值 来 表示 . 模块 G 有 一个 高 紧密度 意味着 模块 G 内 各 子程序 涉及 的 共同 类型 比较 多 或 涉及 到 的 类型 的 复杂度 比较 高 , 即 这些 子程序 紧密 相关 , 这 表明 模块 的 内聚 程度较高 . 亦 即 
 
 显然 , 当 MTint ( G ) = Stype ( 即 模块 内 所有 子程序 涉及 的 类型 都 相同 ) 时 , 模块 的 结合 度 达到 最大值 1 . 
 　 　 模块 G 的 重叠 度 Overlap ( G ) 表示 在 平均 一个 子程序 涉及 的 类型 中 ， MTint ( G ) 所 占 的 复杂性 比值 , 即 在 一个 子程序 中 对 公共 部分 处理 的 平均 程度 . 重叠 度高 表明 子程序 与 模块 的 大多数 类型 有关 , 从 某 方面 反映 了 子程序 间 的 高度 关联 关系 , 这 也 是 模块 具有 高 内聚 的 表现 . 由此 ， 
 
 Canfora 在 他 的 对象 抽取 方法 中 , 为 变量 引用 图中 的 子程序 提出 了 子程序 内部 联结 度 的 概念 , 然后 根据 各 子程序 的 内部 联结 度 对 变量 引用 图作 相应 的 合并 、 切片 和 删除 , 最后 得到 许多 独立 的 子 图 , 每个 独立 子图 都 视为 一个 候选 对象 . 但 他 的 对象 抽取 方法 仅 与 子程序 处理 的 变量 个数 有关 , 而 与 变量 的 复杂程度 无关 , 这 显然 会 带来 一些 问题 . 由于 我们 使用 的 是 子程序 - 类型 关系 图 , 且 考虑 到 子程序 之间 的 关联 程度 不仅 与 它们 处理 的 类型 个数 有关 , 而且 与 类型 的 复杂程度 密切相关 , 因此 ， 必须 对 Canfora 的 子程序 的 内部 联结 度 重新 定义 . 
 　 　 我们 将子 图 的 内部 联结 度 定义 为 两个 顶点 都 在 子 图内 的 所有 边上 的 权值 之 和 与 至少 有 一个 顶点 在子 图内 的 所有 边上 的 权值 之 和 的 比值 . 这里 , 边上 的 权值 用 该 边 一端 的 类型 顶点 的 复杂度 计算 . 子程序 p 的 内部 联结 度 是 指 由 涉及 的 类型 是 Sp - t ( p ) 子集 的 子程序 集 与 类型 集 Sp - t ( p ) 组成 的 子 图 的 内部 联结 度 . 因此 , 我们 得到 子图 内部 联结 度 IC ( p ) 的 形式 定义 如下 : 
 
 其中 P ( p ) = ｛ pi ｜ Sp - t ( ppi ) Sp - t ( p ) ｝ . 
 　 　 模块 的 紧密度 、 重叠 度 和 子程序 内联 度 是 模块 内聚性 的 反映 , 它们 的 值 越 大 , 表明 模块 的 内聚 度越 高 . 有 了 这些 度量 手段 , 用下 一节 的 算法 就 可以 在 子程序 - 类型 关系 图中 找出 这样 的 一些 子图 : 它们 是 由 类型 结点 和 子程序 结点 组成 的 子 图 , 具有 较 高 的 内聚性 , 并且 在 一定 程度 上 可以 避免 将 逻辑 上 属于 不同 对象 的 子程序 封装 在 同一个 对象 内 ， 或 将 逻辑 上 属于 不同 对象 的 属性 封装 在 同一个 对象 中 . 
 3 　 对象 抽取 方法 
 3.1 　 增加 和 删除 子程序 对 模块 内聚 度 的 影响 
 　 　 由于 在 子程序 - 类型 关系 图上 , 抽取 过程 中子 图 需要 进行 合并 和 分裂 , 这时 需 判断 向 模块 增删 子程序 对 模块 内聚 度 的 影响 . 为此 , 下面 我们 先 定性分析 向 模块 增加 和 删除 子程序 给 内聚 度 造成 的 影响 . 设 添加 或 删除 的 子程序 名为 p ′ , 其 涉及 的 类型 为 Sp - t ( p ′ ) , 改变 后 的 模块 记为 G ′ . 
 3.1 . 1   向 模块 内 增添 一个 子程序 对 模块 内聚 度 的 影响 
 当向 模块 G 内 添加 一个 子程序 p ′ 时 , 由 模块 紧密度 、 重叠 度及 MTint 的 定义 可 直接 推 得 以下 两个 引理 . 
 　 　 引理 1 .   
 
 引理 2 .   
 
 　 　 引理 1 表明 , 在 模块 所 共同 涉及 的 类型 的 复杂度 增值 与 新增 子程序 涉及 的 类型 复杂度 之 和 的 比 大于 等于 原 模块 的 紧密度 时 , 新 模块 的 紧密度 才 不会 变小 . 引理 2 表明 ， 模块 重叠 度 的 变化 取决于 新增 子程序 涉及 的 新 模块 中 的 公共 类型 的 复杂度 之 和 与其 涉及 的 所有 类型 复杂度 之 和 的 比值 与 原 模块 重叠 度 之间 的 关系 . 而 由 模块 内联 度 定义 , 显然 ， 当 Sp - t ( p ′ ) ∩ Sp - t ( p ) = Φ 时 , 内联 度 不变 ； 当 Sp - t ( p ′ ) Sp - t ( p ) 时 , 内联 度变 大 ； 在 其他 情况 下 , 内联 度 变小 . 
 　 　 由 上面 的 分析 易知 ， 当 新添 子程序 涉及 的 类型 包含 了 原 模块 涉及 的 公共 类型 时 , 如果 新增 子程序 涉及 的 公共 类型 的 相对 复杂性 与其 涉及 的 总 类型 复杂性 之 比 大于 原 模块 的 紧密度 或 重叠 度 , 则 模块 的 内聚 度会 保持 不变 或 增大 . 即 有 如下 推论 . 
 　 　 推论 1 .   当 MTint ( G ) Sp - t ( p ′ ) 时 , 
 　 　 ①   若 
 　 　 ②   若 ≥ Tightness ( G ) . 
 特别 地 , 当 MTint ( G ) = Sp - t ( p ′ ) 时 , Overlap ( G ′ ) ≥ Overlap ( G ) , Tightness ( G ′ ) ≥ Tightness ( G ) .   
 3.1 . 2   从 模块 内 删除 一个 子程序 对 模块 内聚 度 的 影响 
 　 　 删除 子程序 与 增添 子程序 的 过程 正好 相反 , 当 从 模块 内 删除 一个 子程序 p ′ 时 , 由 模块 紧密度 、 重叠 度及 MTint 的 定义 可 直接 推 得 以下 两个 引理 . 
 　 　 引理 3 .   
 
 　 　 引理 4 .   
 
 　 　 子程序 P 内联 度 的 变化 则 决于 被删 子 各序 P ' 涉及 的 类型 与 P 涉及 的 类型 之间 的 关系 . 当 Sp - t ( p ' ) ∩ Sp - t ( p ) Φ 时 , 内联 度 不变 ; 当 Sp - t ( p ' ) Sp - t ( p ) , 内联 度 变小 , 在 其他 情况 下 , 内联 度会 变大 . 
 　 　 由 引理 3 可知 , 模块 紧密度 的 变化 取决于 被删 子程序 造成 的 模块 所 共同 涉及 的 类型 复杂度 的 养活 量 和 它 所 涉及 类型 的 复杂度 的 比值 下原 模块 紧密度 之间 的 关系 . 引理 4 则 说明 , 模块 的 重叠 度 可能 增大 也 可能 减小 , 它 取决于 被删 子程序 涉及 的 新 模块 中 的 公共 类型 的 复杂度 之 和 下 其 涉及 的 氖 类型 复杂度 之 和 的 比值 下原 模块 重叠 度 之间 的 函数 关系 . 易知 , 当 删除 子程序 p ' 后 , 模块 涉及 的 公共 类型 没 改变 时 , 如果 被删 子程序 p ' 涉及 的 原 模块 公共 类型 的 相对 复杂性 与 涉及 的 总 类型 复杂性 之 比 小于 原 模块 的 紧密度 或 重叠 度时 , 则 模块 的 内聚 度会 保持 不变 或 增大 . 即 有 如下 推论 . 
 推论 2 .   当 MTint ( G ) = MTint ( G ′ ) 时 , 
 　 　 ①   若 
 　 　 ②   若 
 　 　 上面 讨论 了 怎样 提高 一个 候选 模块 的 内聚 度 的 充分条件 , 定性 地 分析 模块 的 内聚 度 和 模块 的 改变 对内 聚度 的 影响 , 从而 为 候选 模块 的 抽取 提供 了 合并 与 分裂 的 原则 . 下面 , 我们 在 此基础 上 讨论 对象 抽取 算法 . 
 3.2 　 对象 抽取 算法 
 　 　 子图 之间 存在 一致性 连接 ( coincidental   connection ) 和 假 连接 ( spurious   connection ) 两种 联系方式 ［ 2 ］ . 一致性 连接 指 的 是 一个 子程序 因 实现 多个 功能 而 存取 多个 数据结构 , 每个 功能 逻辑 地 属于 一个 对象 . 这时 ， 可 将 子程序 分割 成 多个 子程序 , 每个 子程序 实现 一种 功能 , 逻辑 地 属于 一个 对象 . 如 ， 子程序 Init 完成 栈 和 队列 的 初始化 , 这时 可 将 Init 分割 成 两个 不同 的 子程序 , 分别 实现 对栈 和 队列 的 初始化 . 而 假 连接 是 子程序 实现 特定 的 功能 而 存取 不同 的 数据结构 . 如 , 子程序 Copy 将 栈 中 的 元素 复制到 队列 中 , 这时 将 其 分割 没有 意义 , 所以 在 处理 中将 该 子程序 移去 . 对 子程序 的 程序 流图 进行 分析 , 就 可 判断 出该 子程序 是 一致性 连接 还是 假 连接 . 
 　 　 在 子程序 - 类型图 上 , 每个 类型 可 得出 对应 的 一个 子图 , 计算 这些 子图 的 内聚 度 . 由于 抽取 出 的 模块 要 具有 较 高 的 内聚 度 , 所以 只 考虑 那些 内聚 度 大于 阈值 的 子 图 . 如果 这些 子图 的 子程序 结点 集 的 交集 不为 空 , 则 应 根据 增加 或 删除 子程序 对 这些 子图 内聚 度 的 影响 程度 来 判定 该 子程序 划归 哪 一个 子图 . 如果 子图 的 类型 结点 集 的 交集 不为 空 , 则 应 判定 是否 应 将 这些 子图 合并 . 对象 抽取 算法 如下 : 
 　 　 ( 1 )   在 子程序 - 类型 关系 图中 , 对 每个 类型 t , 记由 子程序 集 St - p ( t ) 和 类型 集 ∪ p ∈ St - p ( t ) Sp - t ( p ) 组成 的 子 图为 Mt , 计算 Tightness ( Mt ) 或 Overlap ( Mt ) ( 由 上面 内聚 度 的 分析 可知 , 其值 越大 , 表示 该子 图 的 内聚 度越 高 ) , 若 Mt 的 紧密度 或 重叠 度 大于 一 给定 阈值 Step , 则 将 Mt 加入 OverStep 列表 . 
 　 　 ( 2 )   对 任意 的 子 图 Mt1 , Mt2 ∈ OverStep , 当两子 图 的 类型 结点 的 交 集中 包含 类型 t1 , t2 时 , 分 如下 几种 情况 处理 : 
 　 　 ①   如果 Mt1 , Mt2 合并 为 一个 新 的 子 图 Mt 后 , 子图 的 内聚 度 大于 阈值 Step , 则 表明 这 两个 类型 是 同一个 对象 中 两个 联系 密切 的 重要 属性 , 因此 将 合并 后 的 子 图 Mt 加入 OverStep 列表 . 重新 生成 子程序 - 类型 关系 图 , 在 这个 新 的 类型 关系 图上 , 类型 结点 t1 , t2 合并 为 一个 新 类型 结点 t , 在 原图 上 , 所有 从 子程序 结点 指向 类型 t1 , t2 的 弧 在 新图 上 都 指向 类型 结点 t . 
 ②   如果 Mt1 , Mt2 合并 为 一个 新 的 子 图 Mt 后 , 子图 的 内聚 度 小于 阈值 Step . 这时 , 如果 是 某个 子程序 同时 存取 t1 , t2 而 造成 两子 图 Mt1 , Mt2 之间 的 假 连接 , 则 将 这个 子程序 从 Mt1 和 Mt2 中 同时 去掉 ； 如果 是 某个 子程序 造成 的 一致性 连接 , 则 将 其 分割 成 几个 逻辑 功能 独立 的 子程序 . 
 　 　 ( 3 )   重复 ( 2 ) , 直到 对 任意 Mt1 , Mt2 ∈ OverStep , 这 两个 子图 的 类型 结点 的 交 集中 不 同时 包含 类型 t1 , t2 为止 . 
 　 　 ( 4 )   对 任意 两个 子图 Mt1 , Mt2 ∈ OverStep , 设 它们 子程序 结点 的 交集 为 Set . 我们 认为 每个 子程序 在 逻辑 上 只 属于 一个 对象 , 因此 ， Set 中 的 子程序 应 划分 给 不同 的 子 图 . 记 Mt1 , Mt2 中 去掉 Set 中 子程序 结点 及 相关联 的 边 后 的 子 图 分别 为 M ′ t1 , M ′ t2 . 对 Set 中 的 任意子 程序 p , 如果 p 划归 M ′ t1 或 M ′ t2 都 导致 其内 聚度 小于 Step , 则 抛弃 p . 否则 ， 如果 有 下面 3 种 情况 之一 出现 : 
 　 　 ①   p 划归 M ′ t1 后 其内 聚度 增加 而 划入 M ′ t2 后 其内 聚度 减小 ; 
 　 　 ②   p 划入 M ′ t1 后 内聚 度 增加 的 程度 大于 划入 M ′ t2 后 内聚 度 增加 的 程度 ; 
 　 　 ③   p 划入 M ′ t1 后 内聚 度 减小 的 程度 大于 划入 M ′ t2 后 内聚 度 减小 的 程度 ， 
 则 p 应 划归 M ′ 1 . 将 改变 后 的 子 图 加入 OverStep 列表 . 
 　 　 ( 5 )   重复 ( 4 ) ， 直到 对 任意 Mt1 , Mt2 ∈ OverStep , 这 两个 子图 的 子程序 结点 的 交集 为空 为止 . 
 　 　 ( 6 )   将 OverStep 列表 中 的 每个 子图 的 类型 结点 作为 属性 , 子程序 结点 作为 方法 封装 成 一个 类 . 
 　 　 算法 中 的 阈值 Step 可 通过 对 大量 模块 的 内聚 度 统计分析 后 得到 , 也 可 作为 一个 参量 来 调节 , 以 观察 和 分析 不同 内聚 度 层次 对 由 系统 中 抽取 出 的 对象 的 影响 . 
 3.3 　 对象 间 继承 关系 的 抽取 
 　 　 为 便于 抽取 对象 间 的 继承性 , 下面 ， 我们 非 形式 地 引入 一些 基本概念 . 一个 对象 的 类型 用 ［ li : Bi ∈ 1 .. ni ］ 表示 , 其中 li 是 对象 的 方法 名 或 属性 名 , Bi 是 li 的 类型 . 若用 A ＜ : B 表示 类型 A 是 类型 B 的 子 类型 , 则 蕴含 是 ： 如果 A ＜ : B 且 a : A , 则 a : B . 蕴含 的 含义 是 一个 类型 的 子 类型 的 实例 也 是 该 类型 的 实例 . 如果 两个 对象 所 对应 的 对象 类型 之间 存在 子 类型 关系 , 则 这 两个 对象 之间 存在 蕴含 关系 , 即 一个 对象 继承 了 另 一个 对象 的 属性 和 方法 . 对象 继承性 的 抽取 过程 就是 找出 相应 对象 类型 的 子 类型 关系 的 过程 . 对象 类型 的 子 类型 关系 的 不同 定义 对应 于 对象 间 继承 关系 的 不同 层次 . 下面 引入 一个 较强 的 对象 类型 子 类型 的 定义 : 如果 子 类型 关系 Bi ＜ : B ′ i ,  i ∈ 1 .. n 成立 , 则 有 ［ li : Bi ∈ 1 .. n + mi ］ ＜ : ［ li : B ′ i ∈ 1 .. ni ］ . 
 　 　 抽取 对象 间 的 继承性 分为 下面 几步 ： 首先 用 上 一节 的 算法 在 程序 中 抽取 出 对象 , 且 形式化 地 表示 出 对象 的 类型 ; 然后 通过 对象 类型 的 演算 找出 对象 类型 间 的 子 类型 关系 , 抽取 出 对象 间 的 继承 关系 ; 最后 将 对象 类型 及其 继承 关系 转换 为 相应 对象 间 的 继承 关系 , 因子 对象 继承 父 对象 的 属性 和 方法 , 所以 转换 过程 中子 对象 的 属性 和 方法 可能 要 进行 适当 的 增删 . 
 4 　 结束语 
 　 　 从 代码 中 抽取 出 抽象层次 的 对象 , 毕竟 是从 原程序 出发 , 与 设计 人员 头脑 中 的 “ 对象 ” 有 一定 的 差距 , 况且 程序 本来 就 未必 真正 实施 了 设计 人员 真正 需要 的 对象 . 但 通过 逆向 工程 的 方法 抽取 出 程序 中 的 “ 拟 对象 ” , 不仅 有助于 理解 原 系统 的 设计 思想 , 而且 能 提高 软件 的 可维护性 和 代码 的 可 重用 性 . Liu 和 Widle 的 基于 全局变量 和 基于 类型 的 方法 以及 基于 接收器 的 方法 没有 考虑 模块 的 性质 , 只是 将 数据 和 子程序 按类型 或 全局变量 简单 地 加以 分类 , 有 可能 将 本来 属于 同一个 对象 的 方法 或 属性 分散 到 多个 模块 中 , 从而 造成 所 取出 的 对象 有 可能 与 实际 中 的 对象 不符 Canfora 的 方法 在 某些 情况 下 得出 的 结果 可能 不 理想 . 本文 从 模块 的 内聚性 出发 , 将 关联 程度 高 的 子程序 、 类型 组合成 对象 , 从而 抽取 出 的 对象 内部 具有 较 高 的 内聚 度 . 我们 已 结合 “ Ada 逆向 工程 与 软件维护 支撑 技术 研究 ” 课题 开发 出 一个 原型 系统 . 它 基本 的 功能 是 , 从用 Ada83 开发 的 软件 中 识别 并 抽取 出 各种 对象 , 并 将 其 转换 为 Ada95 程序 , 其中 最 重要 的 部分 就是 服务性 任务 到 保护 对象 的 转换 ［ 5 ］ . 在 将来 的 工作 中 ， 我们 期望 在 对象 抽取 的 实现 中 能 加进 语义 知识 的 处理 . 
 周毓明 （ 东南大学 计算机科学 与 工程系 　 南京 　 210096 ） 　 
 徐宝文 （ 东南大学 计算机科学 与 工程系 　 南京 　 210096 ） 
 参考文献 
 1 ， Liu   S   S ,   Wilde   N .   Identifying   objects   in   a   conventional   procedural   language :   an   example   of   data   design   recovery .   In :   Proceedings   of   the   IEEE   Conference   on   Software   Maintenance .   San   Diego ,   CA :   IEEE   Computer   Society   Press ,   1990 .   266 ～ 271 
 2 ， Canfora   G ,   Cimitile   A ,   Munro   M   et   al .   A   reverse   engineering   method   for   identifying   reusable   abstract   data   types .   In :   Proceedings   of   the   1st   IEEE   Working   Conference   on   Reverse   Engineering .   Baltimore ,   MD :   IEEE   Computer   Society   Press ,   1993 .   73 ～ 82 
 3 ， Livadas   Panose ,   Johnson   Theodore .   A   new   approach   to   finding   objects   in   programs .   Journal   of   Software   Maintenance :   Research   and   Practice ,   1994 , 6 : 249 ～ 260 
 4 ， Pedrycz   Witold ,   Waletky   James .   Fuzzy   clustering   in   software   reusability .   Software - Practice   and   Experience ,   1997 , 27 ( 3 ) : 245 ～ 270 
 5 ， Li   Bang - qing ,   Xu   Bao - wen ,   Yu   Hui - ming .   Transforming   Ada   severing   tasks   into   protected   objects .   In :   Proceedings   of   the   ACM   SIGAda   Annual   International   Conference .   Washington ,   DC :   ACM   Press ,   1998 .   240 ～ 245 
 
  
