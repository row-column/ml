计算机 应用 研究 
 APPLICATION   RESEARCH   OF   COMPUTERS 
 2000 　 Vol.17 　 No.5 　 P.54 - 57 
 
 
 
 COM + 及其 基于 属性 编程 
 潘登 　 侯文永 
 摘     要     讨论 了 作为 Windows   DNA 架构 的 核心 部分 的 COM + 在 原有 DCOM 和 MTS 的 基础 上 提供 的 多种 服务 以及 COM + 的 基于 属性 编程 。 
 关键词     COM +     基于 属性 编程     DCOM     MTS 
 1     概述 
 　 　 Windows   DNA   ( Distributed   InterNet   Application   Architecture ) 是 微软 从 基于 工作站 的 应用 程序开发 向 企业级 应用 程序开发 转移 的 核心 架构 。 它 作为 一个 完全 集成 的 n - 层 开发 模型 ， 为 开发人员 在 Windows 平台 上 开发 扩展性 好 的 企业级 应用程序 提供 服务 。 图 1 展示 了 Windows   DNA 的 长期 目标 ： 客户端 的 图形用户界面 Forms + ， 中间层 的 COM + ， 以及 数据 层 的 Storage + 。 现在 的 程序员 在 开发 用户界面 时 常常 为 选择 什么样 的 开发 平台 而 左右为难 ， Forms + 则 是 对 这个 问题 的 回答 ， 它 将 Win32   GUI 和 Web   API 结合 了 起来 。 Storage + 是 Windows 未来 的 文件系统 ， 看起来 有点像 OLE   DB 。 这 两者 的 详细情况 微软 尚未 公布 ， 而 COM + 作为 Windows   DNA 的 核心 将 随着 Windows   2000 一同 发布 。 在 这里 将 首先 讨论 什么 是 COM + ， 然后 讨论 COM + 为 现在 的 COM 和 MTS 技术 增加 了 哪些 服务 ， 最后 再 讨论一下 COM + 的 属性 编程 。 
 
 图 1Windows   DNA 长期 目标 
 2     什么 是 COM + 
 　 　 COM + 覆盖 了 许多 领域 ， 为 简单 起 见 ， 可以 将 COM + 看作 是 COM 加上 MTS 编程 模型 再 加上 一些 新 的 特征 。 COM 是 作为 工作站 级 的 组件 技术开发 出来 的 。 随着 DCOM 的 发行 ， COM 也 可以 通过 远程 方法 调用 和 远程 组件 实例 化来 支持 分布 应用 。 MTS 是 用来 提供 服务器端 的 组件 服务 ， 并 弥补 一些 COM 的 不足 ， 如 安全性 问题 ， 组件 管理 等 。 COM + 则 将 COM ， DCOM ， MTS 统一 成为 一个 企业级 的 组件 技术 。 如图 2 。 
 
 图 2COM + MTS = COM + 
 　 　 COM + 扩展 了 COM 和 MTS 编程 模型 ， 同时 还 解决 了 许多 COM 和 DCOM 开发 过程 中 的 许多 问题 ， 并 提供 了 更 多 的 服务 。 例如 ， COM + 提供 了 更好 的 组件 管理 环境 ， 支持 负载平衡 和 对象 缓冲 和 使用 更加 方便 的 事件 模型 。 
 　 　 从 另 一个 方面 来看 ， COM + 是 微软 组件 技术 的 成熟 。 COM 的 概念 对 程序员 来说 比较 难以 理解 ， 尤其 是 在 刚刚 接触 COM 的 时候 。 而 COM + 则 将 许多 细节 移到 了 操作系统 ， 使 程序员 将 精力 集中 在 高层次 的 业务 逻辑 方面 。 
 3     COM + 服务 
 3.1     COM + 目录 服务 
 　 　 现在 COM 和 MTS 组件 把 它们 的 配置 信息 放在 Windows 注册表 里 ， 而 COM + 则 把 大多 组件 的 信息 放在 一个 新 的 数据库 里 ， 这个 数据库 就 叫做 COM + 目录 ( COM +   Catalog ) 。 COM + 目录 统一 了 COM 和 MTS 注册表 ， 并 提供 了 一个 组件 管理 环境 。 开发人员 通过 COM +   Explorer 或 一系列 新 的 COM 接口 来 访问 COM + 目录 。 
 　 　 COM + 的 一个 新 特征 是 它 支持 声明 编程 ( Declarative   Programming ) 。 意思 是 说 ， 开发人员 按 通常 的 方式 开发 一个 组件 ， 在 分发 的 时候 组件 的 细节 却 各不相同 。 例如 ， 开发人员 开发 一个 可以 在 有 负载平衡 环境 下 工作 的 组件 ， 但 是否 使用 负载平衡 特性 却 各不相同 。 有些 应用程序 需要 使用 负载平衡 特性 ， 而 另 一些 却 不 。 是否 使用 负载平衡 特性 是 通过 COM +   Explorer 在 管理层 上 设置 的 。 
 3.2     COM + 负载平衡 
 　 　 现在 的 COM 和 MTS 的 一个 缺点 是 它们 不 支持 动态 负载平衡 。 为了 创建 远程 组件 的 一个 实例 ， 客户端 应用程序 必须 显式 地 指出 组件 服务器 的 机器 名称 。 这样 就 导致 应用程序 的 扩展性 不好 。 COM + 通过 对 客户端 应用程序 提供 透明 的 负载平衡 服务 解决 了 这个 问题 。 
 　 　 为 使用 负载平衡 特性 ， 首先 定义 一个 应用服务 群 ( 多台 安装 有 组件 的 服务器 ) ， 然后 配置 一台 负载平衡 路由器 ， 由 它 接收 创建对象 请求 并 将 请求 送到 应用服务 群中 的 某台 服务器 上 。 COM + 负载平衡 作为 一个 Windows   NT 服务 运行 在 路由 结点 上 。 当 收到 一个 创建对象 的 请求 后 ， 它 和 本地 SCM   ( Service   Control   Manager ) 一起 将 请求 送到 应用服务 群 中负载 最轻 的 服务器 上 。 
 
 图 3COM + 动态 负载平衡 
 　 　 每个 具有 负载平衡 能力 的 组件 与 一个 负载平衡 引擎 相 联系 ， 引擎 和 路由 结点 通信 来 决定 将 请求 送到 哪 一台 服务器 上 。 缺省 的 COM + 负载平衡 引擎 使用 应答 时间 算法 ， 应答 时间 通过 测量 每台 组件 服务器 上 每个 接口 的 每个 实例 的 每次 方法 调用 的 时间 来 计算出来 。 这个 算法 不 一定 对 每个 应用 都 最合适 ， 但 在 大多数 环境 下 它 工作 得 很 好 。 程序员 还 可以 开发 自己 的 负载平衡 引擎 ， 引擎 组件 本身 也 是 一个 COM + 组件 。 
 　 　 路由 结点 在 收到 创建对象 的 请求 时 ， 首先 在 COM + 目录 检查 该 组件 是否 支持 动态 负载平衡 ， 如果 是 ， 再 将 请求 送到 合适 的 服务器 。 请求 被 送到 服务器 后 一旦 对象 创建 好 ， 则 将 对象 的 引用 直接 传 回到 客户 ， 在 客户 和 服务器 间 建立 直接 连接 。 
 　 　 虽然 COM + 负载平衡 对 客户端 透明 ， 但 为了 提高效率 ， 在 编程 时 仍 要 小心 。 首先 ， 创建 远程 对象 时 使用 路由 结点 的 名称 而 不要 使用 远程 服务器 的 名称 。 由于 COM + 的 动态 负载平衡 只 在 组件 激活 时起 作用 ， 所以 客户 应 只 在 需要 的 时候 创建 远程 对象 ， 使用 完毕 后应 尽快 地 释放 ( 这 和 MTS 客户 编程 模式 有点 不 一样 。 MTS 客户 应 尽早 地 得到 对象 引用 ， 然后 就 一直 抓着不放 ， 以免 频繁 地 创建 释放 对象 ) 。 
 　 　 虽然 COM + 动态 负载平衡 仍然 存在 一些 问题 ， 比如说 ， 在 路由 结点 上 存在 单点 失效 问题 ， 但 它 毕竟 在 对 分布 应用 的 扩展性 支持 方面 迈出 了 一大步 。 
 3.3     COM + 内存 数据库 
 　 　 我们 知道 ， 对于 数据 访问 频繁 的 应用程序 ， 提高 其 性能 的 最好 方法 就是 把 尽可能 多 的 数据 放到 物理 内存 里 。 COM + 的 IMDB ( In - Memory   Database ) 就 提供 了 这方面 的 服务 。 IMDB 是 只 在 物理 内存 上 操作 的 临时性 事务 数据库系统 。 虽然 IMDB 主要 是 用于 Web 环境 以 解决 大量 用户 对 数据库 的 访问 问题 ， 但 它 依然 适用 于 任何 需要 快速 大量 数据 访问 的 应用 。 
 
 图 4COM + 内存 数据库 
 　 　 IMDB 实现 了 一个 面向 数据库 ， 优化 查询 的 缓冲 系统 。 它 能 从 后台 数据库 装入 物理 数据 或者 用来 存放 临时 数据 。 对 一个 热门 Web 站点 ， 每分钟 要 对 成千上万 的 用户 提供数据 查询 服务 ， 这个 代价 将 是 相当 昂贵 的 。 通过 使用 IMDB ， 把 那些 访问 频繁 的 表格 装入 Web 服务器 的 物理 内存 ， 就 能 简单 地 通过 增加 物理 内存 来 支持 更 多 的 用户 ， 而 内存 的 价格 越来越 便宜 ， 这样 也 就 大大降低 了 成本 。 同时 也 减少 了 Web 服务器 和 数据库 服务器之间 的 网络流量 。 
 IMDB 的 一个 重要 的 不同 是 它 不 通过 SQL 语句 来 访问 数据 。 IMDB 的 主要 目标 是 尽可能 快地 访问 数据 ， 为了 达到 这个 目标 ， 数据 访问 是 通过 标准 的 ISAM 技术 而 不是 SQL 解释器 来 实现 ， 这就是说 ， 必须 对 查询 或 过滤 的 字 段 建 索引 。 
 　 　 IMDB 作为 快速 数据 访问 的 缓冲 相当 有效 ， 它 同时 也 能 为 应用程序 管理 临时 数据 。 现在 的 MTS 组件 通过 SPM ( Shared   Property   Manager ) 来 共享 临时 数据 。 IMDB 现在 支持 事务 操作 ， 并且 将来 也 会 支持 分布 操作 ， 它 最终 将 成为 组件 共享 临时 状态 信息 的 解决方案 。 
 3.4     COM + 对象 缓冲 
 　 　 对象 缓冲 ( Object   Pooling ) 是 把 多个 组件 实例 装入 内存 的 过程 。 对象 缓冲 后 ， 当有 客户 请求 到来 时 就 能 立即 给 客户 应答 ， 大大提高 了 客户 响应速度 。 对象 缓冲 是 大型 可 扩展 应用程序 的 另 一个 重要 特征 。 在 MTS 环境 下 开发 组件 时 ， 组件 实现 IObjectControl   接口 。 当 组件 在 MTS 内部 实例 化 时 ， MTS 通过 IObjectControl 接口 提供 激活 / 失效 通知 。 当使 实例 无效 时 ， MTS 调用 CanBePooled (   ) 来看 实例 是否 能 被 放入 缓冲 。 现在 的 MTS 不 支持 对象 缓冲 ， 所以 CanBePooled (   ) 永远 不会 被 调用 。 COM + 系统 则 支持 对象 缓冲 。 
 　 　 其实 大多数 情况 下 不 需要 开发 支持 对象 缓冲 的 组件 。 那么 ， 什么 时候 需要 呢 ？ 一 ， 对象 的 创建 时间 大于 对象 的 实际 使用 时间 。 二 ， 组件 访问 有限 资源 如 数据库 ， 管道 连接 等 。 由于 对象 缓冲 的 大小 可以 限制 ， 对象 缓冲 在 第二种 情况 下 特别 有效 。 
 　 　 COM + 系统 已经 提供 了 许多 系统 级 的 支持 对象 缓冲 的 组件 ( 例如 ODBC 资源 对象 等 ) ， 所以 在 开发 大型 的 可 扩展 应用程序 时 开发人员 可以 集中精力 提供 应用 级 组件 。 
 3.5     COM + 排队 组件 
 　 　 现在 的 COM 开发 模式 是 基于 过程 调用 。 客户 与 组件 建立 RPC 连接 ， 查询 某个 接口 ， 然后 用 返回 的 接口 同步 调用 某个 方法 ， 通过 [ out ] 参数 取得 返回 信息 。 客户 的 生存期 是 和 组件 实例 紧密联系 在 一起 。 
 　 　 COM 提供 的 基于 RPC 的 服务 对 构建 分布 应用 来说 是 必须 的 ， 然而 ， 对 某些 应用 来说 ， 使用 消息传递 技术 可能 会 更 适合 。 新 的 COM + 排队 组件 ( Queued   Component ) 服务 为 这 一类 应用 提供 了 解决方案 。 
 　 　 基于 消息传递 的 应用 在 底层 使用 消息传递 系统 而 不是 RPC 连接 ， 这样 将 客户 和 组件 的 生存期 分离 开来 。 COM + 排队 组件 使用 的 底层 系统 是 MSMQ   ( Microsoft   Message   Queue   Server ) ， 客户 与 组件 通过 排队 机制 分离 开来 。 
 
 图 5COM + 排队 组件 
 　 　 这样 就 使 应用程序 具有 更加 灵活 的 可扩展性 和 可用性 。 如果 组件 暂时 不可 用 ， 则 客户程序 仍然 可以 执行 。 如果 客户 很多 而 服务器 很少 ， 则 可以 将 客户 的 请求 排队 ， 从而 均衡 服务器 的 负载 。 对 像 Web 站点 这样 负载 不 稳定 、 起伏 大 的 应用 来说 ， 采用 消息传递 方法 将 带来 极大 的 好处 。 
 当然 ， 基于 RPC 连接 和 消息传递 的 服务 对 分布式应用 来说 都 需要 ， 开发人员 可以 根据 最终用户 需求 来 选择 适当 的 技术 。 
 　 　 像 大多数 COM + 服务 一样 ， COM + 排队 组件 也 尽可能 多地 将 底层 细节 对 开发人员 隐藏 起来 。 实际 的 排队 机制 对 开发人员 透明 ， 开发人员 可以 像 开发 其它 组件 一样 开发 COM + 排队 组件 ， 但 有 两点 例外 ： 一 、 组件 接口 只能 有 [ in ] 参数 ， 这些 参数 将 通过 MSMQ 消息 按值 而 不是 按 地址 传递 。 二 、 组件 接口 方法 不能 有 返回值 。 
 　 　 当 客户 实例 化 一个 组件 时 ， COM + 运行 环境 实际上 在 本地 创建 一个 称为 “ 录音机 ” 的 代理 对象 。 当 客户 方法 调用 时 ， 录音机 把 调用 按 顺序 “ 记录 ” 到 MSMQ 消息 里 。 客户 释放 对象 的 所有 引用 后 ， 这个 消息 通过 MSMQ 被 送到 服务器 。 在 服务器 上 ， 一个 特别 服务 将 这些 消息 取出 来 ， 然后 用 另 一个 称为 “ 放音机 ” 的 代理 生成 组件 实例 。 放音机 “ 播放 ” 那些 方法 调用 同 组件 实例 交互 ， 就 像 组件 在 同 客户 在 交互 一样 。 如果 出错 ， 则 将 消息 放 回 队列 里面 去 。 
 　 　 COM + 提供 的 分离 、 异步 处理 使 开发人员 在 开发 分布式 的 企业 应用程序 时 具有 更大 的 灵活性 。 
 3.6     COM + 事件 
 　 　 COM 提供 了 两种 技术 来 处理 组件 和 客户 之间 的 事件 。 第一种 技术 使用 接口 回调 机制 ， 由 客户 实现 服务 组件 描述 的 接口 ， 组件 服务器 通过 调用 这些 客户 接口 来 实现 事件 触发 。 第二种 技术 叫做 可 连接 对象 ( Connectable   Objects ) ， 使用 标准 的 COM 接口 IConnectionPoint   。 后 一种 方法 和 第一种 相似 ， 但 它 提供 了 一种 更 通用 的 方法 来 连接 客户 和 组件 。 
 　 　 谈到 事件 的 时候 客户 和 组件 的 概念 就 模糊起来 。 事实上 ， 组件 变成 了 客户 ， 客户 变成 了 组件 。 它们 实际上 是 两个 共享 信息 的 合作 软件 实体 。 COM + 称 发布 信息 的 实体 为 “ 发行者 ” ( Publisher ) ， 接收 这些 信息 的 实体 为 “ 订阅 者 ” ( Subscriber ) 。 
 COM 事件 模型 有 以下 缺点 ： 
 　 　 ． 发行者 和 订阅 者 紧密 地 联系 在 一起 ， 在 编译 时 互相 要 知道 对方 的 接口定义 。 
 　 　 ． 支持 多路 广播 需要 编写 许多 额外 的 代码 。 
 　 　 ． 这种 模式 只 定义 了 一些 接口 ， 开发人员 仍然 需要 编写 代码 来 实现 这些 接口 。 
 　 　 ． IConnectionPoint 接口 在 分布 环境 下 效率 特别 差 。 
 　 　 ． 不 支持 持久 连接 ， 当然 这 也 是 由于 COM 的 实现 是 基于 RPC 的 。 
 
 图 6COM + 事件 模型 
 　 　 COM + 事件 模型 引入 了 一个 称为 事件 类 ( Event   Class ) 的 中间 对象 。 事件 类 是 由 COM + 运行 环境 实现 的 组件 ， 位于 发行者 和 订阅 者 之间 。 因为 事件 类 实现 了 事件 接口 ， 对 发行者 而言 ， 它 是 订阅 者 。 当 发行者 要 触发 事件 时 ， 它 创建 一个 事件 类 实例 ， 调用 某个 事件 类 接口 方法 ， 然后 释放 接口 。 运行 环境 决定 何时 以及 怎样 通知 订阅 者 。 像 排队 组件 一样 ， 发行者 和 订阅 者 的 生存期 是 分开 的 。 也 是 由于 同样 的 原因 ， 事件 接口 只能 有 [ in ] 参数 。 
 　 　 接收 事件 比较简单 。 订阅 者 通过 运行 环境 的 帮助 创建 一个 订阅 对象 ， 并 将 它 加到 COM + 事件 库 ( COM +   Event   Store ) ， 这样 当 发行者 触发 事件 时 ， 事件 类 就 能 确定 谁 “ 订阅 ” 了 该 事件 ， 并 通知 订阅 者 ， 甚至 在 必要 的 时候 激活 订阅 者 。 
 总而言之 ， 新 的 COM + 事件 系统 ： 
 　 　 ． 将 订阅 者 和 发行者 的 生存期 分离 。 
 　 　 ． 在 事件 系统 增加 了 一个 激活 模式 。 当 事件 发生 时若 订阅 者 没有 激活 ， 运行 环境 可以 激活 订阅 者 而 将 事件 信息 传给 它 。 
 　 　 ． 提供 一个 第三方 的 发行者 - 订阅 者 环境 。 一旦 事件 类 创建 ， 双方 都 可以 事件 的 发行者 或 订阅 者 。 
 　 　 ． 支持 丰富 的 过滤 机制 。 通过 编写 过滤 对象 ， 可以 在 订阅 者 级 和 发行者 两端 过滤 事件 ， 后者 的 效率 更高 。 
 　 　 COM + 事件 系统 不单是 为 应用 程序开发 ， 它 还 在 COM + 内部 被 用来 处理 调试 和 跟踪 消息 ， 甚至 用来 实现 操作系统 本身 。 
 4     基于 属性 编程 
 　 　 COM + 提供 了 这么 多 特征 ， C++ 程序开发 人员 仍然 需要 某种 方式 来 利用 这些 特征 。 开发 COM 组件 是 一项 困难 的 工作 ， 因为 COM 和 C++ 的 开发 模式 不 一样 ， 尽管 ATL 已经 使 开发 COM 组件 容易 多 了 ， 但 它 仍然 需要 一些 底层 的 COM 知识 。 COM + 采用 基于 属性 的 编程 ( Attribute - based   Programming ) ， 大大简化 程序开发 。 
 　 　 基于 属性 编程 是 一种 在 代码 里 使用 声明 性 指令 ( Declarative   Instruction ) 来 指导 它 的 实现 的 技术 ， 换句话说 ， 就是 不 对 每个 组件 编写 相同 的 系统 级 代码 ， 而是 指导 开发工具 来 实现 这些 代码 。 属性 封装 了 底层 概念 ， 并 将 这些 信息 提供 给 编译器 。 属性 并 不 改变 底层 的 C++ 代码 语意 ， 而是 通过 “ 属性 提供者 ” ( Attribute   Provider ) 将 嵌入 的 属性 转 成 标准 的 C++ 代码 。 
 
 图 7 属性 编译 
 　 　 在 C++ 语言 里 支持 基于 属性 编程 并不需要 修改 C++ 编译器 ， 只 需要 在 编译 过程 里 插入 一个 支持 额外 语言 属性 的 机制 即可 。 当 编译器 在 源代码 遇到 属性 时 ， 它 把 属性 传给 属性 提供者 ， 属性 提供者 将 属性 转变成 C++ 代码 ， 然后 将 这些 代码 回 送到 编译器 ， 然后 编译器 产生 最终目标 代码 。 这样 任何人 都 可以 写 他 / 她 自己 的 属性 提供者 来 增加 语言 的 功能 。 
 5     结论 
 　 　 COM + 作为 Windows   DNA 架构 的 核心 部分 ， 在 原有 DCOM 和 MTS 的 基础 上 又 提供 了 目录 服务 ， 动态 负载平衡 服务 ， 内存 数据库 服务 ， 对象 缓冲 服务 ， 排队 组件 服务 等 多种 可靠 服务 ， 同时 还 提供 了 新 的 事件 模型 ， 为 应用程序 开发人员 开发 大型 可 扩展 的 分布式 企业级 应用程序 带来 更大 的 灵活性 。 基于 属性 编程 将 底层 的 概念 隐藏 到 操作系统 内部 ， 从而 使 应用 程序开发 更 轻松 ， 自然 。 
 潘登 ( 上海交通大学 计算机科学 与 工程系   上海   200030 ) 
 侯文永 ( 上海交通大学 计算机科学 与 工程系   上海   200030 ) 
 参考文献 
 1 ， Windows   DNA ,   Building   Applications   for   the   Internet   Age ,   Microsoft   Corporation   White   Paper ,   October   1998 
 2 ， Tom   Armstrong ,   COM +   Event ,   Visual   C++   Developers   Journal ,   1999   ( July / August ) 
 3 ， Tom   Armstrong ,   COM   +   MTS   =   COM + ,   Next   Step   in   the   Windows   Component   Strategy ,   Visual   C++   Developers   Journal ,   1999   ( February / March ) 
 4 ， Language   Innovations   for   COM +   and   Beyond ,   TOOL13   Presentation   at   Microsoft   PDC   1998 
 收稿 日期 ： 1999 - 11 - 25 
