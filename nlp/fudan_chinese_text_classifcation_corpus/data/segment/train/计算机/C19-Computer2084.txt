计算机 工程 
 COMPUTER   ENGINEERING 
 1999 年   第 25 卷   第 10 期   Vol.25   No.10   1999 
 
 
 
 Java 动态 数据结构 与 软 构件 重用 技术 的 实现 
 钟诚 　 宋玲 　 赵明 
 摘要 ： Java 是 一种 支持 并行 和 颁式 处理 的 纯 面向对象 的 计算环境 。 探讨 其 动态 对象 技术 和 继承 机制 ， 并 通过 实例 说明 动态 数据结构 和 软 构件 重用 的 实现 方法 。 
 关键词 ： Java ； 面向对象 ； 动态 数据结构 ； 软件 重用 
 Implementation   on   Dynamic   Data   Structure   and   Software   Reuse   Technologuy   in   Java 
 Zhong   Cheng   Song   Ling   Zhao   Ming 
 ( School   of   Computer   and   Information   Engineering , Guangxi   University , Nanning   530004 ) 
 【 Abstract 】 Java   is   an   Object - oriented   distributcd   computing   environment . In   this   paper , dynamic   data   structure   and   software   reuse   technology   is   researched   and   implemented   in   Java   programming . 
 【 Key   words 】 Java   ; Object - oriented ; Dynamic   data   structures ; Sofware   reuse 
 1     通过 动态 对象 和 构造方法 实现 动态 数据结构 
 　 　 Java 的 对象 是 通过 对类 进行 实例 化 动态 产生 的 ， 而 构造方法 则 实现 对象 的 初始化 [ 1 , 2 ]   。 因此 ， 可以 巧妙 地 应用 动态 对象 和 构造方法 创建 大小 可 伸缩 的 动态 数据结构 － 诸如 动态 数组 、 动态 栈 和 动态 队列 等 ， 从而 使得 面向对象 程序设计 更加 灵活 和 有效 ， 以 满足 随 时间 变化 的 应用 的 需要 。 
 　 　 为什么 要 研究 动态 数据结构 呢 ？ 我们 知道 ， 大规模 科学 与 工程 计算 、 计算机 图象处理 等 领域 经常 需要 对 N × N 矩阵 进行 计算 和 处理 。 当 问题 规模 N 较大 时 ， 此 矩阵 占据 了 大量 的 内存空间 ， 使得 许多 问题 的 求解 难以 在 内存容量 有限 的 系统 上 实现 。 事实上 ， 许多 情况 下 应用 系统 并 不是 每时每刻 都 要 使用 N × N 个 数据 。 例如 ， 在 某些 时间 里 可能 只 需 使用 到 下 三角 ( 或 上 三角 ) 矩阵 中 的 元素 。 如果 应用 诸如 Fortran 、 Pascal 或 C 等 传统 的 面向 过程 的 语言 编程 实现 时 ， 只能 且 必须 静态 地 申请 分配 一个 存储单元 数为 N2 的 方阵 ， 这 显然 浪费 了 ( N2 - N ) / 2 个 存储单元 。 因此 ， 探讨 产生 各维 大小 可 动态变化 的 数组 具有 重要 意义 。 
 　 　 下面 以 Windows95 和 CAFE 平台 为例 ， 通过 动态 产生 三角 矩阵 来 说明 动态 数据结构 产生 方法 。 由于 Java 系统 将 数组 抽象 成类 ， 某个 具体 数组 则 是 数组 类 的 一个 实例 对象 ， 因此 可以 将 某个 具体 的 Java 多维 数组 看成 是 数组 类 对象 的 一个 实例 对象 ， 而且 其 各维 的 大小 通过 构造方法 动态 地 逐步 产生 ： 
 　 　 class   multiarray 　 / / 　 矩阵 类 
 　 　 　 { 　 double 　 x [ ] [ ] ; 
 　 　 　 　 　 multiarray (   int   n ) 　 / / 　 构造方法 
 　 　 　 　 　 　 { 　 x = new 　 double [ n ] [ ] ; 
 　 　 　 　 　 　 　 for   ( int 　 i = 1 ; i < = n ; i ++ ) 　 / / 　 动态 构造 三角 矩阵 
 　 　 　 　 　 　 　 　 　 x [ i - 1 ] = new 　 double [ i ] ; 
 　 　 　 　 　 　   } 
 　 　 　 　 　 　 void 　 assign ( int   n ) 
 　 　 　 　 　 　 　 { 　 for   ( int   i = 0 ; i < n ; i ++ ) 　 / / 　 给 三角 矩阵 赋值 
 　 　 　 　 　 　 　 　 　 for   ( int   j = 0 ; j < = i ; j ++ ) 
 　 　 　 　 　 　 　 　 　 　 x [ i ] [ j ] = i + j ; 
 　 　 　 　 　 　 　   } 
 　 　 　 　 　 　 　 void   output ( int   n ) 
 　 　 　 　 　 　 　 　 { 　 for ( int 　 i = 0 ; i < n ; i ++ ) 　 / / 　 输出 三角 矩阵 
 　 　 　 　 　 　 　 　 　 　 { 　 for ( int   j = 0 ; j < = i ; j ++ ) 
 　 　 　 　 　 　 　 　 　 　 　 　 　 System . out . print ( " 　 " + x [ i ] [ j ] ) ; 
 　 　 　 　 　 　 　 　 　 　 　 　 System . out . println ( ) ; 
 　 　 　 　 　 　 　 　 　 　   } 
 　 　 　 　 　 　 　 　 } 
 2 　 通过 继承 机制 实现 软 构件 重用 
 　 　 所谓 软件 重用 是 指 利用 现有 的 可靠 的 软件 成分 ( 称为 软 构件 ) 来 构造 新 的 应用软件 系统 [ 3 , 4 ]   。 这些 软 构件 可以 是 软 构件 库里 的 标准件 也 可以 是 用户 自己 新 开发 的 构件 。 实现 软 构件 重用 的 一种 技术 是 继承 机制 。 当 开发 应用 系统 时 ， 首先 将要 处理 的 客观 世界 的 事物 定义 成 通用 的 抽象 的 软件 成分 Y ， 然后 在 此基础 上 再 定义 各种 较为 具体 的 软件 成分 X ， 并 通过 继承 ， 使得 X ( 又 称为 子类 X )   可以 自动 地 共享 Y ( 又 称为 父类 Y ) 的 数据 和 方法 ， 从而 实现 软 构件 重用 ， 如图 1 所示 。 
 
 图 1     子类 X 通过 继承 重用 父类 Y 
 　 　 其中 继承 映射 可以 是 直接 的 " 继承 " ， 即 子类 的 继承 部分 完全 等同于 父类 ( 数据 与 方法 ) ； 也 可以 是 其他 更 丰富 、 更 广阔 的 " 继承 " ， 比如 重新 定义 成员 数据 、 重新 实现 方法 等 。 当类 X 继承 Y 时 ， 我们 说类 X 重用 了 类 Y 的 数据 / 方法 。 
 　 　 开发 可 重用 构件 的 应用 系统 时 ， 如果 软 构件 的 抽象 程度 不高 ， 那么 软 构件 库 就 会 变得 庞大 和 繁杂 ， 降低 了 应用 系统 的 有效性 和 可靠性 ， 从而 失去 通过 集成 软 构件 构造 应用软件 系统 的 意义 。 因此 ， 应用 软 构件 重用 技术开发 应用 系统 的 关键问题 是 如何 识别 和 分类 出软 构件 、 以及 如何 组织 和 实现 软 构件 。 基本 原则 是 仅 将 客观事物 最 基本 的 内容 抽象 成可 重用 的 软 构件 ， 即将 最 基本 的 内容 抽象 成父 类 。   
 　 　 Java 支持 直接 重用 系统 提供 的 各种各样 的 标准 的 软 构件 ( 类 ) ， 也 可以 由 开发人员 通过 extends 指定 类 X 直接 继承 类 Y 来 实现 软 构件 ( 程序 ) 的 重用 ； 并 通过 引用 super . 成员 变量 重载 父类 的 数据 、 通过   super . 方法 ( [ 参数 ] ) 重载 父类 的 方法 ， 以及 通过 super ( [ 参数 ] ) 重载 父类 的 构造方法 来 实现 软件 ( 程序 ) 的 多态性 。 
 　 　 下面 以 计算机科学 与 技术 中 应用 十分 广泛 的 栈 数据 对象 为 例来 讨论 在 Java 应用程序 中 实现 软 构件 重用 的 方法 。 栈 属于 线性 有序 结构 ， 具有 线性 数据结构 的 共同 属性 - - - - - 诸如 建立 线性表 、 判断 线性表 空 或 满 、 查找 线性表 中 有否 满足要求 的 元素 、 将 新元素 插入 线性表 指定 的 位置 、 将 线性表 中 满足条件 的 元素 删除 等等 。 但是 ， 栈有 其 自己 的 特点 ， 即栈 的 插入 和 删除 操作 按照 先进后出 原则 在 同 一端 进行 [ 5 ] 。 
 　 　 因此 ， 首先 定义 一个 线性 数据结构 类 ， 它 封装 了 线性表 数据 ， 建立 线性表 方法 、 判断 线性表 空 或 满 方法 、 查找 线性表 中 有否 满足要求 的 元素 的 方法 等 ， 然后 利用 继承 机制 和 重载 技术 实现 栈类 ： 
 　 　 class 　 lineartable 　 / / 　 线性表 类 
 　 　 　 {   int   s [ ] ; 　 / / 　 定义 线性表 　 s 
 　 　 　 　 int   top = - 1 ; 　 / / 　 top   指向 当前 线性表 最后 一个 元素 
 　 　 　 　 lineartable ( int   n ) 　 / / 　   动态 建立 大小 为 n 的 线性表 方法 
 　 　 　 　 　 { 
 　 　 　 　 　 　 s = new   int [ n ] ; 
 　 　 　 　 　   } 
 　 　 　   boolean   over   (   ) 　 / / 　 判断 当前 线性表 是否 满 方法 
 　 　 　 　 　 　 {   if   ( top > = s . length   - 1 ) 
 　 　 　 　 　 　 　 　 return   true ; 
 　 　 　 　 　 　 　 else 
 　 　 　 　 　 　 　 　 return   false ; 
 　 　 　 　 　 　 } 
 　 　 　 　 　 boolean   empty   (   ) 　 / / 　 判断 当前 线性表 是否 空 方法 
 　 　 　 　 　 　 {   if   ( top < 0 ) 
 　 　 　 　 　 　 　 　 return   true ; 
 　 　 　 　 　 　 　 else 
 　 　 　 　 　 　 　 　 return   false ; 
 　 　 　 　 　 　 } 
 　 　 　 　 　 int   search ( int   x ) 　 / / 　 查找 线性表 中 有否 数据 返回 其标 ind 的 方法 
 　 　 　 　 　 　 {   
 　 　 　 　 　 　 　 int   i = 0 , flag = 0 , ind = - 1 ; 
 　 　 　 　 　 　 　 while   ( flag = = 0   &&   i < = top ) 
 　 　 　 　 　 　 　 　 if   ( s [ i ] = = x ) 
 　 　 　 　 　 　 　 　 　 {   ind = i ; 
 　 　 　 　 　 　 　 　 　 　 flag = 1 ; 
 　 　 　 　 　 　 　 　 　 } 
 　 　 　 　 　 　 　 　 else 
 　 　 　 　 　 　 　 　 　 ++ i ; 
 　 　 　 　 　 　 　 　 　 　 return 　 ind ; 
 　 　 　 　 　 　 　 　 　 } 
 　 　 　 　 　 　 } 
 　 　 　 　 　 class   stack   extends   lineart   able 　 / / 　   栈 子类 
 　 　 　 　 　 　 {   stack ( int   n ) 
 　 　 　 　 　 　 　 　 { 
 　 　 　 　 　 　 　 　 　 super ( n ) ; 　 / / 　 继承 并 重用 线性表 父类 建立 线性表 方法 来 建立 大小 为 n 、 栈顶 指针 为 top 的 栈 s 
 　 　 　 　 　 　 } 
 　 　 　 　 　 void   insert (   int   x ) 　 / / 　 栈 子类 特有 的 压栈 方法 
 　 　 　 　 　 　 {   if   ( super . over ( ) ) 　 / / 　 / / 　 继承 并 重用 线性表 父类 的 判断 栈 是否 溢出 方法 
 　 　 　 　 　 　 　 　 System . out . println ( " The   stack   is   over   ! " ) ; 
 　 　 　 　 　 　 　 　 　 else 
 　 　 　 　 　 　 　 　 {   ++ top ; 
 　 　 　 　 　 　 　 　 　 s [ top ] = x ; 
 　 　 　 　 　 　 　 　 } 
 　 　 　 　 　 　 } 
 　 　 　 　 　 int   delete ( ) 　 / / 　 栈 子类 特有 的 出栈 方法 
 　 　 　 　 　 　 {   int   y ; 
 　 　 　 　 　 　 　 y = - 1 ; 
 　 　 　 　 　 　 　 if   ( super . empty ( ) ) 　 / / 　 继承 并 重用 线性表 父类 的 判断 栈 是否 为空 方法 　 　 　 　 　 　 　 　 　 　 System . out . println ( " The   stack   is   empty   ! " ) ; 
 　 　 　 　 　 　 　 else 
 　 　 　 　 　 　 　 　 {   y = s [ top ] ; 
 　 　 　 　 　 　 　 　 　 - - top ; 
 　 　 　 　 　 　 　 　 } 
 　 　 　 　 　 　 　 return   y ; 
 　 　 　 　 　 　 } 
 　 　 　 　 } 
 　 　 此外 ， 队列 也 是 另 一种 有序 线性 结构 。 因此 ， 利用 继承 机制 和 重载 技术 并 参考 栈类 的 实现 ， 很 容易 实现 队列 类 重用 线性表 类 的 数据 和 有关 方法 。 
 　 　 由此可见 ， 利用 继承 机制 和 重用 技术 将 标准 、 可靠 的 软 构件 组装 应用软件 系统 ， 一方面 可以 减少 大量 重复性 劳动 ， 有助于 快速 开发 软件系统 的 原型 、 提高 软件生产率 ； 另一方面 可以 大大降低 应用 系统 的 出错率 ， 提高 新 开发 的 软件系统 的 可靠性 、 可维护性 和 可扩充性 ； 从而 大大 促进 、 增强 软件 的 可用性 和 适应性 。 
 3     结语 
 　 　 Java 是 一种 纯 面向对象 、 跨平台 、 可 重用 、 健壮 、 安全 、 支持 语言 级 多线程 并发 技术 的 分布式计算 环境 ， 它 与 Web 技术 的 有机 结合 尤其 适宜 进行 网络 计算 和 动态 多媒体信息 的 并发 处理 。 相信 Java 计算技术 在 21 世纪 将 在 网络 计算 、 并行 和 分布 处理 、 多媒体 和 虚拟现实 技术 以及 科学 与 工程 计算 等 领域 得到 广泛 的 应用 。 
 基金项目 ： 广西 自然科学 基金 （ 9712010 ） 和 广西 教委 科研 基金 （ S96308 ） 
 作者简介 ： 钟诚 （ 1965 ～ ） ， 男 ， 副教授 ， 主要 研究 并行计算 、 基于 Java 的 分布式系统 应用 和 数据安全 等 
 作者 单位 ： 广西大学 计算机 与 信息 工程学院 ， 南宁 　 530004 
 参考文献 
 1   Sun   Microsystems   Inc . Java   Computing . http : / / www . sun . com , 1996 
 2   王克宏 主编 ， 郁欣   , 王曦东 , 姜河 编著 . Java 语言 编程技术 , 北京 ： 清华大学出版社 , 1997 
 3   毛 新军 , 齐治昌 . 软件 重用 研究 与 应用 . 计算机科学 , 1994 , 21 ( 4 ) ：   65 - - 67 
 4   蒋学锋 , 钟诚 , 许鸿川 . 软件工程 . 重庆 ： 重庆大学 出版社 , 1997 
 5   苏德富 , 钟诚 , 薛弘哗 . 数据结构 . 重庆 ： 重庆大学 出版社 , 1997 
 收稿 日期 ： 1999 - 01 - 20 
