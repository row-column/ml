计算机 研究 与 发展 
 JOURNAL   OF   COMPUTER   RESEARCH 
 AND   DEVELOPMENT 
 1999 年   第 36 卷   第 12 期   Vol.36   No.12   1999 
 
 
 
 并行 重构 程序 中 过程 调用 的 优化 技术 
 冯晓兵 　 　 　 张兆庆 
 摘 　 要 　 过程 间 分析 技术 是 提高 编译器 目标 码 效率 的 重要 技术 . 在 分布式 存储 的 并行 系统 中 ， 数据分布 的 好坏 对 应用程序 的 性能 有 重要 影响 . 但是 仅 做 过程 内 的 数据 对齐 和 分布 推导 难以获得 良好 的 全局 数据分布 模型 ， 而且 会 使 过程 调用 的 开销 难以 控制 ， 因而 如何 处理过程 调用 ， 以及 数据分布 信息 在 过程 调用 点 的 收集 与 传播 对 生成 高效率 的 目标 码是 极其重要 的 . 文中 应用 过程 调用 实例 化 技术 ， 减小 过程 调用 的 开销 ， 并 能 很 好 地 满足 数据 局部性 要求 . 
 关键词 　 并行 编译器 ， 数据 局部性 ， 实例 化 ， 数据分布 模型 
 中图法 分类号 　 TP311 
 A   METHOD   FOR   PROCEDURE   CALL   OPTIMIZING 
 FENG   Xiao - Bing   and   ZHANG   Zhao - Qing 
 ( Center   of   High   Performance   Computing ,   Institute   of   Computing   Technology ,   
 Chinese   Academy   of   Sciences ,   Beijing   100080 ) 
 Abstract 　 Global   data   distribution   analysis   is   a   key   technology   for   parallel   compilers .   Compiler   should   let   computing   and   data   used   by   these   computing   locate   at   the   same   processor ,   otherwise ,   the   performance   of   applications   will   be   very   poor .   Interprocedure   analysis   is   necessary   for   global   data   distribution   analysis .   When   mapping   functions   of   a   formal   array   and   actual   array   associated   with   this   formal   array   are   not   compatible ,   the   cost   of   this   procedure   callsite   will   be   very   high .   Two   issues   must   be   solved :   ①   how   to   process   procedure   calls ;   ②   how   to   collect   array   distribution   information   and   transfer   the   useful   information   among   procedures .   In   this   paper ,   a   method   for   solving   these   two   issues   is   introduced .   All   callsites   of   a   procedure   are   classified   into   patterns   according   to   their   calling   contexts ,   with   each   pattern   calling   a   special   body   of   this   procedure .   Information   used   to   classify   the   callsites   can   be   applied   for   pattern   body ' s   parallel   optimizing ,   too .   This   is   called   instantiation .   This   method   can   be   used   to   decrease   the   cost   of   procedure   call   and   to   obtain   a   global   optimizing   data   distribution   model . 
 Key   words 　 parallel   compiler ,   data   locality ,   instantiation ,   data   distribution   model 
 1 　 引 　 　 言 
 　 　 并行处理 系统 的 广泛应用 促进 了 并行 编译器 的 研究 ， 如何 提高 并行 编译器 的 性能 是 我们 面临 的 重要 问题 . 特别 是 对于 具有 分布式 并行处理 系统 ， 应用程序 的 数据 空间 在 分布式 存储 中 的 映射 形式 严重 地 影响 着 程序 的 执行 效率 . 如何 确定 应用程序 的 全局 数据分布 与 计算 分割 模型 ， 以 取得 更好 的 数据 局部性 ， 这是 提高 应用程序 性能 的 一个 关键因素 ［ 1 ～ 3 ］ . 
 　 　 全局 优化 的 数据分布 与 计算 分割 模型 的 推导 不能 回避 过程 调用 的 处理 . 过程 是 一个 相对 封闭 的 程序 体 ， 过程 在 被 调用 时 获得 的 形式参数 或 全局 量 的 信息 将 约束 着 过程 的 动态 行为 ， 而 过程 对 参数 或 全局 量 的 操作 以及 返回值 也 反过来 影响 着 调用者 的 行为 . 由于 调用者 对于 被 调用 过程 内部 的 信息 是 模糊 的 ， 编译器 不得不 在 程序 分析 、 优化 时 做 保守 估计 ， 从而 使得 很多 的 优化 、 并行 化 工作 无法 完成 ， 严重 地 影响 了 并行 优化 效果 . 特别 是 对于 分布式系统 上 的 并行程序 ， 如果 不 做 过程 间 优化 措施 ， 可能 使得 过程 调用 的 开销 大大提高 . 
 　 　 例 1 . 过程 调用 可能 导致 大量 数据通信 
 　 　 　 program   sample 　 　 　 　 　 　 　 　 　 　 　 subroutine   f ( c ) 
 　 　 　 　 real   a ( 100 , 100 ) , b ( 100 , 100 ) 　 　 　 　 　 real   c ( 100 , 100 ) 
 　 　 　 　 　 … 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 integer   I , J 
 　 　 　 s1 :   f ( a ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 do   I   =   1 , 100 
 　 　 　 　 　 … 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 do   J   =   1 , 100 
 　 　 　 s2 :   f ( b ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 c ( I , J )   =   I × 3 + J 
 　 　 　 　 　 … 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 enddo 
 　 　 　 　 　 end 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 return 
 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 end 
 　 　 在 上例 的 FORTRAN 程序 中 ， 过程 f 中 的 两层 循环 都 是 可以 并行 的 ， f 在 主程序 中 被 调用 了 两次 ， f 在 调用 点 s1 获得 的 实在 参数 是 数组 a ， 在 调用 点 s2 获得 的 实在 参数 是 数组 b . 如果 经过 并行 编译器 的 分析 得出 数组 a 的 第一 维 被 分布 了 ， 而 数组 b 得 第二 维 被 分布 了 ， 此时 如何 确定 过程 f 中 形式参数 数组 c 的 数据分布 模式 呢 ？ 如果 对 过程 f 不 做 特殊 处理 ， 由于 f 的 两次 调用 时 实参 数组 的 数据分布 模式 是 矛盾 的 ， 对 f 的 两次 调用 必然 导致 数据 重 映射 （ remap ） 或 大量 的 数据通信 ， 而 这些 操作 可能 会 大大 加大 过程 调用 的 开销 . 对于 如何 处理程序 中 的 过程 调用 ， 一般 有 3 种 方法 ［ 1 ， 4 ， 5 ］ ： 
 　 　 ( 1 ) 过程 嵌入 （ inline ） 的 方法 ： 该 方法 是 在 过程 被 调用 处 直接 嵌入 过程 体 的 一个 副本 ， 在 进行 程序 分析 、 优化 工作 时 可以 全面 地 获得 调用者 和 被 调用者 的 信息 . 但 这种 方法 会 导致 程序 体 的 过度 膨胀 ； 而且 系统 不能 在 任何 上下文 的 环境 中 都 将 一个 调用 点 所 调用 的 过程 嵌入 进来 ； 最后 ， 采用 过程 嵌入 的 方法 有 可能 对 数据 依赖 测试 等 环节 是 无效 的 . 
 　 　 ( 2 ) 过程 间 的 数据流 分析 技术 ： 在 分析 一个 过程 时 ， 其 入口 的 信息 是 指 所有 调用 点 信息 的 综合 ， 每个 调用者 所 获得 的 被 调用 过程 的 信息 将 是 一致 的 . 为了 程序 分析 的 正确性 必然 会 在 某些 环节 采用 保守 估计 ， 影响 程序 分析 、 优化 的 效果 . 
 　 　 ( 3 ) 过程 繁衍 ： 根据 过程 调用 的 上下文 对 同一 过程 的 不同 调用 点 进行 分类 ， 每个 类 对应 了 过程 的 一个 实例 . 源程序 中 的 一个 过程 可能 裂变 成为 几个 副本 ， 但 这种 裂变 是 有 选择 的 . 
 　 　 在 本文 中 ， 我们 将 介绍 一个 过程 间 分析 、 优化 的 算法 框架 ， 以 完成 全局 数据分布 和 计算 分割 模式 的 推导 ， 以 降低 过程 调用 开销 ， 提高 并行程序 的 性能 . 核心技术 是 根据 调用 点 的 上下文 信息 对 过程 调用 进行 实例 化 . 我们 的 工作 背景 是 一个 Fortran 语言 并行 编译器 ， 但 其 基本原理 可以 应用 于 C语言 并行 编译器 的 开发 . 
 2 　 数据分布 映射 的 变换 
 　 　 数据分布 模式 在 过程 间 的 收集 、 传播 、 比较 ， 这是 本文 算法 的 重要 组成部分 ， 因为 判断 一个 过程 的 两个 被 调用 点 是否 可以 共用 同一个 过程 实体 ， 依据 是 这个 过程 所 涉及 的 参数 数组 或 全局 数组 等 的 数据分布 模式 是否 相同 . 另外 ， 由于 某些 数组 的 数据分布 信息 对于 全局 优化 的 数据分布 和 计算 分割 模式 的 推导 有 重要 的 指导意义 ， 需要 在 尽可能 广 的 范围 内 进行 扩散 ， 所以 在 过程 调用 处 可能 将 调用者 的 数据分布 信息 传递 给 被 调用者 ， 也 可能 将 被 调用者 的 数据分布 信息反馈 给 调用者 . 
 2.1 　 几个 概念 
 　 　 首先 ， 我们 说明 一个 概念 ： 形 参数 组 的 分布模式 . 在 Fortran 标准 ［ 6 ］ 中 规定 形式参数 数组 并 不 占据 实际 的 内存空间 ， 所有 对哑 数组 的 操作 都 是 操作 的 与 之 结合 的 实参 数组 . 因而 在 我们 提及 “ 形 参数 组 的 分布模式 ” 时 ， 并 不 意味着 形 参数 组 被 分布 了 ， 而是 指在 形实 结合 后 ， 与 形 参数 组 结合 的 实参 数组 在 以形 参数 组 的 形 ( shape ) 出现 时 ， 其所 对应 的 分布模式 . 
 　 　 定义 1 . 分布模式 一致 . 在 形 参数 组与实 数组 包含 相等 的 数组 元素 个数 的 前提 下 ， 在 过程 的 两个 不同 调用 点 与 同一个 形 参数 组 C 的 相结合 的 实 数组 A 和 B ， 分别 具有 数据分布 模式 DA 和 DB . 数组 A 在 与 形 参数 组 C 做 形实 结合 时 ， 将 其 分布模式 DA 传播 给 C ， 形式 为 DC1 . 数组 B 在 与 形 参数 组 C 做 形实 结合 时 ， 将 其 分布模式 DB 传播 给 C ， 形式 为 DC2 . 如果 DC1 和 DC2 相同 ， 则 称 在 这 两个 调用 点处 ， 形 参数 组 C 的 分布模式 是 一致 的 . 对于 全局 数组 以及 Fortran 语言 中 的 公共 量 做 同样 的 约定 . 
 　 　 定义 2 . 调用 点 一致 . 对于 一个 过程 F 的 两个 调用 点 F1 ， F2 ， 如果 ： 
 　 　 ① 对于 被 分布 的 形 参数 组 ， 其 “ 形 ” 是 相同 的 ； 
 　 　 ② 各个 相应 的 形 参数 组 的 分布模式 是 一致 的 ； 
 　 　 ③ 若 这个 过程 中 出现 了 公共 量 ， 则 各个 相应 的 公共 数组 的 分布模式 是 一致 的 ； 
 　 　 ④ 若 这个 过程 所 引用 了 全局 数组 ， 则 各个 相应 的 全局 数组 在 两个 调用 点处 是 一致 的 ； 
 　 　 ⑤ 若 这个 过程 调用 了 其它 的 过程 G ， F1 调用 G 的 实体 G1 ， F2 调用 G 的 实体 G2 ， G1 和 G2 是 一致 的 ； 
 　 　 则 称 调用 点 F1 ， F2 是 一致 的 . 
 　 　 此时 ， 这 两个 调用 点 调用 这个 过程 的 同一个 实体 . 否则 ， 这 两个 调用 点应 归属于 不同 的 类 ， 调用 不同 的 实体 . 
 2.2 　 对 公共 量 分布 的 一些 限制 及其 处理 
 　 　 在 Fortran 语言 中 ， COMMON 语句 和 EQUIVALENCE 语句 指定 了 不同 的 数据 对象 的 对齐 关系 ， 指明 了 存储 结合 ［ 6 ］ 的 关系 . 
 　 　 例 2 . 存储 结合 的 例子 
 　 　 　 SUBROUTINE   f1 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 SUBROUTINE   f2 
 　 　 　 COMMON / com1 / a ( 100 ) , b ( 20 , 20 ) , c ( 50 ) , d ( 150 ) 　 　 COMMON   / com1 / x ( 100 ) , y ( 400 ) , z ( 200 ) 
 　 　 　 　 　 REAL   e ( 100 ) 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 　 … 
 　 　 　 　 　 EQUIVALENC   ( a ( 51 ) ,   e ( 1 ) ) 　 　 　 　 　 　 　 　 END 
 　 　 　 　 　 … 
 　 　 　 END 
 　 　 在 例 2 中 ， 数组 a ， b ， e ， x ， y 共享 同一 存储 序列 ， 因而 f1 中 的 a ， b ， c 这 3 个 数组 分布模式 的 推导 要 统一 考虑 ， 不能 分开 . 同样 由于 数组 c ， d ， z 也 共享 同一 存储 序列 ， 因而 对 数组 c ， d 的 分布模式 也 要 统一 考虑 . 否则 ， 可能 使得 数组 z 在 同一 时刻 对应 了 两种 数据分布 模式 . 借鉴 HPF ［ 7 ］ 的 经验 ， 对 公共 、 等价 变量 的 数据分布 模式 的 推导 做 一些 限制 . 
 　 　 定义 3 . 集合 变量 组是 一组 变量 的 收集 ， 这些 变量 各自 的 存储 序列 是 一个 唯一 存储 序列 的 一部分 . 集合 变量 组 的 大小 是 指 这个 集合 变量 组 包含 的 所有 存储单元 的 个数 . 
 　 　 定义 4 . 如果 在 一个 集合 变量 组中 ， 有 一个 成员 的 存储 序列 恰好 可以 覆盖 这个 集合 变量 组所 包含 的 所有 的 存储 序列 ， 则 称 这个 成员 为 这个 集合 变量 组 的 集合 覆盖 子 . 
 　 　 在 例 2 中 ， 数组 a ， b ， e ， x ， y 构成 了 一个 集合 变量 组 ， 其 大小 为 500 个 实数 ， 这 5 个 数组 都 不是 这个 集合 变量 组 的 集合 覆盖 子 ； 数组 c ， d ， z 构成 了 一个 集合 变量 组 ， 其 大小 为 200 个 实数 ， 其中 数组 z 是 这个 集合 变量 组 的 集合 覆盖 子 . 一个 公共 块 包含 了 一系列 的 成分 ( component ) ， 每个 成分 或者 是 一个 集合 变量 组 ， 或者 是 一个 不 属于 任何 集合 变量 组 的 变量 . 在 例 2 中 ， 公共 块 com1 包含 了 两个 成分 ， 均 为 集合 变量 组 . 
 　 　 在 处理 集合 变量 组 的 成员 时 ， 把 每 一个 集合 变量 组 当作 是 一个 模板 数组 ， 这个 模板 数组 显然 是 这个 集合 变量 组 的 集合 覆盖 子 . 将 程序 中 出现 的 集合 变量 组 的 成员 变量 按 集合 覆盖 子及 偏移量 做 换名 处理 ， 这样 就 可以 保证 在 同一 时刻 ， 一个 集合 变量 组只 对应 于 一种 分布模式 . 
 2.3 　 分布模式 变换 的 方法 
 　 　 我们 约定 一个 数组 在 其 生存期 内 只 对应 一个 数据分布 模式 . 由于 Fortran 语言 中 的 公用 数组 在 各个 过程 中 的 形 可能 不 一致 ， 因而 需要 做 变换 . 由于 相结合 的 形 参数 组和 实参 数组 都 有 可能 从 自己 所属 的 作用域 中 获得 数据分布 模式 ， 需要 对 相结合 的 形 、 实参 数组 的 数据分布 模式 进行 比较 或 变换 . 
 　 　 分布模式 变换 的 基本 原则 是 要 满足 串行 程序 语义 所 决定 的 存储 结合 顺序 . 即 如果 形 参数 组 的 一个 元素 与 实参 数组 一个 元素 在 非 分布 状态 下 存在 结合 关系 ， 则 当 两个 数组 都 分布 了 ， 这 两个 元素 仍应 满足 结合 关系 . 　 　 
 　 　 对于 对应 的 形 参数 组和 实参 数组 ， 其中 一个 数组 已知 数据分布 模式 ， 不失 一般性 ， 可以 假设 实参 数组 的 数据分布 模式 已知 ， 需要 导出 形 参数 组 的 分布模式 . 首先 ， 确定 实参 数组 分布 的 数据 块 的 大小 ， 即 实参 数组 被 分布 后 ， 被 分布 到 同一个 处理 节点 上 的 连续 的 数据 块 的 大小 ； 其次 ， 根据 分布 的 数据 块 的 大小 确定 形 参数 组 的 哪 一维 要 被 分布 ， 即 寻找 形 参数 组 的 某 一维 ， 假定 是 第 j 维 ， 它 满足 第 j 维 的 跨距 （ stride ） 小于 或 等于 被 分布 的 数据 块 的 大小 ， 但 第 j + 1 维 的 跨距 不 小于 被 分布 的 数据 块 的 大小 ； 然后 ， 根据 该维 元素 长度 和 被 分布 的 数据 块 的 大小 ， 确定 该维 的 分布模式 . 如果 不能 精确 地 确定 分布模式 的 变换 ， 则 相关 过程 的 调用 点 作为 一种 特殊 实体 ， 在 调用 点 的 前后 加入 动态 调整 参数 数组 分布模式 的 机制 . 
 　 　 采用 如下 的 方法 比较 两个 数组 的 数据分布 模式 是否 一致 ： 数组 A 具有 分布模式 DA ， 数组 B 具有 分布模式 DB ， 可以 假定 认为 A 和 B 是 对应 的 形 参数 组和 实参 数组 ， 其中 A 的 分布模式 （ DA ） 已知 ， 根据 前面 的 方法 求得 B 的 分布模式 DB ′ ， 如果 DB 和 DB ′ 相同 ， 则 认为 A 和 B 的 数据分布 模式 是 一致 的 . 
 3 　 优化 过程 调用 的 算法 
 　 　 在 上节 介绍 的 数据分布 映射 的 变换 基础 上 ， 我们 构造 以下 优化 过程 调用 的 算法 ： 
 　 　 　 ① 初始化 ： 展开 调用 图 ， 一个 静态 调用 点 对应 调用 图中 的 一个 节点 . 每个 节点 标记 为 未 被 分析 ， 并 依据 其 静态 估计 的 计算 量 、 调用 次数 等 ， 确定 其权值 . 对 每个 过程 ， 初始化 一个 pattern 的 集合 ， 每个 过程 对应 了 一个 集合 . 在 本 阶段 ， 每个 集合 均 为 空 . 
 　 　 　 ② 自顶向下 扫描 调用 图中 的 每个 节点 { / / 基本 信息 的 收集 和 传播 
 　 　 　 　 根据 上节 的 介绍 自顶向下 传播 已知 的 数据分布 信息 ； 
 将 过程 中 的 公用 量 根据 2.2 节 的 介绍 进行 分类 标记 ； 
 记录 ： ( a ) 与 数组 形 相关 的 形参 标量 ； ( b ) 形 参数 组 的 分布 形态 ； ( c ) 全局 数组 （ 公用 数组 ） 的 分布 形态 . 这 3 种 信息 是 对 调用 点 进行 分类 的 重要依据 . 将 这个 调用 点 加入 相应 的 pattern 集合 中 ， 收集 到 的 信息 标记 在 这个 节点 上 . 
 　 　 　 } 
 　 　 　 ③ 根据 每个 节点 权值 ， 从大到 小 ， 依次 选取 各个 节点 进行 分析 { 
 　 　 　 　 根据 这个 节点 已 被 标记 的 信息 ， 查询 这个 过程 已 被 分析 的 调用 点 ； 
 　 　 　 　 如果 有 一个 调用 点 p 的 信息 与 这个 节点 一致 （ 参见 定义 2 ） ， 且 那个 节点 已 被 标记 为 “ 已 分析 ” ， 则 将 这个 节点 标记 为 “ 复用 ” ， 且 指明 复用 节点 p . 
 　 　 　 　 否则 { 
 　 　 　 　 　 根据 已 收集 到 的 信息 ， 对 过程 进行 过程 内 分析 优化 ［ 4 ］ . 标记 这个 调用 点为 “ 已 分析 ” . 收集 在 分析 过程 中 新 获得 的 信息 ， 沿 调用 路径 向上 、 下 传播 新 收集 的 信息 { 
 　 　 　 　 　 　 如果 这个 调用 点 的 前驱 或 后继 节点 尚未 被 分析 ， 则 将 新 的 信息 加入 到 这个 节点 的 信息 集合 中 ； 
 　 　 　 　 　 　 如果 已到 根 节点 或 前驱 节点 的 标记 是 “ 已 分析 ” 或 “ 复用 ” ， 则 终止 向上 传播 ； 向下 传播 的 终止 条件 是 已 到 叶 节点 或 后记 节点 已 被 处理 过 ； 
 　 　 　 　 　 　 如果 向上 传播 不是 终止 于根 节点 或 向下 传播 不是 终止 于叶 节点 ， 而是 终止 于 某 一 节点 q ， { 
 　 　 　 　 　 　 　 　 如果 q 的 标记 是 “ 复用 ” ， 则 将 这个 调用 点 标记 为 “ 已 分析 ” ， 复制 其原 复用 节点 的 过程 内 分析 信息 ； 
 　 　 　 　 　 　 　 　 如果 q 的 标记 是 “ 已 分析 ” ， 且 有 其它 的 调用 点 复用 这个 调用 点 ， 将 该 过程 的 过程 内 信息 复制 ， 选择 一个 复用 q 的 节点 ， 将 其 标记 为 “ 已 分析 ” ， 将 过程 内 的 信息 挂 在 那个 节点 上 ， 并令 所有 复用 节点 q 的 调用 点 复用 那个 节点 . 
 　 　 　 　 } 
 　 　 　 } 
 　 　 } 
 　 } 
 　 　 　 ④ 以逆 拓扑 序 依次 处理 每个 过程 的 pattern 集合 { 
 　 　 　 　 对于 每个 pattern 集合 π ， 利用 小节 2 中 介绍 的 思想 对 其 元素 作 划分 ， 相互 一致 的 调用 点 被 分 在 同一个 子 集中 . 每个 子集 是 过程 的 一个 实例 ， 子 集中 的 调用 点 调用 这个 实例 . 
 　 　 　 } 
 　 　 　 ⑤ 在 代码生成 阶段 ， 根据上述 生成 的 子集 将 过程 实例 化 ， 并 对 相关 的 调用 点 做 换名 处理 . 
 　 　 调用 图中 的 每个 节点 主要 有 两组 数据项 ， 一组 是 记录 过程 内 的 数据分布 信息 ， 另一组 记录 与 过程 调用 点 分类 相关 的 数据 信息 . 前 一组 的 数据项 并 不是 每个 节点 都 填充 的 ， 只有 标记 为 “ 已 分析 ” 的 节点 才 会 填充 这组 数据项 ， 以 减少 存储 开销 . 
 　 　 我们 暂 不 考虑 “ 数据 再 分布 ” 的 问题 ， 因此 一个 数组 如果 被 分布 了 ， 则 该 数组 只 具有 一个 数据分布 映射函数 . 在 算法 的 第 ② 、 ③ 两步 中 ， 数据分布 模式 的 传播 主要 是 指 参数 数组 的 数据分布 模式 的 传播 . 
 　 　 　 　 Program   f 
 　 　 　 Dimension   a ( 100 , 100 ) , b ( 100 , 100 ) 
 C 　 distribution   a ( BLOCK , * ) ,   b ( * , BLOCK ) 
 　 　 …   … 
 s1 :   call   g ( a , … ) 
 　 　 …   … 
 s2 :   call   g ( b , … ) 
 　 　 …   … 
 s3 :   call   h ( a , … ) 
 　 　 …   … 
 end 
 
 subroutine   g ( c , … ) 
 　 　 dimension   c ( 100 , 100 ) 
 　 　 …   … 
 s4 :   do   m = 1 , 100 
 s5 :   do   n = 1 , 100 
 　 　 　 　 c ( m , n ) = … 
 　 　 　 enddo 
 　 　 enddo 
 　 　 …   … 
 end 
 
 subroutine   h ( d , … ) 
 　 　 dimension   d ( 100 , 100 ) 
 　 　 …   … 
 s6 :   call   g ( d , … ) 
 　 　 …   … 
 end 在 步骤 ② 结束 后 ， 每个 过程 的 pattern 集合 收集 了 这个 过程 的 所有 静态 调用 点 . 
 　 　 由于 在 数据 和 计算 划分 的 推导 中 ， 对 结果 产生 影响 的 是 在 分析 开始 时 参数 数组 和 全局 数组 （ 公用 数组 ） 等 所 具有 的 数据分布 模式 ， 只要 这些 信息 确定 了 ， 对于 同一 过程 体 的 数据 和 计算 划分 推导 所得 的 结果 也 是 确定 的 ， 因此 只要 判定 一个 未 被 分析 的 调用 点 已 具有 的 数据分布 信息 与 同一 过程 的 某个 已 分析 的 调用 点 相同 ， 就 可以 认为 这个 调用 点 可以 复用 已 分析 获得 的 信息 . 这种 处理 方法 可以 减少 过程 内 分析 次数 ， 提高 编译器 分析 的 效率 . 所以 在 步骤 ③ 中 ， 对 一些 节点 标记 为 “ 复用 ” ， 而 不再 作 进一步 的 分析 . 而且 在 文献 ［ 8 ］ 中 的 过程 内 算法 中 ， 一个 数组 只要 出现 在 被 并行 分割 的 循环 中 ， 这个 数组 必然 被 分布 了 ， 因此 在 步骤 ③ 中 对 新 获得 的 数据分布 信息 的 传播 ， 采用 遇到 已 处理 过 的 过程 调用 点 就 终止 的 方法 . 因为 如果 一个 调用 点 已 被 处理 过后 ， 对应 过程 的 某个 数组 仍 未 被 分布 ， 表明 该 数组 在 这个 过程 中 不 出现 在 任何 被 并行 分割 的 循环 中 ， 由于 其它 调用 点 的 分析 以及 数据分布 模式 的 传播 而 导致 这个 数组 可能 被 分布 ， 这 对 提高 目标程序 的 效率 并 没有 意义 ， 因此 算法 使得 分布模式 的 传播 在 此 终止 ， 而 在 相应 的 调用 点处 加入 通信 ， 以 维护 数据分布 的 一致性 . 
 　 　 在 步骤 ④ 中 ， 特别强调 一点 是 ： 若 一个 过程 p 的 两个 调用 点 分别 对应 于 不同 的 两个 实例 ， 则 p 的 这 两个 调用 点 所在 的 两个 调用者 q1 和 q2 也 必是 不同 的 过程 ， 或是 分别 对应 于 同一 过程 的 不同 实例 ， 除非 p 的 这 两个 调用 点 处于 同一 过程 体中 . 由 定义 2 可以 容易 地 得到 这个 结论 . 
 4 　 应用 举例 
 　 　 右例 是 一个 Fortran 程序 ， 其 对应 的 展开 的 程序 略图 如图 1 所示 . 
 
 图 1 　 展开 的 调用 图 
 　 　 假设 应用 程序员 指定 主程序 f 中 数组 a 的 第一 维 被 以 BLOCK 的 方式 分布 ， 数组 b 的 第二 维 被 以 BLOCK 的 方式 分布 . 这个 程序 中 对 过程 g 的 调用 共有 3 处 ： s1 ， s2 和 s6 ， 在 调用 图中 分别 以 g1 ， g2 ， g3 代表 . 进一步 假设 g 中 的 循环 s4 和 s5 都 是 可 并行 循环 . 通过 分析 ， 在 调用 点 s1 处 ， g 的 形 参数 组 c 获得 的 数据分布 模式 是 （ BLOCK ， * ） ， 在 调用 点 s2 处 获得 的 数据分布 模式 是 （ * ， BLOCK ） ， 在 调用 点 s6 处 ， 与 g 的 形 参数 组 直接 结合 的 是 h 的 形 参数 组 d ， d 的 数据分布 模式 继承 与 主程序 中 的 调用 点 s3 处 的 数组 a ， 可以 计算 出 在 s6 处 ， 形 参数 组 c 所 获得 的 数据分布 模式 是 （ BLOCK ， * ） ， 与 s1 处 相同 ， 因而 调用 点 s1 ， s6 可以 归为 一类 （ 如果 在 这 两个 调用 点 ， 所有 其它 影响 分类 的 信息 是 一致 的 ） ， 对应 的 g 的 实体 中 ， 循环 s4 将 被 分割 ； 调用 点 s2 是 单独 的 一类 ， 对应 的 g 的 实体 中 ， 循环 s5 将 被 分割 . 因此 ， 在 目标程序 中 过程 g 有 两个 过程 实例 ， 3 个 调用 点 根据上述 的 分析 分别 调用 这 两个 实例 ， 从而 得到 好 的 性能 . 而 过程 h 被 调用 一次 ， 因此 只有 一个 过程 实例 . 
 5 　 结 　 　 论 
 　 　 综上所述 ， 本文 所 介绍 的 方法 根据 过程 调用 点 的 上下文 的 不同 ， 将 过程 调用 进行 分类 ， 不同 的 类 调用 该 过程 的 不同 实例 ， 一方面 由于 不需 运行 时 在 调用 点处 处理 数据 映射 变换 的 问题 ， 从而 可以 显著 减小 过程 调用 的 开销 . 在 另一方面 ， 由于 每个 过程 实例 都 是 针对 一组 确定 的 相容 的 上下文 ， 因而 对 这个 过程 实例 进行 的 过程 内 并行 优化 分析 可以 更 精细 ， 从而 取得 更 高 的 并行执行 效果 . 过程 调用 实例 化 的 技术 对于 提高 并行 编译器 的 性能 是 有 重要 意义 的 . 
 本 课题 得到 国家 “ 八 六三 ” 高科技 计划 基金项目 和 国家 高性能 计算 基金项目 资助 . 
 作者简介 ： 冯晓兵 ， 男 ， 1969 年 11 月生 ， 博士 ， 主要 研究 方向 为 编译 技术 . 
 　 　 　 　 　 张兆庆 ， 女 ， 1938 年 11 月生 ， 研究员 ， 博士生 导师 ， 主要 研究 方向 为 并行 编译 及 工具 
 　 　 　 　 　 环境 . 
 作者 单位 ： 中国科学院计算技术研究所 高性能 中心 　 北京 　 100080 
 参考文献 
 　 1 　 Chau - WenTseng .   An   optimizing   fortran   D   compiler   for   MIMD   distributed - memory   machines ［ Ph   D   dissertation ］ ,   Rice   University ,   Houston   Texas ,   USA ,   1992 
 　 2 　 Lam   M   S .   Locality   optimization   for   parallel   machines .   In :   Third   Joint   International   Conf   on   Vector   and   Parallel   Processing ,   1994 
 　 3 　 Ken   Kennedy .   Compiler   technology   for   machine - independent   parallel   programming .   International   Journal   of   Parallel   Programming ,   1994 ， 22 ( 1 ) ： 79 ～ 98 
 　 4 　 Cooper   K   D ,   Hall   M   W ,   Ken   Kennedy .   A   methodology   for   procedure   cloning .   Computing   Language ， 1993 ， 19 ( 2 ) ： 105 ～ 117   
 　 5 　 Cooper   K   D ,   Kennedy   K ,   Torczon   L .   The   impact   of   interprocedural   analysis   and   optimization   in   the   Rn   programming   environment .   ACM   Trans   Programming   Language   Systems ,   1986 ， 8 ( 4 ) ：   491 ～ 523 
 　 6 　 Fortran   工作组 .   标准 Fortran   90 语言 程序设计 .   北京 ： 学苑 出版社 ， 1994 
 　 　 ( Fortran   Group .   Standard   of   Fortran   90 ( in   Chinese ) .   Beijing :   Xueyuan   Press ,   1994 ) 
 　 7 　 High   Performance   Fortran   Forum ,   High   Performance   Fortran   Language   Specification ,   Version   1.0 .   Houston :   Rice   University ,   1993 
 　 8 　 林   进 .   并行处理 系统 的 循环 分割 和 数据分布 技术 研究 ［ 博士论文 ］ .   中国科学院计算技术研究所 ，   北京 ， 1998 
 　 　 ( Lin   Jin ， Research   on   loops   and   data   distribution   for   SIMD   system ［ Ph   D   dissertation ］ .   Institute   of   Computing   Technology ,   the   Chinese   Academy   of   Sciences ,   Beijing :   1998 ) 
 原稿 收到 日期 ： 1999 - 02 - 10 ； 修改稿 收到 日期 ： 1999 - 05 - 22 . 
