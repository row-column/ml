软件 学报 
 JOURNAL   OF   SOFTWARE   
 1999 年   第 10 卷   第 5 期   Vol.10   No.5   1999 
 
 
 
 在 数据库 中 发现 具有 时态 约束 的 关联 规则 
 <   
 欧阳 为民 　 蔡 庆生 
 摘要 　   目前 , 国际 上 的 关联 规则 研究 尚未 考虑 时间 因素 . 然而 , 时间 是 现实 世界 的 固有 属性 , 许多 现实   世界 数据库 都 存在 时态 语义 问题 . 该文 考察 称为 有效 时间 的 时态 约束 问题 , 提出 了 时间 区间 延   展与 归并 技术 以及 新 的 时态 关联 规则 发现 算法 , 从而 进一步 推广 了 关联 规则 的 应用 . 
 关键词 　 知识 发现 , 关联 规则 , 时态 约束 . 
 中图法 分类号 　 TP311 
 　 　 Discovery   of   Association   Rules   with   Temporal   Constraint   in   Datab   ases 
 　 OU - YANG   Wei - min1 , 2 　 CAI   Qing - sheng2 
 1 （ Computing   Center 　 Anhui   University 　 Hefei 　 230039   ） 
 2 　 （ Department   of   Computer   Science 　 University   of   Science   and   Technolo   gy   of   China 　 Hefei 　 230027 ） 
 Abstract 　 　 Time   has   not   been   taken   into   account   in   the   current   international   researches   of   association   rules .   However ,   time   is   an   inherent   property   in   the   real   world .   Ther   e   exists   temporal   semantics   in   many   real   world   databases .   The   temporal   constrain   t   problem   called   valid   time   is   considered   in   this   paper .   Both   the   methods   for   ex   tending   and   merging   time   intervals   and   the   new   discovery   algorithm   for   temporal   association   rules   are   proposed .   Thus ,   the   application   of   association   rules   h   as   been   further   generalized . 
 　 　 在 数据库 中 发现 知识 ( knowledge   discovery   in   databases , 简称 KDD ) , 亦 称为 数据 发掘 (   data   mining ) , 是 当今 国际 上 人工智能 和 数据库 研究 方面 最富 活力 的 新兴 领域 . 其 目标 是 为了   满足用户 目标 , 自动 处理 大量 的 原始数据 , 从中 识别 重要 和 有 意义 的 模式 , 并 将 其 作为 知识 加   以 表达 ［ 1 , 2 ］ . 由于 其 强大 的 应用 潜力 以及 广泛 可用 的 存在 于 各种 数据库 中 的 大量 数   据 , 因此 , KDD 成为 一个 具有 迫切 现实 需要 的 很 有 前途 的 热点 研究课题 ［ 1 ］ . 
 　 　 关联 规则 是 美国 IBM   Almaden   Research   Center 的 Rakesh   Agrawal 等 人于 1993 年 首先 提   出 的 KDD 研究 中 的 一个 重要 课题 ［ 2 ］ . 所谓 关联 规则 是 这样 一个 逻辑 蕴涵 式 : X → Y ,   其中 X 和 Y 是 两个 不同 的 属性 集 . 关联 规则 的 直观 含义 是 对 数据库 中 的 所有 元组 , 如果 X 中 的 属   性值 为 真 , 那么 Y 中 的 属性 值 也 为 真 . 例如 , 计算机系 30% 的 学生 是 安徽 籍 , 而 数据库 中有 2% 的   学生 是 计算机系 且 是 安徽 籍 . 这里 , 30% 为 关联 规则 的 信任度 , 而 2% 为 关联 规则 的 支持 度 . 我们   所 要 发现 的 关联 规则 应 满足用户 指定 的 最低 支持 度 和 最低 信任度 约束 . 关于 关联 规则 的 发现   问题 , 目前 已有 若干 高效 算法 ［ 3 , 4 ］ . 
 　 　 在实践中 , 由于 时间 是 现实 世界 数据库 本身 固有 的 因素 , 所以 在 数据 中 常常 会 发现 时态 语   义 问题 . 时态 数据 的 出现 使 我们 有 必要 在 知识 发现 过程 中 考虑 时间 因素 . 在 现实 世界 数据库 中   可以 发现 各种各样 的 时态 数据 , 例如 , 超市 的 交易 记录 有 时间 标记 、 病员 的 病历 数据 记录 、 天   气 数据 日志 文件 等等 . 我们 这里 考察 的 时态 语义 是 所谓 的 时态 约束 问题 , 即 如果 数据库 中 的 每   个 元组 均 有 其 有效 时间 , 那么 在 数据库 中 所 发现 的 知识 也 必然 有 相应 的 时态 约束 , 以 表明 所 发   现 的 知识 何时 是 有效 的 . 目前 , 规则 事实上 都 是 假定 永远 有效 的 . 在 这种 情况 下 , 没有 任何 东西   表明 规则 何时 变得 有效 , 何时 又 被 认为 无效 . 同样 , 目前 无效 的 规则 也 没有 说明 它 在 过去 或 将   来 是否 有效 . 在 现实 中 , 附加 上 某种 时态 约束 的 规则 将 可以 更好 地 描述 客观现实 情况 , 因而 也   会 更 有 价值 . 在 现实生活 中 往往 存在 或 希望 带有 时态 约束 的 规则 , 我们 称 这种 关联 规则 为 时态   关联 规则 . 
 　 　 本文 第 1 节 给出 问题 描述 . 第 2 节 简要 描述 关联 规则 发现 算法 的 主要 思想 . 第 3 节 提出 发现   时态 关联 规则 的 有关 技术 , 并 给出 相应 的 算法 描述 . 第 4 节是 实验 结果 . 最后 是 结论 与 进一步 研   究 方向 . 
 1 　 问题 描述 
 　 　 为了 讨论 的 方便 , 我们 采用 关系 型 数据模型 . 不过 , 只 需 对 我们 在 本文 所 提出 的 方法 稍加 修改   即可 应用 于 其他 数据模型 , 如 扩展 的 关系 模型 、 面向对象 的 数据模型 . 令 R = { I1 , I2 , ... , I   m } 是 一 值域 为 { 0 , 1 } 的 属性 集 ( 也 称为 项目 集 ) . 与 知识 发现 任务 相关 的 数据 集 r = { t1 , t2   , ... , tn } 是 定义 在 关系 模式 { I1 , I2 , ... , Im } 上 的 一个 关系 , 即 元素 个数 为 m 的 二元 向   量 的 集合 . 
 　 　 我们 称 某 元组 t 支持 ( support ) 某 属性 A , 如果 元组 t 直接 包含 属性 A , 或者 属性 A 是 元组 t 的   某个 属性 值 的 先辈 , 记为 t ［ A ］ = 1 . 令 X  R 是 属性 子集 , t ∈ r 是 关系 的 某 一行 或 元组 . 如果 对 每   个 属性 A ∈ X 均 有 t ［ A ］ = 1 , 那么 我们 称 t 支持 X , 记 t ［ X ］ = 1 . 与 属性 集 X 匹配 的 元组 集记 为 supp   ort ( X ) = { t ∈ r | t ［ X ］ = 1 } . 关系 r 中 的 广义 关联 规则 形如 X → Y , 其中 X  R , Y  R ＼ X . 设 最低 信任   阈值 ( minimum   confidence   threshod ) 和 最低 支持 阈值 ( minimum   support   threshod ) 分   别为 γ 和 σ , 如果 有 | support ( X ∪ Y ) | ≥ σ n 且 | support ( X ∪ Y ) | / | support ( X ) | ≥ γ , 我们 称关   系 r 关于 最低 信任 阈值 γ 和 最低 支持 阈值 σ 满足 关联 规则 X → Y . 这就是说 , 关系 r 中 至少 有 σ n   行 元组 对 X 和 Y 中 的 所有 属性 均 为 1 , 且 在 对 属性 集 X 为 1 的 元组 中有 比例 为 γ 的 元组 对 属性 集 Y   也 为 1 . 对 任意 给定 的 属性 集 X , 如果 | support ( X ) | ≥ σ n , 其中 n 为 数据库 中 的 元组 数 , σ 为 最低   支持 阈值 , 那么 我们 称 X 是 频繁 的 . 也就是说 数据库 中 至少 有 比例 为 σ 的 元组 对 属性 集 X 为 1 . 
 　 　 由于 时间 是 现实 世界 的 固有 属性 , 许多 信息系统 都 存在 时态 语义 问题 . 本文 所 考虑 的 时态 语义   是 所谓 的 有效 时间 ( valid   time ) , 即 在 某 段时间 内 , 某 元组 是 有效 的 或 合法 的 . 这样 , 我们   在 具有 有效 时间 的 元组 集中 发现 的 关联 规则 也 必然 同样 具有 相应 的 有效 时间 , 关联 规则 因而   就 有 了 时效性 . 为此 , 我们 在 对 上述 问题 进行 描述 的 基础 上 增加 了 有效 时间 约束 一项 , 即 在 关   系 模式 中 增加 一个 有效 时间 valid － time 属性 , 规定 每个 元组 均 必须 附加 有效 时间 valid   － time 属性 . 于是 , 当 判断 某 元组 是否 支持 某 属性 A 时 , 由于 属性 A 是 附加 有效 时间 约束 的 , 所以   , 我们 必须 首先 判断 该 元组 的 有效 时间 是否 与 属性 A 的 有效 时间 匹配 . 只有 两者 的 有效 时间 是   匹配 的 , 才 可以 进一步 考虑 是否 支持 的 问题 . 也就是说 , 我们 将 判断 某 元组 是否 支持 某 属性 A 的   问题 分为 两个 子 问题 ： ( 1 )   元组 的 有效 时间 与 属性 A 的 有效 时间 是否 匹配 ； ( 2 )   未 附加 有效   时间 的 普通 元组 是否 支持 属性 A . 对于 第 2 个子 问题 , 我们 可以 采用 任何 一种 关联 规则 发现 算法   , 如 R . Agrawal 提出 的 Apriori 算法 中 的 方法 . 第 1 个子 问题 则 是 本文 要 解决 的 问题 . 
 2 　 关联 规则 发现 算法 Apriori 简介 
 　 　 关联 规则 的 发现 可 分为 如下 两个 子 问题 ［ 3 ］ ： 
 　 　 ( 1 )   寻找 所有 支持 度 不 低于 用户 指定 的 最低 支持 的 属性 组合 . 我们 称 这种 属性 组合 为频   繁 属性 序列 集 ； 
 　 　 ( 2 )   利用 频繁 属性 序列 集 生成 所 期望 的 规则 . 基本 方法 是 这样 的 , 比如说 ABCD 是 频繁 属性   序列 , 如果 support ( ABCD ) / support ( AB ) 不 低于 用户 指定 的 最低 信任度 γ , 那么 规则 AB → CD 成   立 . 注意 , 由于 ABCD 是 频繁 属性 序列 , 上述 规则 必定 具有 用户 指定 的 最低 支持 . 
 　 　 现在 , 我们 简要 描述 R . Agrawal 提出 的 寻找 所有 频繁 属性 序列 集 的 Apriori 算法 . 我们   以该 算法 作为 发现 具有 时态 约束 的 关联 规则 的 基础 . 令 K - 属性 序列 为 具有 K 个 属性 的 集合 , Fr   e ［ K ］ 为 频繁 K - 属性 序列 的 集合 , 而 C ［ K ］ 为 候选 K - 属性 序列 ( 即 可能 的 频繁 属性 序列 ) 的   集合 . Apriori 算法 需对 数据库 作 多次 遍历 , 每次 遍历 均 由 两个 阶段 构成 . 第 1 , 利用 上次 (   第 K - 1 次 ) 遍历 所 得到 的 频繁 ( K - 1 ) - 属性 序列 集 Fre ［ K - 1 ］ 生成 候选 K - 属性 序列 集 C ［ K ］ .   候选 生成 算法 Apriori － gen ［ 3 ］ 保证 C ［ K ］ 是 所有 频繁 K - 属性 序列 集 的 超集   . 第 2 , 对 数据库 作 一次 遍历 , 对 其中 的 每个 元组 确定 它 支持 C ［ K ］ 中 的 哪些 候选 , 并 在 相应 候   选 的 count 域 中 累计 支持 数 . 遍历 结束 后 , 检查 候选 集 C ［ K ］ , 确定 哪些 候选 是 频繁 的 , 从   而 构成 频繁 K - 属性 序列 集 Fre ［ K ］ . 该 算法 反复 进行 , 直到 Fre ［ K ］ 为 空时 为止 . 
 　 　 已知 频繁 ( K - 1 ) - 属性 序列 集 Fre ［ K - 1 ］ , 候选 生成 算法 Apriori － gen 返回 所有 频繁 K   - 属性 序列 集 的 超集 . 该 候选 生成 的 算法 思想 是 基于 这样 一个 观察 ： 频繁 属性 序列 的 任何 一   个 子集 均 是 频繁 的 . 该 候选 生成 算法 也 分为 如下 两步 ： 
 　 　 ( 1 )   链接 ( join ) , 即 Fre ［ L , K - 1 ］ 与 自己 链接 生成 C ［ L , K ］ . 
 Insert   into   C ［ L , K ］ 
 Select   p . item1 , p . item2 , ... , p . itemk - 1 , q . itemk - 1 
 From   p ∈ Fre ［ L , K - 1 ］ , q ∈ Fre ［ L , K - 1 ］ 
 Where   p . item1 = q . item1 , p . item2 = q . item2 , ... , p . itemk - 2 = q .   itemk - 2 , p . itemk - 1 < q . itemk - 1 , 
 　 　 ( 2 )   修剪 ( prune ) , 删除 C ［ L , K ］ 中 的 任何 一个 候选 c , 如果 c 中 存在 一个 长度 K - 1 属性 子集   不 属于 Fre ［ K - 1 ］ , 即 不是 频繁 的 . 
 　 　 上述 候选 生成 算法 的 正确性 请参阅 文献 ［ 2 ］ . 
 3 　 带 时态 约束 的 关联 规则 发现 算法 
 　 　 我们 在 现有 的 关联 规则 发现 算法 Apriori 的 基础 上 进行 扩展 , 以 处理 数据 的 时态 约束 问   题 , 从而 提出 时态 关联 规则 的 发现 算法 . 在 本文 的 扩展 的 数据库 中 , 与 普通 数据库 相比 , 这里 的   元组 均 多 了 一个 属性 值为 时间 区间 的 有效 时间 属性 , 以 体现 时态 约束 . 与 Apriori 算法 相比 , 我   们 的 算法 所用 的 候选 生成 方法 与 Apriori － gen 大体 相同 , 不同之处 在于 , 当 遍历 数据库 以   进行 候选 计数 时 , 两个 项目 序列 要 匹配 , 两者 的 相关 有效 时间 也 需 可 归并 . 我们 的 方法 是 首先   按照 一定 比例 ( 由 用户 根据 特定 的 应用领域 确定 该 比例 ) 延展 时间 区间 , 然后 再 按照 不同 情况   对 时间 区间 进行 归并 , 累计 支持 数 . 注意 , 此时 候选 的 数据结构 中 除了 项目 序列 域 itemset 和计   数器域 support 外 , 还要 增加 一个 有效 时间 域 valid － time , 以 表示 其 有效 的 时间 区间 . 
 3.1 　 时间 区间 的 延展 
 　 　 时间 区间 的 延展 是 指 将 其 两个 端点 向外 扩张 , 以期 使 两个 时间 区间 能够 相遇 或 交叠 , 然后   再 归并 为 同一个 时间 区间 . 其 问题 在于 如何 延展 时间 区间 . 一种 方法 是 将 所有 时间 区间 的 两个   端点 均 向 外 延伸 固定 的 长度 , 另 一种 方法 是 按 一定 比例 延展 时间 区间 . 当 采用 前 一 方法 时 , 我   们 无法 考虑 时间 区间 本身 的 长度 , 每个 时间 区间 一律 延伸 了 固定 的 长度 . 其 结果 是 , 有 的 区间   可能 扩展 了 20% , 而 有 的 区间 却 可能 扩展 了 100% . 于是 , 与 原来 较大 的 时间 区间 相比 , 原来 较 小   的 时间 区间 的 细节 信息 损失 较大 . 这 不 甚 合理 . 因此 , 我们 采用 后者 按 一定 比例 延展 时间 区间   的 方法 , 以 使 细节 信息 损失 对 不同 大小 的 时间 区间 是 均衡 的 . 在 时间 区间 的 延展 过程 中 , 细节   信息 的 损失 是 不可避免 的 , 这 与 在 利用 概念 层次 关系 进行 推广 时 细节 信息 也 有 损失 是 一致 的 .   
 　 　 时间 区间 的 两端 点向外 延伸 的 程度 由 表示 时间 区间 延展 程度 的 推广 因子 f 确定 . 该 推广 因   子 f 的 值 既 可以 由 算法 自动 设置 , 也 可 在 调用 本 算法 时 指定 . 然而 , 不管怎样 , 推广 因子 f 的 值应   根据 特定 应用领域 凭 经验 选取 . f 的 值 越 大 , 时间 区间 的 延展 就 越 快 , 结果 规则 中 细节 信息 的 损   失 就 越 多 ； 反之 , f 越小 , 时间 区间 的 延展 就 越慢 , 结果 规则 中 细节 信息 的 损失 就 越少 , 并且 由   于 因此 而 需要 更 多 的 独立 的 延展 , 算法 效率 就 降低 了 . 如果 时间 区间 在 时间轴 上 的 分布 是 稀疏   的 , 那么 在 归并 时间 区间 之前 要 对 其作 较大 的 延展 . 如果 时间 区间 在 时间轴 上 的 分布 是 稠密 的   , 那么 即使 对 时间 区间 作 不算 大 的 延展 , 也 很 可能 引起 细节 信息 的 迅速 损失 . 这些 问题 在 确定   推广 因子 f 的 值 时应 认真 加以 考虑 . 事实上 , 由于 事先 并不知道 推广 因子 f 的 值 多少 才 是 合适 的   , 因此 , 我们 一般 采取 试探性 的 办法 . 这样 , 推广 因子 f 的 值 若 设定 得 不 合适 也 就 在所难免 . 为了   发现 用户 真正 感兴趣 的 模式 , 必然 要 不断 地 调整 推广 因子 f 的 值 . 
 3.2 　 时间 区间 的 归并 
 　 　 给定 一 项目 序列 集合 , 该 集合 中 的 所有 项目 序列 的 项目 集均 相同 , 但 各自 的 有效 时间 区间   未必 相同 , 我们 的 目标 是 将 可以 归并 的 时间 区间 分别 合并 起来 , 并 累计 归并 后 在 同一时间 区间   内 彼此 匹配 的 项目 序列 的 个数 . 两个 时间 区间 的 归并 可 按 如下 4 种 基本 情况 分别 进行 ： 
 　 　 ( 1 )   区间 a 与 区间 b 相同 , 这 两个 区间 自然 地 可 并 为 一个 区间 a , 且 其 两个 端点 不变 ； 
 　 　 ( 2 )   区间 a ( i , j ) 与 区间 b ( m , n ) 相遇 , 即 j = m , 这 两个 区间 可 由 一个 新 区间 c ( i , n ) 替换 ； 
 　 　 ( 3 )   区间 a ( i , j ) 与 区间 b ( m , n ) 交叠 , 即 i 〈 m , j 〉 m 且 j < n , 这 两个 区间 可 由 一个 新 区间 c ( i ,   n ) 替换 ； 
 　 　 ( 4 )   区间 a ( i , j ) 包含 区间 b ( m , n ) , 即 i 〈 m 且 j 〉 n , 这 两个 区间 归结为 一个 区间 c ( i , j ) . 
 　 　 候选 项目 序列 计数 的 关键 不仅 在于 识别 出 除了 相关 的 时间 区间 不同 之外 , 其他 各个 项目   均 彼此 匹配 的 项目 序列 , 而且 还 在于 识别 上述 各种 时间 区间 之间 的 基本 关系 , 并 予以 归并 , 累   计 相互 匹配 的 项目 序列 的 个数 . 
 3.3 　 带有 时态 约束 的 关联 规则 发现 算法 描述 
 　 　 本 节 首先 给出 一个 例子 来 描述 具有 时态 约束 的 关联 规则 的 发现 方法 , 然后 再 给出 相应 的   算法 描述 . 
 　 　 设有 如表 1 所示 的 事务 数据库 , 其中 TID 为 事务 标识符 , Itemset 为 相应 事务所 包含 的 项目   子集 , Valid － time 为 相应 事务 的 有效 时间 , 假定 推广 因子 f = 1.5 . 我们 的 目标 是从 中 发现 具   有 有关 时态 的 关联 规则 . 发现 方法 是 在 Rakesh   Agrawal 的 Apriori 算法 中 结合 时间 区间 的   延展 与 归并 技术 . 对 候选 项目 序列 计数 , 不仅 要 识别 项目 序列 是否 匹配 , 而且 还要 识别 相应 的   时间 区间 是否 可以 归并 , 由此 统计 候选 项目 序列 的 支持 . 具体方法 如下 ： 
 表 1 　 样本 事务 数据库 
 
 TIDItemsetValid － time 
 100A , C , D ［ 40 , 70 ］ 
 200B , C , E ［ 60 , 90 ］ 
 300A , B , C , E ［ 90 , 120 ］ 
 400B , E ［ 30 , 50 ］ 
 500A , B , C ［ 400 , 500 ］ 
 
 　 　 ( 1 )   频繁 1 - 项目 序列 集 的 发现 
 　 　 首先 以 推广 因子 f = 1.5 推广 数据库 D 中 各 事务 的 有效 时间 , 再 以 所有 的 单个 项目 构成 候选   集 C1 = { { A } , { B } , { C } , { D } , { E } } , 遍历 数据库 , 得到 各 候选 项目 - 时间 对 的 集合 ：   
 　 　 　 　 　 　 Set ( A ) = { ( A , ［ 20 , 105 ］ ) , ( A , ［ 45 , 180 ］ ) , ( A , ［ 200 , 750 ］ ) } 
 　 　 　 　 　 　 Set ( B ) = { ( B , ［ 30 , 135 ］ ) , ( B , ［ 45 , 180 ］ ) , ( B , ［ 15 , 75 ］ ) , ( B , ［ 200 , 750 ］ ) } 
 　 　 　 　 　 　 Set ( C ) = { ( C , ［ 20 , 105 ］ ) , ( C , ［ 30 , 135 ］ ) , ( C , ［ 45 , 180 ］ ) , ( C , ［ 200 , 750 ］ ) 
 　 　 　 　 　 　 Set ( D ) = { ( D , ［ 20 , 105 ］ ) } 
 　 　 　 　 　 　 Set ( E ) = { ( E , ［ 30 , 135 ］ ) , ( E , ［ 45 , 180 ］ ) , ( E , ［ 15 , 75 ］ ) } 
 　 　 接着 统计 各 集合 中 时间 区间 可 彼此 归并 的 元素 对 个数 , 该值 即 为 相应 元素 对 的 支持 . Set ( A ) 中   的 两 元素 对 可 归并 为 ( A , ［ 20 , 180 ］ ) , 但 与 ( A , ［ 200 , 750 ］ ) 不可 归并 . 因此 , ( A , ［ 20 , 180 ］ )   的 支持 为 2 . 记 Set ( A ) 中 未能 归并 的 元素 对 的 集合 为 Rest ( A ) = { ( A , ［ 200 , 750 ］ ) } , 考察 它们 彼   此 是否 可 归并 , 由于 Rest ( A ) 中仅 有 1 个 元素 对 , 所以 该 元素 的 支持 只能 是 1 , 低于 最低 支持 , 应   予 删除 . 用 同样 的 方法 考察 Set ( B ) , Set ( C ) , Set ( D ) 和 Set ( E ) 可 得 ( B , ［ 15 , 180 ］ ) 的 支持 为 3 ；   ( C , ［ 30 , 180 ］ ) , 支持 为 3 ； ( D , ［ 20 , 105 ］ ) , 支持 为 1 ； ( E , ［ 30 , 180 ］ ) , 支持 为 3 . 取 支持 不   低于 最低 支持 2 的 元素 对 构成 频繁 1 - 项目 序列 集 L1 = { ( A , ［ 20 , 180 ］ ) , ( B , ［ 15 , 180 ］ ) , ( C   , ［ 30 , 180 ］ ) , ( E , ［ 30 , 180 ］ ) } . 
 　 　 ( 2 )   频繁 2 - 项目 序列 集 的 发现 
 　 　 根据 Apriori － gen 候选 生成 算法 , 我们 由此 可 导出 候选 2 - 项目 序列 集 C2 = { AB , A   C , AE , BC , BE , CE } . 遍历 数据库 , 得到 各 候选 项目 - 时间 对 的 集合 ： 
 　 　 　 　 　 Set ( AB ) = { ( AB , ［ 45 , 180 ］ ) , ( AB , ［ 200 , 750 ］ ) } 
 　 　 　 　 　 Set ( AC ) = { ( AC , ［ 20 , 105 ］ ) , ( AC , ［ 45 , 180 ］ ) , ( AC , ［ 200 , 750 ］ ) } 
 　 　 　 　 　 Set ( AE ) = { ( AE , ［ 45 , 180 ］ ) } 
 　 　 　 　 　 Set ( BC ) = { ( BC , ［ 30 , 135 ］ ) , ( BC , ［ 45 , 180 ］ ) , ( BC , ［ 200 , 750 ］ ) } 
 　 　 　 　 　 Set ( BE ) = { ( BE , ［ 30 , 135 ］ ) , ( BE , ［ 45 , 180 ］ ) , ( BE , ［ 15 , 75 ］ ) } 
 　 　 　 　 　 Set ( CE ) = { ( CE , ［ 30 , 135 ］ ) , ( CE , ［ 45 , 180 ］ ) } 
 与 上述 ( 1 ) 中 的 方法 相同 , 接着 统计 各 集合 中 时间 区间 可 彼此 归并 的 元素 对 个数 , 该值 即 为 相   应 元素 对 的 支持 , 取 支持 不 低于 最低 支持 2 的 元素 对 构成 频繁 2 - 项目 序列 集 L2 = { ( AC , ［ 20 ,   180 ］ ) , ( BC , ［ 30 , 180 ］ ) , ( BE , ［ 15 , 180 ］ ) , ( CE , ［ 30 , 180 ］ ) } . 
 　 　 ( 3 )   频繁 3 - 项目 序列 集 的 发现 
 　 　 根据 Apriori － gen 候选 生成 算法 , 我们 由此 可 导出 候选 2 - 项目 序列 集 C2 = { BCE }   , 注意 , 由于 项目 序列 ABC 的 子 序列 BC 不是 频繁 的 , 因而 被 修剪 了 . 遍历 数据库 , 得到 该 候选 项目   - 时间 对 的 集合 ： Set ( BCE ) = { ( BCE , ［ 30 , 135 ］ ) , ( BCE , ［ 45 , 180 ］ ) } . 容易 推知 , L3 = { ( BCE   , ［ 30 , 180 ］ ) } . 
 　 　 由于 L3 中 只有 1 个 元素 , 不能 生成 更长 的 候选 , 所以 算法 过程 结束 . 
 基于 上述 例子 , 我们 给出 如下 算法 描述 ： 
 　 　 Algorithm   TCAR : 带有 时态 约束 的 关联 规则 发现 算法 
 　 　 Input :   ( 1 )   DB 为 定义 在 R = { I1 , I2 , ... , Im , valid － time } 之上   的 某 关系数据库 , 其中 属性 Ii 的 值域 为 { 0 , 1 } , valid － time 为 相关 元组 的 合法 时间 区   间 ； 
 ( 2 )   minsup , minconf 和 f 分别 为 最低 支持 度 、 最低 信任度 和 推广 因子 ； 
 　 　 Output :   满足 最低 支持 度 和 最低 信任度 的 时态 关联 规则 . 
 　 　 Begin 
 　 　 　 ( 1 ) 　 L0 = { 1 } ;   / *   initialized   the   L0   * / 
 　 　 　 ( 2 ) 　 for   ( k = 1 ; Lk - 1 ≠  ; k ++ )   { 
 　 　 　 ( 3 ) 　 　 if   ( k = = 1 )   then   C1 = get － all － item ( D ) ;   / *   take   all   items   as   C1   * / 
 　 　 　 ( 4 ) 　 　 　 else   Ck = get － candidate － set ( Lk - 1   ) ;   / *   as   same   as   A   priori － gen   * / 
 　 　 　 ( 5 ) 　 　 for   each   t   transaction   t   in   D   do   { 
 　 　 　 ( 6 ) 　 　 　 if   ( k = = 1 )   then   generalize   the   t . valid － time   with   f ; 
 　 　 　 ( 7 ) 　 　 　 for   each   candidate   c ∈ Ck   do   
 　 　 　 ( 8 ) 　 　 　 　 if   ( t . itemset   matchs   c )   then   Set ( c ) = Set ( c ) ∪ { ( c , t . valid   － time ) } 
 　 　 　 ( 9 )   　 　 } 
 　 　 　 ( 10 )   　 for   each   candidate   c ∈ Ck   do 
 　 　 　 ( 11 )   　 　 while   | Set ( c ) | ＞ 1   do   { 
 　 　 　 ( 12 )   　 　 　 x = first － element ( Set ( c ) ) ; Set ( c ) = Set ( c ) - { x } ; 
 　 　 　 ( 13 )   　 　 　 while   | Set ( c ) | ≥ 1   do   { 
 　 　 　 ( 14 )   　 　 　 　 y = next － element ( Set ( c ) ) ; Set ( c ) = Set ( c ) - { y } ; 
 　 　 　 ( 15 )   　 　 　 　 if   y   can   be   merged   with   x   / *   by   the   methods   described   i   n   3.2   * / 
 　 　 　 ( 16 )   　 　 　 　 　 then   { x . valid － time = merge ( x . valid － time , y . valid － time   ) ; 
 　 　 　 ( 17 )   　 　 　 　 　 　 　 　 x . support ++ ; } 
 　 　 　 ( 18 )   　 　 　 　 　 else   Rest ( c ) = Rest ( c ) ∪ { y } ; 
 　 　 　 ( 19 )   　 　 　 　 } 
 　 　 　 ( 20 )   　 　 　 if   x . support ≥ minsup   then   Lk = Lk ∪ { x } ; 
 　 　 　 ( 21 )   　 　 　 Set ( c ) = Set ( c ) ; 
 　 　 　 ( 22 )   　 　 　 }   
 　 　 　 ( 23 )   　 　 } 
 　 　 　 ( 24 )   Discovered － Rule － set = ∪ K   get － rules ( Lk , minconf ) ; 
 　 　 End . 
 4 　 性能 测试 
 　 　 为了 测试 上 节 所述 算法 的 性能 , 我们 在 PC   586 / 166 ( 32M 内存 ) 上用 Visual   FoxPro1.0 实现 了 该   算法 . 合成 数据 的 生成 方法 与 IBM   Almaden 研究 中心 Rakesh   Agrawal 教授 领导 的 KDD 研究 小组   所 采用 的 方法 类似 ( 参见 http : ∥ www . almaden . ibm . com / cs / quest / syndata . html # AssocSynDa   ta ) , 只是 增加 了 一个 有效 时间 属性 . 合成 事务 数据库 的 生成 参数 如下 ： ( 1 )   事务 个数 D 为   200 ； ( 2 )   事务所 含 项目 集 的 平均 大小 T 为 5 ； ( 3 )   最大 频繁 项目 序列 的 平均 大小 I 为   3 ； ( 4 )   事务 数据库 中所含 项目 的 个数 N 为 20 ； ( 5 )   最低 支持 minsup 为 10% . 为 测试 算   法 的 扩放性 , 我们 逐次 递增 事务 个数 , 从 500 起 , 每次 递增 500 , 分 6 次 , 递增 到 3500 , 相应 的 性能   曲线 如图 1 所示 . 实验 结果表明 , 该 算法 设计 正确 , 并 具有 良好 的 可 扩放性 . 
 5 　 结论 与 进一步 的 工作 
 　 　 时间 是 现实 世界 的 固有 属性 , 许多 现实 数据库 都 存在 时态 语义 问题 . 本文 考虑 的 时态 语义   是 所谓 的 有效 时间 ( valid   time ) , 即 某 元组 在 某 时间 区间 内 是 有效 的 . 这样 , 我们 在 具有 有效   时间 的 数据 集中 发现 的 关联 规则 也 必然 同样 具有 相应 的 有效 时间 , 关联 规则 因而 也 就 有 了 时   效性 . 为此 , 我们 在 Rakesh   Agrawal 提出 的 Apriori 算法 的 基础 上 , 结合 我们 提出 的 时间 区间 延   展与 归并 技术 , 得到 新 的 能够 处理 具有 时态 约束 的 关联 规则 发现 算法 . 
 　 　 本文 所 考虑 的 时态 语义 单一 , 仅 考虑 了 时间 区间 的 时态 约束 问题 , 下 一步 将 研究 其他 类型   ( 如 周期性 变化 ) 的 时态 约束 问题 . 
 致谢 　 本文 工作 得到 了 国际 KDD 研究 知名 学者 加拿大 Simon   Fraster   大学 Han   Jiawei 教授 和 美国 IBM   Almaden   Research   Center 的 Rakesh   Agrawal 教授 的 支   持 , 他们 为 笔者 提供 了 有关 的 研究 资料 , 特此 表示感谢 . 
 　 
 本文 研究 得到 国家自然科学基金 和 安徽省 教委 科研 基金 资助 . 
 作者 欧阳 为民   , 1964 年生 , 博士 , 副教授 , 主要 研究 领域 为 KDD , 机器 学习 , 人工智能 及其 应用 . 
 　 　 　 蔡 庆生 , 1938 年生 , 教授 , 博士生 导师 , 主要 研究 领域 为 机器 学习 , 知识 发现 , 人工   智能 . 
 　 　 　 本文 通讯联系 人 ： 欧阳 为民 , 合肥   230039 , 安徽大学 计算中心 
 作者 单位 ： 欧阳 为民 （ 安徽大学 计算中心 　 合肥 　 230039 ） 
 　 　 　 　 　 　 欧阳 为民 　 蔡 庆生 （ 中国 科学技术 大学 计算机科学 系 　 合肥 　 230027 ） 
 　 　 　 　 　 E - mail :   oywm @ mars . ahu . edu . cn 
 参考文献 
 　 [ 1 ] 　 Piatetsky - Shapiro   G .   Discovery ,   analysis ,   and   presentation   of   strong   rules .   In :   Piatetsky - Shapiro   G ,   Frawlay   W   J   eds .   Knowledge   Discovery   in   Databa   ses .   Cambridge ,   MA :   AAAI / MIT   Press ,   1991 .   229 ～ 238 
 　 [ 2 ] 　 Agrawal   R ,   Imielinski   T ,   Swami   A .   Mining   association   rules   between   sets   of   items   in   large   databases .   In :   Proceedings   of   the   1993   ACM － SIGMOD   Internationa   l   Conference   on   Management   of   Data .   Washington ,   DC ,   1993 .   207 ～ 216 
 　 [ 3 ] 　 Agrawal   R ,   Srikant   R .   Fast   algorithm   for   mining   association   rules .   In :   Proc   eedings   of   the   1994   International   Conference   on   Very   Large   Data   Bases .   Santiago ,   Chile ,   1994 .   487 ～ 499 
 　 [ 4 ] 　 Mannila   H ,   Toivonen   H ,   Verkamo   A   Inkeri .   Efficient   algorithms   for   discoveri   ng   association   rules .   In :   Proceedings   of   AAAI   Work   Shop   Knowledge   Discovery   in   D   atabases .   1994 .   181 ～ 192 
 本文 1997 - 11 - 20 收到 原稿 , 1998 - 05 - 28 收到 修改稿 
