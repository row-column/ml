软件 学报 
 JOURNAL   OF   SOFTWARE 
 1999 年   第 10 卷   第 7 期 　 No.7   Vol.10   1999 
 
 
 
 算法 框架 : 算法 重 定位 的 一种 可 操作 的 方法 
 栾尚敏 　 李 　 未 　 马绍汉 
 　 　 摘要 　 算法 框架 是 实现 算法 重 定位 的 一种 可 操作 的 方法 . 文章 给出 了 算法 重 定位 的 定义 , 讨论 了 如何 通过 选择 操作 和 组合 操作 来 设计 算法 框架 . 然后 给出 了 定义 选择 操作 和 组合 操作 的 一种 方法 . 由 文章 所 定义 的 算法 框架 得到 求解 某一 问题 的 算法 模式 , 从 该 算法 模式 就 可以 生成 求解 该 问题 的 算法 . 文章 最后 讨论 了 算法 框架 和 算法 模式 以及 模块化 算法 之间 的 关系 . 研究 算法 重 定位 及其 可 操作 的 方法 对 软件 自动化 和 机器 学习 有着 重要 的 意义 . 
 　 　 关键词 　 算法 设计 , 软件 自动化 , 算法 重 定位 . 
 　 　 中图法 分类号 　 TP301 
 Algorithm   Framework :   an   Operational   
 Approach   to   Algorithm   Relocation 
 LUAN   Shang - min1   LI   Wei1   MA   Shao - han2 
 1 ( Department   of   Computer   Science   and   Engineering   Beijing   University   of   Aeronautics   and   Astronautics   Beijing   100083 ) 
 2 ( Department   of   Computer   Science   Shandong   University   Ji ' nan   250100 ) 
 　 　 Abstract 　   Algorithm   framework   is   an   operational   approach   to   algorithm   relocation .   In   this   paper ,   the   authors   present   the   definition   of   algorithm   relocation   and   an   algorithm   framework   based   on   selection   operator   and   combination   operator .   The   authors   discuss   how   to   design   selection   operator   and   combination   operator .   The   algorithm   for   a   given   problem   can   be   obtained   from   the   algorithm   schema ,   which   is   obtained   from   the   algorithm   framework   presented   in   this   paper .   The   relationship   between   algorithm   framework   and   algorithm   schema   and   the   relationship   between   algorithm   framework   and   modular   algorithm   are   discussed   as   well .   Algorithm   relocation   and   its   operational   approach   are   significant   for   software   automation   and   machine - learning . 
 　 　 Key   words 　 Algorithm   design ,   software   automation ,   algorithm   relocation . 
 　 　 算法 设计 自动化 是 软件 自动化 的 难点 和 关键 . 算法 设计 是 一种 知识 高度 密集 的 创造性 活动 , 要 实现 算法 设计 自动化 , 难度很大 . 在 算法 自动 或 半自动 生成 方面 虽然 取得 了 一定 的 进展 ［ 1 ～ 4 ］ , 但是 , 这些 方法 只能 生成 具有 特定 结构 的 算法 , 例如 循环 算法 和 递归 算法 , 或 只能 生成 特定 领域 的 算法 , 而 目前 还 没有 一种 生成 通用 算法 的 方法 . 
 　 　 L ［ 1 ］ 在 半自动 生成 算法 的 系统 NDADAS ( ND   algorithm   design   automation   system ) 中 采用 了 问题归约 的 方法 , 用 这种 方法 可以 生成 具有 特定 结构 的 算法 , 例如 循环 算法 和 递归 算法 等 . Helman ［ 2 ］ 给出 了 搜索 问题 的 一种 描述 方法 和 该类 问题 的 一个 算法 模式 , 讨论 了 如何 通过 该 算法 模式 得到 求解 具体 问题 的 动态 规划 和 分枝 限界 算法 . 我们 进一步 推广 了 Helman 的 方法 , 给出 了 求解 问题 的 一个 算法 模式 ［ 3 ］ . 通过 该 算法 模式 , 我们 不仅 可以 得到 动态 规划 和 分枝 限界 算法 , 而且 可以 得到 贪心 和 回溯 算法 . 而后 , 我们 ［ 4 ］ 又 给出 了 一个 算法 模式 来 得到 求解 问题 的 混合 算法 , 但 采用 这种 方法 来 实现 算法 的 自动 设计 只能 限制 在 一定 领域 内 . 
 　 　 本文 从 算法 重 定位 的 角度 来 讨论 如何 实现 算法 自动化 . 首先 给出 了 算法 重 定位 的 定义 , 讨论 了 算法 框架 的 设计 , 以及 如何 由 策略 控制关系 和 变换 来 定义 横向 组合 操作 和 纵向 组合 操作 . 由 算法 框架 可以 得到 求解 某一 问题 的 算法 模式 , 再 由 这个 算法 模式 得到 求解 该 问题 的 算法 , 所以 ， 文献 ［ 2 ～ 4 ］ 中 所 定义 的 算法 模式 可以 由 本文 所 给出 的 算法 框架 得到 . 本文 最后 讨论 了 算法 框架 和 模块化 算法 ［ 5 ］ 之间 的 关系 . 算法 框架 是 算法 重 定位 的 一种 可 操作 的 方法 , 研究 算法 重 定位 及其 可 操作 的 方法 对 实现 算法 设计 的 自动化 和 机器 学习 有着 重要 的 意义 . 
 　 　 本文 以 优化 代码 问题 为例 进行 讨论 . 设有 n 个 元素 a1 , a2 , ... , an , 每 一个 ai 对应 着 一个 数值 , 记为 d ( ai ) , 1 ≤ i ≤ n , 试 构造 一个 二叉树 , 这个 二叉树 以 这 n 个 元素 为叶 节点 , 使 Li * d ( ai ) 最小 . 这里 , Li 是从 根 节点 到 标记 为 ai 的 叶 节点 的 路径 长度 . 
 1   算法 重 定位 的 定义 和 算法 框架 的 设计 
 　 　 在 讨论 算法 重 定位 和 算法 框架 之前 , 我们 首先 讨论 问题 的 结构 和 问题 的 实例 , 也就是说 如何 来 描述 一个 问题 及其 实例 . 需要 说明 的 是 , 本文 所 给出 的 算法 框架 并 不 依赖于 这里 所 给出 的 问题 的 描述 方法 的 , 只是 为了 方便 叙述 和 讨论 . 
 　 　 定义 1.1 ( 问题 的 结构 ) .   用 二元 组 P = 〈 A , Q 〉 来 描述 问题 的 结构 , 这里 , A 是 原子 的 集合 . 用 MS 表示 求解 过程 中 产生 的 所有 中间 结果 的 集合 , 它 可以 是 二叉树 的 集合 , 也 可以 是 一个 串 的 集合 , 或是 一个 集合 的 集合 等等 . Q 是 解 的 集合 . 
 　 　 定义 1.2 ( 问题 的 实例 ) .   用 四元组 〈 P , I , ∝ , d 〉 来 描述 问题 的 实例 . 这里 , P 是 问题 的 结构 , 如上所述 ; I 是 初始状态 的 集合 ; ∝ 是 一个 Q 上 的 偏序 关系 ; d 是 一个 辅助 集合 , 在 某些 问题 中 它 用来 存放 描述 问题 的 数据 , 例如 货郎担 问题 和 优化 代码 问题 . 在 某些 问题 中 也 用来 存放 其他 内容 , 例如 , 在 SAT 问题 中 它 是 子句 的 集合 . 
 　 　 下面 , 我们 以 优化 代码 问题 为 例来 说明 如何 用 这种 描述 问题 的 方法 描述 具体 问题 . 
 　 　 　 　 　 　 　 　 A = { a1 , a2 , ... , an } 
 　 　 　 　 　 　 　 　 Q = { t | t 是 以 a1 , a2 , ... , an 为叶 节点 的 二叉树 } 
 　 　 　 　 　 　 　 　 I = { a1 , a2 , ... , an } 
 用 d 来 存放 a1 , a2 , ... , an 的 值 . 为了 定义 偏序 关系 ∝ , 还应 定义 MS 上 的 一个 函数 f 如下 : 
 　 　 设 A ′ A , t 是 以 A ′ 中 的 元素 为叶 节点 的 二叉树 , 则 
 　 　 　 　 　 　 　 　 
 　 　 设 t1 , t2 ∈ Q , 若 f ( t1 ) ≤ f ( t2 ) , 则 t1 ∝ t2 . 
 　 　 定义 1.3 ( 算法 重 定位 ) .   对于 求解 某一 具体 问题 的 算法 , 我们 可以 对 它 进行 修改 , 从而 改变 求解 问题 的 方法 , 或者 使得 修改 后 的 算法 成为 求解 另 一个 问题 的 算法 , 对 算法 的 这种 修改 称为 算法 重 定位 . 
 　 　 从 算法 重 定位 的 定义 可以 看到 , 对于 求解 某一 问题 的 算法 , 我们 可以 对 它 进行 修改 , 使 求解 问题 的 方法 发生 了 改变 , 但 该 算法 仍然 是 求解 原 问题 的 算法 , 这种 修改 是 算法 重 定位 . 对于 一个 算法 , 我们 可以 通过 对 它 的 修改 , 使 它 成为 求解 另 一 问题 的 算法 . 不论 求解 问题 的 方法 是否 改变 , 这种 修改 也 是 算法 重 定位 . 
 　 　 直观 上 讲 , 对于 一个 算法 , 我们 只要 修改 它 的 某些 部分 , 就 可以 使 求解 问题 的 方法 发生 改变 , 或者 使 它 成为 求解 另 一个 问题 的 算法 . 例如 , 在 下面 的 过程 中 
 　 　 Step1 .   MS = I . 
 　 　 Step2 .   若 不 存在 t1 使得 R1 ( t1 ) 成立 , 则 停机 . 否则 从 MS 中 选择 一个 二叉树 t1 , 使得 R1 ( t1 ) 成立 . 
 　 　 Step3 .   S 是 MS 的 一个 子集 , 并且 S 中 的 任意 一个 二叉树 t2 , R2 ( t2 ) 成立 . 
 　 　 Step4 .   S 中 的 每 一个 二叉树 t2 , 构造 一个 二叉树 t , 使得 t1 和 t2 分别 是 t 的 左 儿子 和 右 儿子 , MS = MS + { t } . 
 　 　 Step5 .   GOTO   Step   2 . 
 　 　 设 I 是 上面 所述 的 代码优化 问题 中 所 定义 的 初始状态 的 集合 . 若以 如下 方式 定义 R1 和 R2 : 
 　 　 若 t1 不是 MS 中 其他 任何 树 的 子树 , 并且 满足 这种 条件 的 树 中 t1 的 代价 最小 , 则 R1 ( t1 ) 成立 ; 
 　 　 若 t2 不是 MS 中 其他 任何 树 的 子树 , 并且 满足 这种 条件 的 树 中 t2 的 代价 次 小 , 则 R2 ( t2 ) 成立 , 
 就 得到 代码优化 问题 的 贪心 算法 . 
 　 　 若 以 如下 方式 定义 R1 和 R2 : 
 　 　 若 在 MS 中 存在 树 t , t1 和 t 没有 公共 的 元素 作为 叶 节点 , 分别 以 t 和 t1 作为 左 儿子 和 右 儿子 的 树 不 存在 于 MS 中 , 并且 t1 的 代价 比 MS 中 任何 一个 满足 如下 条件 的 树 t3 的 代价 小 : t3 以 A 中 的 n 个 元素 作为 叶 节点 , 则  R1 ( t1 ) 成立 ; 
 　 　 对于 t2 ∈ MS , 若 t2 的 代价 比 MS 中 任何 一个 满足 如下 条件 的 树 t3 的 代价 小 : t3 以 A 中 的 n 个 元素 作为 叶 节点 , 则 R2 ( t2 ) 成立 ， 
 就 得到 代码优化 问题 的 分枝 - 限界 算法 . 
 　 　 如果 有 一种 方法 能 描述 出 各种 算法 的 这些 不同 的 地方 , 那么 要 修改 一个 算法 就 成为 一件 很 容易 做到 的 事情 . 如何 来 描述 这些 不同 的 地方 呢 ? 这 将 在下文 加以 叙述 . 
 　 　 在 上面 的 过程 中 , Step   2 是从 MS 中 选择 一个 满足 一定 条件 的 元素 t1 , 我们 称 这 一 过程 为 选择 操作 . Step   3 是从 MS 中 选择 一个 满足 一定 条件 的 元素 t2 , Step   4 是 执行 变换 tr ( t1 , t2 ) ; 我们 把 执行 Step   3 和 Step   4 的 过程 称为 组合 操作 . 下面 给出 选择 操作 和 组合 操作 的 准确 定义 . 
 　 　 设 A 是 一个 集合 , 用 2A 表示 集合 A 的 幂集 , 即 集合 A 的 所有 子集 组成 的 集合 . 
 　 　 定义 1.4 ( 选择 操作 ) .   称 部分 函数 OP : 2MS → MS 是 一个 选择 操作 , 如果 OP 满足 : x ∈ 2MS , OP ( x ) ∈ x . 所有 的 选择 操作 组成 的 集合 记为 SS . 这里 , MS 是 求解 过程 中 产生 的 中间 结果 的 集合 . 
 　 　 定义 1.5 ( 组合 操作 ) .   称 部分 函数 COP : MS × 2MS → 2MS 是 一个 组合 操作 , 所有 的 组合 操作 组成 的 集合 记为 CS . 这里 ， MS 是 在 求解 过程 中 所 产生 的 中间 结果 的 集合 . 
 　 　 下面 我们 给出 基于 选择 操作 和 组合 操作 的 一个 算法 框架 . 
 　 　 alframework ( ) 
 　 　 　 begin 
 　 　 　 　 MS = I ; 
 　 　 　 　 while   ( not   complete ( MS ) )   do 
 　 　 　 　 　 begin 
 　 　 　 　 　 　 select1   ( SS , ) ; 
 　 　 　 　 　 　 select2   ( CS , ) ; 
 　 　 　 　 　 end 
 　 　 　 end 
 　 　 end ( alframework ) 
 这里 ， 是 一个 集合 , 根据 中 的 内容 决定 采用 哪 种 选择 操作 和 组合 操作 . 下面 我们 将 详细 说明 如何 通过 该 算法 框架 得到 求解 具体 问题 的 算法 . 
 2   定义 组合 操作 和 选择 操作 的 一种 方法 
 　 　 在 第 1 节 我们 曾经 指出 , 若能 对 各种 算法 的 不同之处 给出 一种 准确 的 描述 , 就 可以 很 容易 地 实现 算法 的 重 定位 . 下面 将 讨论 这个 问题 . 
 　 　 定义 2.1 ( 选择 控制关系 ) .   设 # 是 MS 上 的 一个 二元关系 , 且 满足 对于 任意 的 t1 , t2 ∈ Q , t1 # t2 当且 仅 当 t1 ∝ t2 , 则 称 # 为 关于 ∝ 的 选择 控制关系 . 
 　 　 定义 2.2 ( 组合 控制关系 ) .   设是 MS 上 的 一个 二元关系 , 且 满足 对于 任意 的 t1 , t2 ∈ Q , t1 ∝ t2 成立 , 则 t2 # t1 一定 不 成立 , 称 # 为 关于 ∝ 的 组合 控制关系 . 
 　 　 定义 2.3 ( 变换 ) .   若 部分 函数 tr 是 MS × MS → MS 的 一个 函数 , 则 称 这个 部分 函数 tr 为 变换 . 用 tr 或 其下 标的 形式 来 表示 . 
 　 　 定义 2.4 ( 策略 控制关系 ) .   设 # , 分别 是 关于 ∝ 的 选择 控制关系 和 组合 控制关系 , 则 称序 对 〈 # , 〉 为 策略 控制关系 . 
 　 　 下面 以 货郎担 问题 为 例来 说明 如何 定义 一个 具体 问题 的 某种 求解 方法 的 策略 控制关系 和 变换 . 关于 货郎担 问题 的 详细描述 请 参见 文献 ［ 6 ］ . 要 详细 地 描述 货郎担 问题 的 分枝 - 限界 方法 , 需 定义 如下 策略 控制关系 和 变换 . 
 　 　 选择 控制关系 # : 设 t1 ∈ MS , t2 ∈ Q , 若 t2 的 边权 之 和 小于 t1 的 边权 之 和 , 则 t2 # t1 . 
 　 　 组合 控制关系 : 设 t1 ∈ MS , t2 ∈ Q , 若 t2 的 边权 之 和 小于 t1 的 边权 之 和 , 则 t2 # t1 . 
 　 　 变换 tr ( t1 , t2 ) : 将 路径 之 和 合并 为 一个 路径 . 
 　 　 货郎担 问题 的 分枝 - 限界 算法 的 选择 控制关系 和 组合 控制关系 是 相同 的 , 但 在 很多 情况 下 , 它们 也 是 不同 的 , 例如 该 问题 的 动态 规划 算法 . 这里 还有 两个 问题 需要 说明 . ( 1 )   对于 某些 具体 问题 的 算法 , 有 的 并 不 非要 定义 其 选择 控制关系 和 组合 控制关系 不可 , 如 SAT 问题 的 GSAT ［ 7 ］ 算法 , 只 定义 其 组合 控制关系 就行了 , 因为 其 当前 解 很 明显 , 就是 最近 得到 的 n 维 向量 . ( 2 )   组合 控制关系 有时 是 依赖于 当前 解 的 , 这个 关系 在 不同 的 时刻 可能 不同 . 下面 给出 的 这 两个 选择 操作 和 组合 操作 说明 了 如何 用 策略 控制关系 来 定义 选择 操作 和 组合 操作 . 
 　 　 
 　 　 根据 定义 可以 很 容易 地 证明 如下 性质 . 
 　 　 性质 2.1 .   OP1 和 OP2 是 选择 操作 . 
 　 　 性质 2.2 .   COP1 和 COP2 是 组合 操作 . 
 　 　 并 不是 所有 的 算法 都 可以 通过 这里 定义 的 两个 选择 操作 和 两个 组合 操作 而 得到 , 但 可以 定义 一些 新 的 选择 操作 和 组合 操作 得到 所 需要 的 算法 . 在 定义 一种 选择 操作 或 组合 操作 时 , 应 尽量 使 所 定义 的 选择 操作 或 组合 操作 适用 的 情况 多一些 , 而 不是 只 适用 于 一种 情况 . 由 这里 定义 的 两个 选择 操作 和 两个 组合 操作 可以 得到 4 种 算法 模式 . 
 3   算法 重 定位 的 实现 
 　 　 本 节 讨论 如何 由 上 一节 的 算法 框架 来 实现 算法 重 定位 , 也就是说 , 如何 通过 上述 的 算法 框架 来 得到 求解 具体 问题 的 算法 . 若 选择 操作 和 组合 操作 如 第 2 节所 定义 , 则 算法 框架 中 的 变量 中 的 内容 为 策略 控制关系 . 根据 中 的 策略 控制关系 确定 选用 哪 种 选择 操作 和 组合 操作 , 这样 也 就 确定 了 一种 算法 模式 , 再 对 算法 模式 中 的 变量 和 未定义 的 函数 给出 定义 ， 就 得到 了 求解 具体 问题 的 算法 . 例如 ， 要 得到 货郎担 问题 的 分枝 限界 算法 , 根据 我们 定义 的 分枝 - 限界 方法 的 选择 控制 函数 和 组合 控制 函数 , 需要 选择 OP1 ( MS ) 和 COP1 ( MS ) 来 作为 选择 操作 和 组合 操作 , 可 得到 如下 的 算法 模式 . 
 　 　 algorithm   HL 
 　 　 　 begin 
 　 　 　 　 MS = I ; 
 　 　 　 　 while   ( not   complete ( MS ) )   do 
 　 　 　 　 　 begin 
 　 　 　 　 　 　 t = OP1 ( MS ) ; 
 　 　 　 　 　 　 MS = COP1 ( t , MS ) ; 
 　 　 　 　 　 end 
 　 　 　 end ( algorithm ) 
 　 　 若 Λ 和 Δ 中 分别 包含 第 2 节中 定义 的 货郎担 问题 的 分枝 - 限界 方法 的 选择 控制关系 和 组合 控制关系 , complete ( MS ) 的 定义 同 文献 ［ 4 ］ 给出 的 定义 , 再 定义 该 算法 模式 中 的 变量 S1 ( MS , Λ , d ) ; S2 ( MS , Δ , t , B , d ) ; S3 ( MS , Δ , TS , T , t ) ; S4 ( MS , Δ , T , t ′ ) 就 得到 求解 货郎担 问题 的 分枝 - 限界 算法 . 定义 如下 . 
 　 　 S1 ( MS , Λ , d ) : 从 MS 中 任意 选择 一个 元素 . 
 　 　 S2 ( MS , Λ , t , B , d ) : 从 MS 和 Λ 中 分别 选择 一个 元素 和 一个 选择 控制关系 , 直到 已 取遍 了 MS 和 Λ 中 的 所有 元素 时为 null . 
 　 　 S3 ( MS , Δ , TS , T , t ) : 从 MS 中 任意 选择 一个 元素 , 且 不 存在 一个 A 中 的 原子 , 该 原子 同时 存在 于 上述 元素 和 t 中 , 直到 取遍 了 MS 中 满足 上述 条件 的 路径 时为 null ; 并且 也 选择 一个 变换 作为 返回值 的 一部分 . 
 　 　 S4 ( MS , Δ , T , t ′ ) : 从 MS 和 Λ 中 分别 选择 一个 元素 和 一个 选择 控制关系 , 直到 已 取遍 了 MS 和 Λ 中 的 所有 元素 时为 null . 
 　 　 只要 选取 选择 操作 OP2 和 组合 操作 COP1 , 再 给出 策略 控制关系 的 适当 定义 就 可以 得到 求解 SAT 问题 的 GSAT ［ 7 ］ 算法 了 , 并且 通过 算法 框架 也 可以 得到 混合 算法 . 限于 篇幅 , 不再 详细 讨论 . 通过 上面 的 例子 可以 看到 如何 通过 算法 框架 来 实现 算法 重 定位 . 
 4   讨   论 
 　 　 前面 给出 了 算法 重 定位 的 定义 , 讨论 了 如何 由 选择 操作 和 组合 操作 来 设计 算法 框架 , 以及 如何 由 算法 框架 得到 求解 具体 问题 的 算法 . 这里 首先 说明 如何 用 面向对象 的 方法 编程 实现 . 首先 建立 一个 类 , 该类 对应 着 算法 框架 , 然后 对于 不同 的 选择 操作 和 组合 操作 , 定义 不同 的 子类 , 这样 就 得到 了 不同 的 算法 模式 . 对于 算法 模式 的 编程 实现 问题 , 在 文献 ［ 3 , 4 ］ 中 都 给予 了 讨论 , 文献 ［ 6 ］ 还 用 C++ 实现 了 一个 系统 . 限于 篇幅 , 这里 不再 多述 , 有 兴趣 的 读者 请 参见 文献 ［ 3 , 4 , 6 ］ . 
 　 　 由 上面 的 结果 我们 可以 看到 , 文献 ［ 2 ～ 4 ］ 中 所 给出 的 算法 模式 可以 由 本文 所 给出 的 算法 框架 得到 . 我们 还 推广 了 文献 ［ 2 ～ 4 ］ 中 的 结果 . 例如 , 本文 所 定义 的 选择 操作 就是 对 文献 ［ 2 , 3 ］ 中 所 定义 的 横向 组合 运算 的 推广 , 也就是说 横向 组合 运算 是 选择 操作 中 的 一种 . 通过 我们 所 定义 的 组合 选择 控制关系 和 变换 可以 很 容易 地来 描述 组合 操作 的 过程 , 而 文献 ［ 2 ～ 4 ］ 却 没有 做到 这 一点 . 另外 , 文献 ［ 2 ～ 4 ］ 所 给出 的 算法 模式 是 基于 问题 的 一种 严格 的 描述 方法 , 而 这里 我们 所 给出 的 算法 框架 并 不是 基于 某 一种 问题 的 描述 方法 , 虽然 我们 也 给出 了 问题 结构 和 问题 实例 的 一种 描述 , 但 这 只是 为了 叙述 和 讨论 的 方便 , 我们 还 可以 给出 其他 形式 的 描述 方法 , 设计 基于 该种 问题 描述 的 选择 操作 和 组合 操作 就 可以 了 . 
 　 　 一个 算法 , 若 它 的 各种 应用 的 不同 是 附加 在 这个 算法 的 前面 或 后面 , 而 没有 必要 再 改写 原来 的 算法 , 则 称 该 算法 是 模块化 算法 ［ 5 ］ . 在 用 面向对象 的 方法 进行 程序设计 时 , 我们 若 已经 对 一个 模块化 算法 进行 了 编码 , 当 我们 再 用到 该 算法 时 就 可以 建立 一个 子类 , 将 该 算法 继承 下来 使用 , 而 没有 必要 再 对 它 重新 进行 编码 . 对于 我们 这里 给出 的 算法 框架 , 在 用 面向对象 的 方法 进行 程序设计 时 , 也 有 同样 的 优点 . 例如 , 我们 在 给出 了 一个 选择 操作 或 组合 操作 的 编码 后 , 当 我们 再次 用到 该 选择 操作 或 组合 操作 时 , 就 没有 必要 对 它 进行 重新 编码 , 而 直接 继承 下来 使用 就 可以 了 . 
 　 　 本文 研究 得到 国家自然科学基金 资助 . 作者 栾尚敏 , 1968 年生 , 博士 , 讲师 , 主要 研究 领域 为 算法 设计 自动化 , 形式化 方法 , 人工智能 . 李未 , 1943 年生 , 博士 , 教授 , 博士生 导师 , 中国科学院 院士 , 主要 研究 领域 为 并发程序 设计 语言 , 操作 语义 , 类型 理论 , 人工智能 . 马绍汉 , 1938 年生 , 教授 , 博士生 导师 , 主要 研究 领域 为 算法 , 并行算法 , 人工智能 . 
 　 　 本文 通讯联系 人 : 栾尚敏 , 北京 100083 , 北京航空航天大学 计算机科学 与 工程系 
 作者 单位 ： 栾尚敏 　 李 　 未 ( 北京航空航天大学 计算机科学 与 工程系 　 北京 　 100083 ) ； 马绍汉 ( 山东大学 计算机科学 系 　 济南 　 250100 ) 
 参考文献 
 　 1 　 L   Jian .   Framework   of   algorithm   correctness   in   NDADAS .   Science   in   China   ( series   A ) ,   1991 , 34 ( 7 ) : 875 ～ 884 
 　 2 　 Helman   P .   An   algebra   for   search   problems   and   their   solution . In :   Kanal   L ,   Kumar   V   eds .   Search   in   Artificial   Intelligence . Berlin :   Springer - Verlag ,   1988.28 ～ 90 
 　 3 　 栾尚敏 , 马绍汉 . 一类 问题 的 描述 方式 及其 算法 . 计算机 学报 , 1995 , 18 ( 10 ) : 755 ～ 762 
 ( Luan   Shang - min ,   Ma   Shao - han .   A   common   model   for   a   class   of   problems   and   their   algorithms .   Chinese   Journal   of   Computers ,   1995 , 18 ( 10 ) : 755 ～ 762 ) 
 　 4 　 栾尚敏 , 马绍汉 . 搜索 问题 的 代数 描述 及其 算法 . 计算机 研究 与 发展 , 1997 , 34 ( 11 ) : 801 ～ 806 
 ( Luan   Shang - min ,   Ma   Shao - han .   An   algebraic   model   for   seach   problems   and   their   algorithm .   Computer   Research   and   Development ,   1997 , 34 ( 11 ) : 801 ～ 806 ) 
 　 5 　 Tello   E   R .   Objected - oriented   Programming   for   Artificial   Intellegence .   Berlin :   Springer - Verlag ,   1989 
 　 6 　 栾尚敏 . 面向对象 的 方法 库 设计 ［ 硕士学位 论文 ］ . 济南 : 山东大学 , 1993 
 ( Luan   Shang - min .   Object - oriented   method   base   design   ［ MS .   Thesis ］ .   Ji ' nan :   Shandong   University ,   1993 ) 
 　 7 　 Selman   B ,   Levesque   H ,   Mitchell   D .   A   new   method   for   solving   hard   satisfiability   problem . In :   Clancey   W   ed .   Proceedings   of   the   10th   National   Conference   on   Artificial   Intelligence   ( AAAI - 92 ) .   San   Jose ,   CA :   MIT   Press ,   1992 .   440 ～ 446 
 1998 - 02 - 23 收到 原稿   
 1998 - 08 - 27 收到 修改稿 
