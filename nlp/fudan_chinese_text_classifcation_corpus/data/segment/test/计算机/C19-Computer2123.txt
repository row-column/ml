计算机 工程 
 COMPUTER   ENGINEERING 
 1999 年   第 25 卷   第 12 期   vol.25   No.12   1999 
 
 
 
 视图 事务 经历 的 串行化 调度 分析 
 焦 　 容 　 虞险云 　 严哲南 　 陈 金海 
 1   串行化 调度 与 数据 一致性 
 　 　 实例 化 视图 ( Materialized   View ) 是 提高 数据仓库 查询 效率 的 重要 技术 。 相比 虚拟 视图 ( Virtual   View ) ， 它们 都 从 数据仓库 数据源 派生 出来 ， 但 在 数据仓库 中有 实例 化 视图 元组 的 物理 存储 ， 而 虚拟 视图 的 元组 分布 在 一些 相关 的 数据源 中 。 实例 化 视图 的 元组 物理 存储 可 加速 访问速度 ， 同时 也 带来 了 数据源 更新 导致 的 视图 数据 不 一致 问题 。 在 许多 数据仓库 应用 中 ， 比如 银行业 、 零售业 等 行业 由于 数据量 非常 大 ， 视图 数据 不 一致 现象 大量 存在 ， 数据 的 一致性 成 了 数据仓库 视图 维护 的 " 生命线 " 。 
 　 　 视图 数据 不 一致 的 一个 很 重要 原因 是 多个 数据源 更新 操作 并发 执行 。 如果 能 设法 保证 事务 调度 的 可 串行化 特性 ， 那么 就 能 解决 并发 事务 导致 的 数据 不一致性 问题 。 串行化 调度 的 显著 优点 在于 它 的 执行 的 原子 性 ， 调度 中 的 每 一 事务 操作 都 集中 在 一起 ， 上 一 事务 执行 完后 才 开始 下 一 事务 ， 各 事务 之间 互不 干扰 。 正是 由于 串行 事务 各 事务 彼此 保持 相对 独立 ， 串行 事务 被 取作 数据 一致性 和 正确性 的 标准 。 本文 将 就 实例 化 视图 经历 的 可 串行化 作 一些 探讨 。 
 2   实例 化 视图 的 串行化 调度 理论 
 　 　 解决 串行化 调度 问题 ， 我们 会 首先 想到 传统 的 2PL 协议 。 2PL 协议 适用 条件 很 简单 ， 要求 一个 事务 内部 的 所有 加锁 操作 应 在 所有 撤锁 操作 之前 发生 。 不幸 得 很 ， 实例 化 视图 维护 与 数据源 的 更新 操作 相互 勾连 后 ， 2PL 协议 在 解决 实例 化 视图 的 串行化 问题 时 遇到 了 困难 。 对 2PL 协议 加以 扩展 ， 本文 将 提出 一个 新 的 实例 化 视图 的 串行化 问题 。 在 介绍 该 理论 之前 ， 先 简要 介绍 一下 串行化 理论 的 基本知识 。 
 2.1   串行化 理论 的 基本知识 
 　 　 实例 化 视图 的 串行化 理论 会 用到 几个 概念 ， 有 必要 严格 定义 几个 概念 。 
 　 　 定义 1 ： 实例 化 视图 经历 可 串行化 并发 事务 经历 可 串行化 当且 仅 当 这些 并发 事务 对 实例 化 视图 产生 的 影响 与 它们 依次 顺序 执行 产生 的 影响 相同 。 
 　 　 定义 2 ： 本地化 谓词 ( Local   Predicate ) 
 　 　 我们 知道 ， 视图 一般 用 SQL 语句 来 定义 ， 一句 SQL 语句 实际上 可 看作 一个 谓词 。 那么 所谓 本地化 谓词 就是指 该 谓词 ( 具体来说 即该 SQL 语句 ) 涉及 的 所有 属性 都 来自 同一个 关系 表 。 
 　 　 定义 3 ： 本地化 查询 ( Localized   Query ) 
 　 　 考虑 由 SQL 语句 查询 定义 的 任意 一个 视图 V ， 把 该 查询 本地化 以 构建 本地化 查询 视图 V ' 。 有 两个 步骤 ： 
 　 　 1 ) 省略 ： 省略 SQL 中 的 GROUPBY 和 HAVING 子句 ， 以及 SELECT 子句 的 集合 属性 ， 例如 SUM ( ) 、 AVG ( ) 等 属性 。 
 　 　 2 ) 代替 ： 构造 最强 条件 C ， C 中 只 含 两类 谓词 ： 本地 谓词 或 只 涉及 SELECT 子句 中 出现 过 的 属性 的 谓词 。 用 条件 C 代替 原有 WHERE 子句 中 的 条件 。 
 　 　 定义 4 ： 派生 集 ds ( Derivation   Set ) 
 　 　 对于 前面 提到 的 本地化 查询 视图 V '   ， V 与 V ' 之间 存在 共同 属性 。 选择 出 V ' 里面 的 一些 元组 ， 这些 元组 在 共同 属性 上 的 值 与 V 的 元组 这些 属性 值 相等 。 
 　 　 举个 例子 来 直观 说明 以上 一些 定义 。 
 　 　 分析 如下 创建 视图 V 的 SQL 语句 ： 
 　 　 CREATE   VIEW   AS 
 　 　 SELECT   Stu . StuID , avg ( Score )   FROM   Stu , Tutor , Subject   
 　 　 　 　 WHERE   Stu . StuID = Tutor . StuID   and   Tutor . StuID = Subject . 
 StuID 
 　 　 　 　 and   Subject . Subname = ' Law ' 
 　 　 GROUPBY   Stu . StuID 
 　 　 HAVING   avg ( Score ) > 60 
 　 　 那么 ， 根据 本地化 查询 视图 的 构造 规则 ， 在 构造 强 条件 C 时要 删除 WHERE 子句 中 的 条件 Tutor . StuID = Subject . StuID ， 因为 这个 条件 涉及 两个 关系 表 ， 非 本地化 谓词 。 最终 构造 结果 如下 ：   
 　 　 SELECT   Stu . StuID   FROM   Stu , Tutor , Subject 
 　 　 　 　 WHERE   Stu . StuID = Tutor . StuID   and   Subject . Subname = ' Law ' 
 　 　 考虑 视图 V 的 元组 t = ( 13315 ,   90 ) , 13315 是 学号 属性 Stu . StuID 的 值 ， 该 学生 基本 表中 平均分 属性 avg ( Score ) 值为 90 。 派生 集 ds ( t ) 是 以下 3 个 集合 的 并 集 ： 
 　 　 . 所有 学 号 ( StuID ) 为 13315 的 Stu 表中 的 元组 集合 
 　 　 . 所有 导师 情况表 ( Tutor ) 中 的 StuID ( 所带 学生 ) 属性 为 13315 的 元组 集合 
 　 　 . 所有 科目表 ( Subject ) 科目 为 法学 ( Law ) 的 元组 集合 。 
 　 　 这样 派生 集 ds ( t ) 就 像是 视图 元组 t 的 晴雨表 。 对 ds ( t ) 的 任何 修改 都 将 影响 到 t ， 触发 系统对 t 做 相应 的 更新 操作 。 
 2.2   有效 经历 转化 
 　 　 先 介绍 将 用到 的 几个 记号 。 r , w 表示 对 基本 表 的 读 和 写 ， rV 表示 读 实例 化 视图 的 元组 ， 应 指出 rV 可 等价 地 解释 成读 虚拟 视图 ( Virtual   View ) 的 元组 ， 但 虚拟 视图 中 没有 存储 物理 数据 ， 读 虚拟 视图 也 即 读出 与 虚拟 视图 对应 的 基本 表 关系 中 的 有关 元组 。 此外 ， 用 m [ t ] 表示 对 视图 元组 t 的 维护 操作 ， m [ t ] 相当于 宏 操作 ， 由读 所有 基本 表 ， 更新 每个 数据仓库 视图 这些 操作 组成 。 那么 维护 操作   m 什么 时刻 被 调用 呢 ？ 设想 在 事务 T 中 存在 这样 两个 顺序 操作 ， 先对 派生 集 ds ( t ) 中 的 元组 进行 写 操作 ， 接下来 读 视图 元组 t 。 从 上 面对 ds ( t ) 的 讨论 可以 知道 ， 对 ds ( t ) 中 的 元组 进行 写 操作 实际上 导致 了 视图 元组   t 的 变化 ， 因此 必须 在 这 两个 顺序 操作 中 插入 维护 操作 m 。 具有 这样 特征 的 实例 化 视图 事务 经历 称为 有效 经历 。 
 　 　 可以 想象 ， 如果 把 对 具备 有效 经历 特征 的 实例 化 视图 的 读 操作 转 译成 对 虚拟 视图 的 读 操作 ， 有效 经历 的 串行化 问题 就 转化成 虚拟 视图 经历 的 串行化 问题 。 虚拟 视图 没有 维护 操作 m [ t ] 的 概念 ， 所以 转译 时应 省略 掉 这些 维护 过程 。 
 2.3   实例 - 串行化 图 的 构造 
 　 　 定义 5 ： 实例 化 视图 V 的 依赖图 G ( V ) 
 　 　 G ( V ) 是 一个 有向图 。 每个 基本 表 关系 和 用于 定义 视图 V 的 其他 视图 都 对应 一个 结点 。 如果 视图 结点 N2 是从 结点 N1 派 生出 的 ， 那么 有 一条 从 N1 指向 N2 的 有 向 边 。 
 　 　 定义 6 ： 虚拟 视图 的 冲突 操作 
 　 　 这里 借鉴 2PL 串行化 理论 的 冲突 操作 概念 ， 如果 虚拟 视图 两个 操作 中有 一个 写 操作 的话 ， 就 定义 这是 一对 冲突 操作 。 虚拟 视图 的 冲突 操作 概念 可用 表 1 定义 。 
 表 1   虚拟 视图 冲突 表 
 
 　 r [ u ] rV [ t ] w [ u ] 
 r [ u ] NNY 
 rV [ t ] NNY 
 w [ u ] YYY 
 
 
 　 　 Y 表示 发生冲突 操作 ， N 表示 无 冲突 操作 。 r [ u ] ， w [ u ] 表示 对 基本 表 元组 t 的 操作 ， rV [ t ] 表示 对 虚拟 视图 的 元组 t 的 读 操作 。 当然 u 应是 派生 集 ds ( t ) 中 的 元素 ， u 的 写 操作 w [ u ] 实际上 引起 了 视图 元组 t 的 变化 ， 所以 在 表 1 中 w [ u ] 和 rV [ t ] 是 一对 冲突 操作 。 在 虚拟 视图 冲突 操作 概念 的 基础 上 ， 下面 提出 实例 - 串行化 图 的 构造 规则 。 实例 - 串行化 图 的 构造 规则 ： 
 　 　 1 ) 节点 的 构造 ： 并发 事务 中 的 每个 事务 都 对应 一个 节点 。 
 　 　 2 ) 边 的 构造 ： 如果 Ti 中有 一 操作 先于 Tj 中一 操作 发生 ， 并且 按照 表 1 中 的 冲突 概念 ， 这 两个 操作 是 一对 冲突 操作 ， 那么 有 一条 从 节点 Ti 指向 节点 Tj 的 有 向 边 。 
 　 　 构造 出 实例 - 串行化 图后 ， 可 依据 下面 的 定理 判断 有效 经历 是否 可 串行化 。 
 　 　 定理 ： 一个 有效 经历 是 实例 - 可 串行化 的 当且 仅 当 实例 - 串行化 图是 无环 的 。 
 　 　 限于 篇幅 ， 不 在 本文 给出 该 定理 的 证明 。 但 必须 强调 定理 的 适用 条件 ， 定理 仅 适用 于 实例 化 视图 经历 是 有效 经历 的 情形 。 如果 一个 实例 化 视图 经历 是 无效 经历 ， 这个 实例 化 视图 必定 是 不可 串行化 的 ， 借助 实例 - 串行化 图 的 无 环性 判断 无效 经历 的 可 串行化 没有 任何 意义 。 
 　 　 出现 的 符号 做 一些 说明 ： 
 　 　 . rl [ RX ] ： 对 关系 表 R 中 的 元组 X 加读 锁 。 
 　 　 . r [ RX ] ： 读 关系 表 R 中 的 元组 X 。 
 　 　 . wl [ RX ] ： 对 关系 表 R 中 的 元组 X 加写 锁 。 
 　 　 . w [ RX ] ： 写 关系 表 R 中 的 元组 X 。 
 　 　 . u [ RX ] ： 对 关系 表 R 中 的 元组 X 解锁 。 
 　 　 . VX ： 实例 化 视图 V 中 的 一个 元组 ， 这个 元组 由 关系 表 R 、 S 中 的 相关 元组 RX 和 SX 作 连接 操作 得出 。 
 　 　 . VY ： 与 VX 相似 ， VY 从 关系 表 R 、 S 中 的 相关 元组 RY 和 SY 派生 得出 。 
 　 　 作为 判断 视图 串行化 定理 的 一个 应用 ， 表 2 描述 了 一个 实例 化 视图 串行化 调度 过程 。 不难看出 ， 事务 T1 的 解锁 操作 u [ VY ] , u [ RY ] , u [ VY ] 都 在 所有 加锁 操作 之后 发生 。 同样 ， 事务 T2 和 T3 的 解锁 操作 也 在 加锁 操作 之后 发生 ， 因此 并发 事务 T1 、 T2 和 T3 满足 2PL 协议 。 但是 通过 下面 的 分析 ， 我们 发现 该 事务 调度 并非 串行化 调度 。 
 表 2   各 时刻 的 事务 执行 情况 
 
 时标 T1T2T3 
 1r [ VY ] 　 　 
 2 　 wl [ SY ] 
 3w [ SY ] 
 4wl [ SY ] 
 5 提交 
 6 　 wl [ RY ] 
 7w [ RY ] 
 8u [ RY ] 
 9 提交 
 10m [ VY ] 　 
 11r [ VY ] 
 12r [ VY ] 
 13u [ SY ] , u [ RY ] , u [ VY ] 
 14 提交 
 
 
 　 　 根据 前面 的 视图 有效 经历 概念 ， 时刻 t3 的 w 操作 、 时刻 t7 的 w 操作 与 时刻 t12 的 r 操作 之间 插入 了 时刻 t10 的 维护 操作 m [ t ] ， 表 2 描述 的 经历 为 有效 经历 。 这样 该 有效 事务 经历 就 可以 适用 可 串行化 定理 了 。 
 　 　 时刻 3 出现 的 事务 T2 含读 SY 的 操作 w [ SY ] ， 后面 时刻 7 事务 T3 包含 写 RY 的 操作 w [ RY ] ， 按照 实例 - 串行化 图 的 构造 规则 ， 在 图 1 中 右半部 出现 了 由 T2 指向 T3 的 弧 。 再 注意 到 在 时刻 1 事务 T1 的 r [ VY ] 和 稍后 的 时刻 3 就 发生 了 T2 的 w [ SY ] 操作 构成 了 一对 冲突 操作 ， 于是 图 1 左 半部 中 可 看到 T1 指向 T2 的 弧 。 在 时刻 7 就 发生 了 T3 的 w [ RY ] 操作 和 时刻 12 事务 T1 的 r 构成 了 一对 冲突 操作 ， 于是 图 1 左 半部 中 可 看到 T3 指向 T1 的 弧 。 实例 - 串行化 图 就 包含 一个 环 ， 从而 该 实例 - 串行化 图是 不可 串行化 的 。 
 
 图 1 有环 依赖图 
 　 　 综合 对表 2 描述 的 实例 化 视图 事务 经历 的 讨论 ， 可以 知道 实例 - 串行化 图是 一种 有效 的 解决 可 串行化 问题 的 策略 。 
 2.4   串行化 事务 调度 的 实现 
 　 　 根据 特定 的 需要 ， 数据仓库 的 具体 体系结构 设计 是 相当 灵活 的 。 对 广泛 使用 的 数据仓库 体系结构 - - 斯坦福大学 数据仓库 研究 课题组 ( WareHouse   Information   Project   at   Stanford ,   WHIPS ) 提出 的 WHIPS 结构 作 一些 结构 引伸 ， 我们 提出 一种 改进 的 体系结构 来 支持 视图 可 串行化 特性 ， 如图 3 所示 。 新 结构图 中 增加 了 事务 管理器 这个 新 部件 。 事务 管理器 的 主要 功能 是 ： 集成 器 把 收集 到 的 一系列 更新 信息 发送给 事务 管理器 。 把 有关 更新 操作 组合成 具有 原子 性 的 多个 事务 后 ， 视图 管理器 判断 视图 经历 是否 有效 经历 ， 如果 是 有效 经历 ， 进一步 建立 经历 的 依赖图 ， 判断 其无环性 决定 经历 是否 可 串行化 。 确认 事务 经历 可 串行化 后 ， 把 事务 提交 给 数据仓库 ， 执行 事务 的 实例 化 视图 更新过程 ， 否则 执行 事务 撤回 操作 。 
 　 　 如果 采用 图 2 的 数据仓库 体系结构 判断 出 视图 可 串行化 ， 可 设计 出 事务 调度 的 Seri - Sche 算法 。 先 介绍 算法 中将 涉及 的 专用 术语 ： 
 
 图 2   数据仓库 的 新 结构 
 　 　 ( 1 ) source _ evaluate (   ) 函数 ： 计算 查询 Q 的 查询 结果 A 。 
 　 　 1 ) MV ( Materlized   View ) ： 实例 化 视图 ， 有 实在 的 元组 存放 在 数据仓库 中 。 
 　 　 2 ) AL ( Action   Lists ) ： 对 数据仓库 操作 的 动作 列表 。 
 　 　 3 ) pending ( Q ) :   当 调用 source _ evaluate (   ) 过程 处理 查询 Q 时 ， 同时 发生 了 数据 更新 操作 ， 该 更新 操作 被 暂时 放进 集合 pending ( Q ) 中 。 待 查询 Q 处理 完后 ， 再 对 MV 、 AL 作 相应 的 处理 。 
 　 　 4 ) UQS ( Unanswered   query   set ) ： UQS 为 这样 一类 查询 集 ， 这 类 查询 已 发送至 相关 数据源 ， 但 数据仓库 还 没收 到 相应 查询 结果 。 
 　 　 5 ) V <   Ui   > ： 更新 Ui 对 视图 V 的 影响 。 
 　 　 接着 描述 Seri - Sche 算法 ： 
 　 　 输入 ： 更新 操作 Ui 
 　 　 输出 ： 实例 化 视图 MV 的 最新 状态 
 　 　 伪 代码 ：   
 　 　 　 对 任一 数据源 x 的 处理 ： 
 　 　 1 ) 数据源 完成 数据 更新 Ui 后 ， 把 Ui 发送至 数据仓库 。 
 　 　 2 ) 一旦 收到 Qi 查询 ， 计算 出 当前 数据源 状态 SS [ x ] 下 的 查询 结果 Ai ， 并 发送 Ai 至 数据仓库 。 
 　 　 对 数据仓库 部分 的 处理 ： 
 　 　 1 ) AL 初始化 为 空集 
 　 　 2 ) 收到 更新 Ui 的 信息 后 ：   
 　 　 3 ) if   Ui 是 删除 操作 
 　 　 　 　 begin 
 　 　 4 ) 把 来不及 处理 的 查询 Ui 加到 集合 pending ( Qj ) ; 
 　 　 5 ) 把 key _ delete ( MV , Ui )   函数 加 到 动作 列表 集合 AL 中 
 　 　 　 　 end 
 　 　 6 ) if   Ui 是 插入 操作   begin 
 　 　 7 ) 令 Qi ＝ V < Ui >   并且 集合 pending ( Qi ) 保持 原样 
 　 　 8 ) 执行 函数 source _ evaluate ( Qi ) , 且 将 结果 赋值 给 Ai 
 　 　 9 ) 对 pending ( Qi ) 中 的 每 一个 元素 Uj ,   执行 键 删除 函数 key _ delete ( Ai , Uj ) 
 　 　 10 ) 在 AL 集合 中 加入 insert ( MV , Ai ) 
 　 　 　 end 
 　 　 11 ) UQS 为 空集 时 ， 在 MV 上 执行 动作 列表 集合 AL 中 所有 元素 ， 该 执行 操作 为单 事务 操作 。 注意 不要 增加 与 MV 中 相同 的 元组 。 
 　 　 12 ) 动作 列表 集合 AL 置空 
 　 　 　 End   { of   Seri - Sche 算法 } 
 3   总结 及 思考 
 　 　 本文 通过 举例 的 方式 导出 了 数据仓库 实例 化 视图 的 串行化 理论 ， 利用 该 理论 来 保证 事务 并发 执行 时 的 数据 一致性 。 我们 主要 做 的 工作 是 在 继承 2PL 协议 的 冲突 操作 概念 的 基础 上 ， 作出 改进 ， 提出 实例 - 串行化 图 的 构造 规则 ， 来 判断 数据仓库 实例 化 视图 的 可 串行 性 。 一个 可 串行化 实例 化 视图 必须 同时 满足 两个 条件 ： 首先 该 实例 化 视图 经历 是 有效 经历 ， 这 是 可 串行化 的 必要条件 。 第二个 条件 是 实例 - 串行化 图是 无环 的 。 
 　 　 可是 ， 数据仓库 实例 化 视图 的 并发 控制 研究 是 一个 很 新 的 课题 ， 值得 研究 的 问题 很多 。 举个 例子 ， 在 对 数据仓库 频繁 做 增加 、 删除 等 更新 操作 ， 却 相对 较少 地 做 读数据 基本 表 操作 情况 下 ， 也就是说 数据仓库 负载 失衡 时 ， 本文 提出 的 实例 化 视图 的 串行化 理论 还 是不是 最佳 的 并发 控制 方法 呢 ？ 本文 远远 谈不上 尽善尽美 ， 如果 能 起到 抛砖引玉 的 作用 ， 我们 的 初衷 就 已 获得 满足 。 
 作者 单位 ： 复旦大学 计算机科学 系 ， 上海 200433 
 参考文献 
 1   Yue   Zhuge , Wiener   J   L , Molina   H   G . Multiple   Consistency   for   DataWarehousing . http : / / db . stanford . edu . cn / zhuge / 1996 / mvc . ps 
 2   Bernstein   P   A , Hadzilacos   V , Goodman   N . Concurrency   Control   and   Recovery   in   Database   Systems . Addison - wesley , 1987 
